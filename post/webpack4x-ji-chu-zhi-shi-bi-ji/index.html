<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>webpack4.X 基础知识笔记 | jiegiser的博客</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://jiegiser.github.io/newBlog/favicon.ico?v=1575597820724">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jiegiser.github.io/newBlog/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jiegiser.github.io/newBlog">
  <img class="avatar" src="https://jiegiser.github.io/newBlog/images/avatar.png?v=1575597820724" alt="">
  </a>
  <h1 class="site-title">
    jiegiser的博客
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/jiegiser" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              webpack4.X 基础知识笔记
            </h2>
            <div class="post-info">
              <span>
                2019-12-06
              </span>
              <span>
                42 min read
              </span>
              
            </div>
            
              <img class="post-feature-image" src="https://jiegiser.github.io/newBlog/post-images/webpack4x-ji-chu-zhi-shi-bi-ji.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h4 id="1-webpack-基础知识">1. WebPack 基础知识</h4>
<p>首先需要明白<code>webpack</code>为什么会出现，作用是什么，总之他就是一个模块打包工具；<br>
<code>commonJS</code>的模块导出方式为:</p>
<pre><code class="language-javascript">function SiderBar() {
    var dom = document.getElementById('root');
    var siderbar = document.createElement('div');
    siderbar.innerHTML = 'siderbar';
    dom.append(siderbar);
}

module.exports = SiderBar
</code></pre>
<p><code>commonJS</code>的模块导入(引入)方式为:</p>
<pre><code class="language-javascript">var SiderBar = require('./siderbar.js')
</code></pre>
<p><code>webpack</code>是一个打包工具，，他能识别任何一个模块引入的语法，包括<code>ES Module(也就是 import export)、CommonJS 、CMD 、AMD</code>都可以识别。<code>webpack</code>都能够进行很好的翻译。</p>
<h4 id="2-webpack-安装-使用配置文件-浅析打包输出的内容-loader-使用-loader-打包静态资源图片篇-使用-loader-打包静态资源样式篇">2. Webpack 安装、使用配置文件、浅析打包输出的内容、Loader、使用 Loader 打包静态资源（图片篇）、使用 Loader 打包静态资源（样式篇）</h4>
<h5 id="21-安装有两种方式全局安装与局部安装">2.1 安装有两种方式：全局安装与局部安装</h5>
<ul>
<li>全局安装：<code>npm install webpack webpack-cli -g</code> 不推荐使用,卸载<code>npm uninstall webpack webpack-cli -g</code>;</li>
<li>局部安装：<code>npm install webpack webpack-cli --save-dev</code> 或者<code>npm install webpack webpack-cli -D</code>是等价的。局部安装的直接输入<code>webpack -v</code>是不能运行这个命令的，可以通过 <code>npx webpack -v</code>去运行命令。<code>npx</code>会从项目的<code>node_modul</code>去找<code>wenpack</code>包，所以可以通过<code>npx</code>去查找我们在项目中的<code>webpack</code>包;可以在不同的项目中使用不同版本的<code>webpack</code> ；<br>
输入<code>npm info webpack</code>可以查看包的信息，包括版本等信息。</li>
<li>安装指定版本的<code>webpack</code>:<code>npm install webapck@版本号 webpack-cli -D</code></li>
</ul>
<h5 id="22-使用配置文件">2.2 使用配置文件</h5>
<p><code>webpack</code>在进行打包的时候，首先会查找项目中是否存在配置文件<code>webpack.config.js</code>，如果没有，他会使用默认的配置文件进行打包。<br>
在项目的目录下新建<code>webpack.config.js</code>文件，里面输入内容：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,改成bundle就是说，打包后的文件放在bundle文件夹中
      path: path.resolve(__dirname,'bundle')
    }
}
</code></pre>
<p>代码的注释很详细，就不在重复；上面代码就是说将我们项目中的<code>/src/index.js</code>文件进行打包到<code>bundle</code>文件夹下的<code>bundle.js</code>中。<br>
一般情况，我们将我们的源代码放在<code>src</code>目录下。</p>
<blockquote>
<p>需要注意的是： <code>webpack</code>中默认的配置文件是<code>webpack.config.js</code>，我们可以输入命令<code>npx webpack --config webpackconfig.js</code>将默认的配置文件指向<code>webpackconfig.js</code>这个文件。</p>
</blockquote>
<p>我们每次进行打包的时候，都需要输入命令<code>npm webpack</code>,我们可以在<code>webpack.config.js</code>这个文件中进行配置我们允许的命令；如下面代码：</p>
<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;bundle&quot;: &quot;webpack&quot;
  },
</code></pre>
<p>上面的配置就是当我们输入<code>npm run build</code>的时候相当于输入 <code>npm webpack</code>,进行打包我们的文件。这里运行 <code>npm webpack</code>是不会进行全局检测是否安装了 <code>webpack</code>，而是从项目的<code>node_module</code>去查找。</p>
<blockquote>
<p>补充：查看官网的<code>guides</code>中的<code>Getting started</code>里面的内容</p>
</blockquote>
<h5 id="23-浅析打包输出的内容">2.3 浅析打包输出的内容</h5>
<p>我们输入命令<code>npm run bundle</code>或者<code>npx webpack</code>之后，控制台会输出下面的内容：</p>
<pre><code>Hash: 7d4f5a28d798a39e7e58
Version: webpack 4.31.0
Time: 293ms
Built at: 2019-05-16 08:56:10
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]

WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
</code></pre>
<p><code>Hash</code>：是对应打包成功后文件的<code>Hash</code>值是唯一值；<br>
<code>bundle.js</code>：我们打包出的文件；<br>
<code>Chunks</code>：我们打包后的文件，每一个文件都会有一个自己的<code>id</code>值，这里面存放该文件的<code>id</code>值跟与其他打包后的文件有关系的对应文件的<code>id</code>值；<br>
<code>Chunk Names</code>:存放<code>Chunks</code>中每一个<code>id</code>值对应的名字。这里的<code>main</code>，这里的入口文件，对应的名字就是<code>main</code>；我们前面说到配置打包的入口文件：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: './src/index.js',
</code></pre>
<p>其实是下面的简写形式：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: {
      main: './src/index.js',
    },
</code></pre>
<p><code>WARNING in configuration</code>:这里的警告说，我们在进行打包的时候，没有配置打包的模式与打包的环境；其实我们在没有配置模式的情况下默认是<code>production</code>，如下面的代码：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')
module.exports = {
    // 配置打包模式
    mode: 'production',
    // 入口文件
    entry: {
      main: './src/index.js',
    },
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
      path: path.resolve(__dirname,'dist')
    }
}
</code></pre>
<p>添加之后，再次进行打包就不会出现警告了：</p>
<pre><code>Hash: 81601a0beb210cf86adc
Version: webpack 4.31.0
Time: 632ms
Built at: 2019-05-16 15:20:51
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]
</code></pre>
<p>这个<code>production</code>模式打包后的文件，会对文件进行压缩，上面打包后的文件内容如下：打包为一行；</p>
<pre><code class="language-javascript">!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},t.t=function(e,n){if(1&amp;n&amp;&amp;(e=t(e)),8&amp;n)return e;if(4&amp;n&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;n&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return t.d(n,&quot;a&quot;,n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p=&quot;&quot;,t(t.s=0)}([function(e,n,t){var r=t(1),o=t(2),u=t(3);new r,new o,new u},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;header&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;SiderBar&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;content&quot;,e.append(n)}}]);
</code></pre>
<p>我们将打包模式配置成<code>mode: 'development'</code>;打包后的内容就不会进行压缩，内容如下：</p>
<pre><code class="language-javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
</code></pre>
<h5 id="24-loader解析">2.4 Loader解析</h5>
<p><code>webpack</code>本身只是识别<code>js</code>文件的打包，当我们需要进行打包比如图片等文件时，需要在配置文件里面进行配置；<code>webpack</code>在进行打包的时候，首先是直接打包<code>js</code>文件，然后其他的文件会通过配置文件里面的<code>module</code>里面进行查找对应文件的打包规则；如果我们需要对图片文件进行打包，配置如下：</p>
<pre><code class="language-javascript">    module: {
      rules: [{
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: 'file-loader'
        }
      }]
    },
</code></pre>
<p>然后记得进行安装对应的<code>loader</code>；输入命令：<code>npm install file-loader --save-dev</code>然后运行打包命令就可以了；<br>
<code>loader</code>就是一个打包方案，只要不是.<code>js</code>文件，就需要进行配置打包的规则。</p>
<h5 id="25-使用-loader-打包静态资源图片篇-url-loader的使用">2.5 使用 Loader 打包静态资源（图片篇）、url-loader的使用</h5>
<p>如果我们在打包静态资源的时候，比如图片，默认打包后的结果是会生成一个字符串为图片命名，我们现在希望我们打包之后他的文件名以及扩展名，也就是文件类型都是不会改变，可以进行如下配置：<code>[name].[ext]</code>分别代表的是之前文件的文件名以及之前文件的后缀，他其实就是一个<code>webpack</code>的一个占位符。可以在官网的<code>file-loader</code>里面可以看到很多占位符的用法。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                  // 占位符 Placeholders
                  name: '[name].[ext]'
                }
            }
        }]
    },
</code></pre>
<p>同时我们可以设置打包后输出的的文件夹的位置：下面是将图片文件打包在<code>images</code>文件夹中。可以查看官网的文档里面<code>file-loader</code>的相关配置。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/'
                }
            }
        }]
    },
</code></pre>
<h6 id="url-loader-的使用">url-loader 的使用:</h6>
<p><code>url-loader</code>可以进行上面的打包，但是唯一不同的是，<code>url-loader</code>是将图片直接打包成一个<code>base:64</code>的字符串，进行显示在<code>src</code>中。<br>
<img src="https://img-blog.csdnimg.cn/20190516200022406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这个会有一些问题，是减少了发送<code>http</code>请求，但是如果文件很大，加载的时间也是很长，页面会显示空白。如果图片小，可以使用这种方式进行打包。如果图片很大，需要将图片通过<code>file-loader</code>打包到一个文件夹，这样更适合项目。其实在<code>url-loader</code>中已经考虑到了，我们可以进行添加一个配置进行限制：<code>limit: 2048</code>意思就是如果图片超过2048个字节，也就是<code>2kb</code>就将图片打包到<code>imagees</code>文件夹中，如果小于，就直接生成一个<code>base:64</code>的字符串进行显示。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 2048
                }
            }
        }]
    },
</code></pre>
<p>可以查看官网<code>API</code>进行深入的研究这两个<code>loader</code>；</p>
<h5 id="26-使用-loader-打包静态资源样式篇">2.6 使用 Loader 打包静态资源（样式篇）</h5>
<p>首先需要进行配置打包<code>css</code>文件的打包配置，需要使用<code>style-loader、css-loader</code>两个<code>loader</code>进行打包。其中<code>css-loader</code>他是可以解析我们<code>css</code>文件之间的依赖关系，比如我们的<code>index.css</code>中引用了<code>avatar.css</code>文件，如下：<code>@import './avatar.css';</code>他就会进行解析，之间的依赖关系，最终将这些文件打包到一个文件中。<code>style-loader</code>的作用是，当得到<code>css-loader</code>打包后的内容之后，会将这些挂载到页面的<code>header部分</code>，也就是放在了<code>style</code>标签中。配置如下：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }]
    },
</code></pre>
<p>如果我们需要打包<code>.sass、scss</code>这些其他<code>css</code>文件，我们需要引入<code>sass-loader</code>进行打包:<code>npm install sass-loader node-sass webpack --save-dev</code>如下的配置：</p>
<pre><code class="language-javascript">    module: {
        rules: [ {
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader'
            ]
        }]
    },
</code></pre>
<p>其实<code>loader</code>的执行是有先后顺序的：从上到下、从右到左；比如上面的配置，首先是通过<code>sass-loader</code>进行处理，然后通过<code>css-loader</code>进行处理文件关系，最后通过<code>style-loader</code>进行挂载到页面。</p>
<h6 id="261-对于-css-打包进行添加厂商前缀使用postcss-loader自动添加厂商前缀">2.6.1 对于 css 打包进行添加厂商前缀，使用<code>postcss-loader</code>自动添加厂商前缀:</h6>
<p>首先进行安装<code>npm i -D postcss-loader</code>;然后新建<code>postcss.config.js</code>文件，然后进行安装一个<code>autoprefixer</code>插件，输入命令：<code>npm install autoprefixer -D</code>。<code>postcss.config.js</code>文件配置如下：</p>
<pre><code class="language-javascript">module.exports = {
    plugins: [
      require('autoprefixer')
    ]
}
</code></pre>
<p>最后需要记得在打包配置里面进行添加<code>postcss-loader</code>配置项：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>其实我们的厂商前缀是由<code>postcss-loader</code>里面我们添加的<code>autoprefixer</code>插件给我们添加的厂商前缀。</p>
<h6 id="262-css-loader-中一些常用的配置项">2.6.2 css-loader 中一些常用的配置项：</h6>
<p>我们在进行配置<code>loader</code>的时候，如果里面需要配置参数，那么将<code>loader</code>写成一个对象，而不是数组里面的字符串，我们给<code>css-loader</code>添加一个选项：<code>importLoaders: 2</code>，如下面代码：<code>importLoaders: 2</code>参数的意思是：如果我们在<code>js</code>文件里面通过<code>import</code>语句进行引入<code>scss</code>文件是可以进行打包的，按照我们前面说的，从下往上执行<code>loader</code>,但是如果我们的在<code>js</code>文件中引入的<code>scss</code>文件中还通过<code>import</code>引入了其他<code>scss</code>文件，那么这里的<code>scss</code>文件在进行打包的时候不会进行类似在<code>js</code>文件中<code>scss</code>打包的过程从下往上执行<code>loader</code>，所以我们需要添加配置项<code>importLoaders: 2</code>，意思就是我们在打包<code>scss</code>文件的时候（或者<code>css</code>）需要执行前面两个<code>loader</code>，这样就保证了不管<code>scss</code>文件（或者<code>css</code>）中通过<code>import</code>引入多少其他的<code>scss</code>文件（或者<code>css</code>），都能够正常的打包，都会依次从上到下依次执行<code>loader</code>进行打包。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<h6 id="263-css-文件模块化打包只在一个模块内有效">2.6.3 css 文件模块化打包：只在一个模块内有效</h6>
<p>我们在写<code>css、scss</code>的时候会直接将他们在代码中进行引入，如下：这会导致如果页面创建元素，所有的元素的样式都会受到影响，</p>
<pre><code class="language-javascript">import  './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<p>在<code>createAvatar.js</code>文件中也是创建一个<code>img</code>标签：</p>
<pre><code class="language-javascript">import avater from './avater.png'
function createAvatar () {
    var img = new Image();
    img.src = avater;
    img.classList.add('avater')
    var dom = document.getElementById('root');
    dom.append(img);
}
export default createAvatar
</code></pre>
<p>在<code>index.scss</code>中，代码如下：</p>
<pre><code class="language-css">
body {
    .avater {
        height: 150px;
        width: 150px;
        transform: translate(100px, 100px);
    }
}
</code></pre>
<p>这样写会导致页面中两个图片显示都一样，都使用了<code>index.scss</code>中的样式；解决这个问题，就是我们可以在打包<code>css</code>这些文件的时候，实现模块化打包，如下面代码：<br>
在打包的时候，进行配置打包为模块;<code>modules: true</code>意思就是开启模块化打包。</p>
<pre><code class="language-javascript">module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2,
                    modules: true
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>然后在代码中通过<code>style.avater</code>这种方法，进行添加样式，这样就不影响全部文件了。</p>
<pre><code class="language-javascript">import style from './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(style.avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<h6 id="264-打包字体文件">2.6.4  打包字体文件：</h6>
<p>我们项目里面也经常会用到图片库中的小图片，比如<code>iconfont</code>里面的小图片，我们查看<code>iconfont.css</code>发现，里面引入了<code>eot|ttf|svg|woff</code>这些文件，如下面代码：</p>
<pre><code class="language-css">@font-face {
    font-family: &quot;iconfont&quot;;
    src: url('./font/iconfont.eot?t=1558162704401'); /* IE9 */
    src: url('./font/iconfont.eot?t=1558162704401#iefix') format('embedded-opentype'), /* IE6-IE8 */
    url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAASIAAsAAAAACQgAAAQ7AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCfgqFVIRuATYCJAMMCwgABCAFhG0HWxvRBxHVoy2Q/SxwzuYE2hXq6ImKdq351ClK774P+U+55ftJYCczKxZYca2qhqqHlK24nUQMelK9FgLpdvvtgwTDKPAeOIriDMIYEisANjdD9/zrCMWSnOf9tMy0dKYX0l//czm9awvOD5TLXMuOegGGvYACGmPbAgq0QBL0luFVB7kbx4EAXIwsNBq16ABGoY8jAN1DB/cFS+goFcWEIdaCpQV60LG2WLoDYKX3ffpREAyQWBL61DaDGg5Anff0XpJ1r+50EPD7swBgVwEyIAugAB2FtjaQg1gWGZdtiqTqSgXBe8nrdXDEm+0fHkAkoAm6zBcT0+ISvCeLv2t8jAN/31cBVgAD/KeVEEN3tJC34tqkxgXGTXfu3rlOc+Hr8MTcgtOSZ+3EUtPhtPGde0E3oi52evhU0NLOz59jd2fHqMcOJzH9aVu+ZJ1uCLHUbjdt5HAiDzx61pbXhwd6tFHySNO01ZCj8/OxS00ix/7dJ0PLqOZyCt95MQyuS8liz5VIqjb2mDW2dlPIXA/rQrkT1MMuDA2uc6mtTW+mbvTjrn1LDzj2L9k7nXc2x/GEdvDtNJpV1zp2gypowHGWmss91q3j/kucZHGY9gDD0AZ06pO7BjY2dOwwyZt01y77UnvnPY7KoDOqqHeEt4hBq+jG0Q2HDWvo3qU1Wiwqad9EuDX31jEYFDiWezSPWuu6WdkBXdvGt4yfOiXOrmmLLgk3fnYYtWktF5e2b/3+HjE28ELhIt/x3G1z8/Kr68rbo2ub+FZxU6bGtUxo2zWhbvgrVVl9RW0Z2zqmcVRDu79wi7pB4of00ieV0apXehC7x4L0V6uIUZ1JeW/lSTsn1Ss7KmKZ/kpX76nOnVhdS//Izv3GW+tyT3G/NHRKGJQwMKEjSpfDB3r3Ghz6PXTSnDnclEwKxJNTvXY8GOzXzW/Qg3cPJnmPmsy2+BxQ37ELrJt6fsw7fT/z45fmG22bHfdtLL5pblGya8Ku8ZWrLf/OW/gez1jlt7tslshAHwCA91KekTNJ4nqek8v/ld8g8P38sHdA1T8mFADAS8u9QOzxXirAHAC7m3aCP4MPrFMUoa6XS+JZPC0pO4x+77XgihNe6K5gnvYKDVwIEEaLQOIjGmRMEqoQs8BCKAIrpjZwmRqvFkKMg4xKBZBhPgIS6AhI/F0BWaC7qEJ0g4XNN7AKDBm4ThSypZASuFU74yK4w/oDu1HSplGUX3xDU8LCcaFHfSGfNghd3aaTV0zIfcw436YX0aCZIozoNAyBIDM53KQ+RPLQNLroRfVGsVLqMy6CO1h/wG6UtNNcVObzNzQlLFyBKbO+kE/bOejUWgB6lSUQ5lx6n2/TE9HUKM0UwYgtGIwYgVw8yOEmtaNFJA8a0khDZfX4inh922CmT81okVHCriWZ/1FMit0iU0QrfosS7CXX8isp8K5UVQA=') format('woff2'),
    url('./font/iconfont.woff?t=1558162704401') format('woff'),
    url('./font/iconfont.ttf?t=1558162704401') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
    url('./font/iconfont.svg?t=1558162704401#iconfont') format('svg'); /* iOS 4.1- */
  }
</code></pre>
<p>我们如果直接使用<code>webpack</code>打包会提示报错，无法打包那些后缀的文件，我们可以通过<code>file-loader</code>进行打包这些字体文件，在<code>webpack.config.js</code>里面进行配置，如下：使得将字体文件打包到<code>dist</code>的相对路径里面，我们直接使用。</p>
<pre><code class="language-js">    module: {
        rules: [ {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }]
    },
</code></pre>
<blockquote>
<p>然后我们可以继续深入，查看官网的<code>document</code>中的<code>GUIDS</code>里面的<code>Asset Management</code>里面的内容，还有<code>loader</code>里面的<code>sass-loader、css-loader、postcss-loader</code>进行深入了解。</p>
</blockquote>
<h4 id="3-使用plugins让打包更便捷">3. 使用Plugins让打包更便捷</h4>
<h5 id="3-1-html-webpack-plugin-插件的使用将html进行打包并根据设置的html模板进行打包">3. 1    html-webpack-plugin 插件的使用——将html进行打包，并根据设置的html模板进行打包</h5>
<p>我们在打包的时候，每次打包之后，打包后的文件，并没有<code>index.html</code>就是我们在<code>src</code>文件夹里面写的网页，都需要我们进行复制到<code>dist</code>目录里面，很是麻烦，我们可以使用<code>webpack</code>插件，来帮助我们解决这个问题。<br>
首先需要安装这个插件:<code>cnpm install --save-dev html-webpack-plugin</code>,然后在<code>webpack.config.js</code>里面进行配置，代码如下：</p>
<pre><code class="language-javascript">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>这样，打包之后，会将我们的<code>html</code>文件也会进行打包，<code>html-webpack-plugin</code>这个插件在打包结束后，自动生成一个<code>html</code>文件，并把打包生成的<code>js</code>自动引入到这个<code>html</code>中。我们打开打包后的<code>html</code>文件，会发现，我们在里面的<code>html</code>结构没有显示，比如我们在里面写的<code>&lt;div&gt;&lt;/div&gt;</code>没有被打包显示，这个时候，我们需要对<code>html-webpack-plugin</code>这个插件进行配置一个<code>template</code>选项，让他根据模板进行打包我们的<code>html</code>文件，模板文件也就是我们需要打包的文件，也就是以模板文件进行打包。配置如下：</p>
<pre><code class="language-js">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    })],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p><code>Plugin</code>可以在<code>webpack</code>运行到某一时刻的时候，帮你做一些事情，很类似<code>vue</code>的声明周期函数；</p>
</blockquote>
<h5 id="32-clean-webpack-plugin-插件的使用清除打包地址的文件">3.2  clean-webpack-plugin 插件的使用——清除打包地址的文件</h5>
<p>我们在查看我们打包后的内容，我们如果将<code>output</code>配置里面的输出文件名修改为其他的，我们重新进行打包，会发现，打包是成功了，但是我们修改之前打包的<code>js</code>文件还是存在在<code>dist</code>文件夹中，我们需要做的是，每次打包之前，需要将<code>dist</code>中之前打包的文件先进行删除，然后再次进行打包<code>js</code>文件。这个时候，我们需要引入一个插件<code>clean-webpack-plugin</code>,<br>
首先输入命令进行安装：<code>npm install clean-webpack-plugin -D</code><br>
然后在<code>webpack.config.js</code>里面进行配置，如下：<code>new CleanWebpackPlugin()</code>意思是每次打包之前删除<code>dist</code>里面所有的内容。</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    }),new CleanWebpackPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p>这里需要注意的是<code>HtmlWebpakcPlugin</code>是在打包之后运行的插件，<code>CleanWebpackPlugin</code>是在打包之前运行的插件。还有一个需要注意的是<code>new CleanWebpackPlugin(['dist'])</code>这里的<code>dist</code>是不需要添加的，直接<code>new CleanWebpackPlugin()</code>就好了</p>
</blockquote>
<h4 id="4-entry-与-output-的基础配置">4. Entry 与 Output 的基础配置</h4>
<h5 id="41-多个文件的打包">4.1 多个文件的打包</h5>
<p>我们在打包文件的时候，经常会遇到打包多个文件，而不是一个<code>js</code>文件，这时候我们需要修改我们的配置；比如，下面代码，我们打包<code>main</code>跟<code>sub</code>的文件：</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        sub: './src/index.js'
    },
</code></pre>
<p>如果我们还是用之前的打包输出的配置；就会报错，提示多个文件打包到一个文件的错误:</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'main.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这个时候我们需要配置输出的文件，让他根据入口配置的文件，也就是那个对象的键，根据键来进行打包输出文件，配置如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样，打包后输出的文件分别为<code>main.js</code>跟<code>sub.js</code>；这样就完成了多个文件的打包。</p>
<h5 id="42-将打包后的js文件在html中通过配置cdn地址进行引入">4.2 将打包后的js文件在html中，通过配置cdn地址进行引入</h5>
<p>我们经常会遇到，我们在打包我们的<code>js</code>代码之后，会将<code>js</code>文件放在<code>cdn</code>服务器上，通过<code>cdn</code>服务器的地址来在页面进行引入脚本。比如，我们希望在<code>html</code>引入<code>js</code>的时候地址前面加上<code>cdn</code>域名：<code>http://cdn.com/main.js</code>这样。我们需要在<code>output</code>里面进行配置一个<code>publicPath</code>的选项：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        publicPath: 'http://cdn.com.cn',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>打包后<code>html</code>的引入如下：</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/main.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/sub.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>进一步学习：查看官网的<code>document</code>里的<code>configuration</code>中的<code>output</code>的配置参数。然后进行查看<code>guides</code>里面的<code>output management</code>里的内容。查看<code>plugins</code>里面的<code>htmlwebpackplugin</code>插件，查看该插件对应的官网。</p>
<h4 id="5-sourcemap-的配置">5. SourceMap 的配置</h4>
<p>我们在前面配置了我们的打包模式 为开发者模式：<code>mode: 'development',</code>在这个模式，默认<code>SourceMap</code>已经被配置进去了，我们可以关掉认<code>SourceMap</code>，配置如下：</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'none',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101150701.png" alt="在这里插入图片描述"><br>
如果我们关闭了<code>SourceMap</code>，我们如果在写代码的时候，不小心制造一个小<code>bug</code>，比如说我们把<code>console</code>写成了<code>conssole</code>这样，在打包时，是不会出现问题的，但是在页面的控制台会提示，该方法不存在，我们点击之后，提示打包后的文件的第153行报错，其实我们真正 想知道的不是打包后文件哪里出错，而是我们在源代码里哪个位置出现错误；而<code>SourceMap</code>他是一个映射关系，他知道<code>dist</code>目录下的<code>main.js</code>也就是我们打包生成的文件153行实际上对应是<code>src</code>目录下<code>index.js</code>文件也就是我们的源代码文件中的第58行。我们可以通过<code>SourceMap</code>获取到<code>index.js</code>中第一行代码出错了；所以我们需要进行配置<code>SourceMap</code>，来根据<code>SourceMap</code>的映射关系，找到我们源代码出错位置：我们查看打包后的文件，会多出一个<code>main.js.map</code>的文件，就是我们的源文件，存放着映射关系。</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'source-map',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101052959.png" alt="在这里插入图片描述"><br>
我们可以查看官网有关<code>SourceMap</code>的配置，也就是<code>devtool</code>的配置，其中如果将<code>devtool</code>配置成<code>inline-cheap-source-map</code>意思他会将打包后的<code>SourceMap</code>直接通过地址放在在打包的文件代码的底部：</p>
<pre><code class="language-js">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQ
</code></pre>
<p>这里，需要说明的是，前面我们进行配置成<code>source-map</code>，点击报错，他会提示代码报错位置的行与列，其实我们在查看问题的时候，并不需要精确到哪一列代码出现问题，只需要知道在哪一行；这时候我们可以将<code>devtool</code>配置成<code>cheap-source-map</code>，他只会提示代码在哪一行报错。<br>
这里的<code>cheap-source-map</code>他就会映射我们写的业务代码，比如打包的文件<code>index.js</code>而不会将我们在<code>loder</code>里面引入的第三方模块代码的映射，如果需要映射<code>loder</code>里面的的代码需要将配置修改为<code>cheap-module-inline-source-map</code><br>
还有一种打包方式就是<code>eval</code>，他是打包速度最快的，但是如果代码过多，也会影响打包速度；</p>
<blockquote>
<p>这里建议我们配置<code>sourceMap</code>的打包方式，如果是在<code>development</code>环境进行打包的时候，将<code>devtool</code>配置成<code>cheap-module-eval-source-map</code>，提示的错误比较全，打包速度也是比较快。如果我们代码已经上线，也就是在<code>production</code>模式下，我们可以将<code>devtool</code>配置成<code>cheap-module-source-map</code>，这样提示效果会好一些。</p>
</blockquote>
<h4 id="6-使用-webpackdevserver-提升开发效率">6. 使用 WebpackDevServer 提升开发效率</h4>
<p>我们现在每次进行打包的时候还要需要输入打包命令，打包之后在将<code>html</code>打开，查看打包结果；这样操作是比较麻烦的，我们需要的是可以监听到我们改动的文件，然后自动进行重新打包，我们有三种方法进行配置；</p>
<h5 id="61-第一种我们可以在packagejson进行配置监听文件变化">6.1 第一种：我们可以在package.json进行配置，监听文件变化</h5>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;
  },
</code></pre>
<p>他的意思是，会进行监听我们打包的文件，只要打包文件发生变化，就会重新打包。</p>
<h5 id="62-第二种监听打包文件变化并自动启动服务器加载html文件">6.2 第二种：监听打包文件变化，并自动启动服务器，加载html文件</h5>
<p>我们的第二种打包方式是，我们不仅需要监听打包文件的变化并重新打包，而且需要在打包完成之后，直接打开我们的<code>html</code>文件，类似在服务器中。前提是首先安装<code>webpack-dev-server</code>,输入命令：<code>npm install webpack-dev-server -D</code>。<br>
我们可以在<code>webpack.config.js</code>添加一个<code>devServer</code>配置：</p>
<pre><code class="language-js">module.exports = {
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist'
    }
}
</code></pre>
<p>然后在<code>package.json</code>里面添加一个运行命令，来运行我们的服务器：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;start&quot;: &quot;webpack-dev-server&quot;
  },
</code></pre>
<p>这时候会启动一个服务器，<code>webpack-dev-server</code>比我们之前配置的<code>webpack --watch</code>这种方式的好处是，他不仅会监听我们打包文件变化，并进行更新打包，而且也会重新刷新我们的网页。我们还可以在<code>webpack.config.js</code>中的<code>devServer</code>配置添加一个<code>open: true</code>选项，他会在打开服务器后，自动打开浏览器，并自动访问启动的服务器地址，打开网页，不用我们手动进行将服务器启动后的地址输入到浏览器进行打开：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true
    },
</code></pre>
<p>还有一个就是我们在使用<code>vue-cli</code>脚手架的时候，我们会在<code>devServer</code>里面配置一个<code>proxy</code>选项，用来模拟后台<code>API</code>请求地址或者转发我们的接口<code>API</code>地址，解决跨域代理；如下面的配置：他的意思是当我们访问<code>localhost:8080/api</code>地址的时候，他会自动将地址转发到<code>localhost:3000</code>端口。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      }
    },
</code></pre>
<h5 id="63-第三种自己手写一个服务器实现类似webpack-dev-server的效果">6.3 第三种：自己手写一个服务器，实现类似Webpack-dev-server的效果</h5>
<p>首先在<code>package.json</code>里面进行配置命令，使得运行命令之后，就运行我们的脚本文件：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;middleware&quot;: &quot;node server.js&quot;
  },
</code></pre>
<p>我们可以借助<code>node</code>的框架，去搭建服务器，这里使用<code>express</code>框架来实现，首先进行安装该框架：<code>npm install express webpack-dev-middleware -D</code>,我们这里同时安装了一个<code>webapck</code>的<code>webpack-dev-middleware</code>中间件，用来监听我们打包文件的变化，来自动进行打包。<br>
然后我们修改<code>webpack.config.js</code>里面的<code>output</code>配置，添加一个<code>publicPath: '/'</code>将文件打包成功后的引用地址前面都加一个根路径，确保打包生成文件的引用路径不会出现错误。</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: '/',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>然后我们的<code>server.js</code>代码如下：</p>
<pre><code class="language-js">const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const config = require('./webpack.config.js');
// 进行webpack编译--执行编译器，进行打包一次代码,
// 在node中直接使用webpack
const complier = webpack(config);

const app = express();
// 只要打包的文件内容发生变化，就会重新打包，通过编译器；将打包的文件放在跟webpack.config.js配置的一致
app.use(webpackDevMiddleware(complier, {
  publicPath: config.output.publicPath
}));

app.listen(3000, () =&gt; {
  console.log('server is run')
})
</code></pre>
<p>上面的我们是直接通过调用<code>webpack</code>配置在<code>node</code>里面使用<code>webpack</code>，我们也可以直接在命令行里去执行<code>webpack</code>，可以在官网的<code>API</code>里面的<code>Command Line Interface</code>查找到很多的命令：比如<code>webpack index.js -o main.js</code>将<code>index.js</code>打包成<code>main.js</code>输出。如果需要查找在<code>node</code>里面运行<code>webpack</code>，可以查看<code>node.js APi</code>里面去查找。</p>
<blockquote>
<p>深入学习：打开官网的<code>documentation</code>里面的<code>Guides</code>中的<code>development</code>里面的内容阅读，然后查看<code>configuration</code>里面有关<code>devtool、devServer</code>里面的内容。</p>
</blockquote>
<h4 id="7-hot-module-replacement-热模块更新">7. Hot Module Replacement 热模块更新</h4>
<p>我们使用<code>webpack-dev-server</code>帮助我们进行打包，会发现不会产生一个<code>dist</code>，因为他会生成一个打包文件，不过没有放在文件里面而是放在了计算机的内存中，可以有效提升打包的速度。<br>
我们在写代码的时候，经常会碰到，我们在修改了我们的<code>css</code>文件后，只是想每次在更新页面的时候，只是将样式文件重新加载，进行渲染，并不想让整个页面进行重新加载，破坏了我们页面的状态；我们想做的就是每次改完样式文件之后，只是重新加载样式文件，不破坏页面的状态；我们可以使用热模块更新来解决这个问题：我在<code>webpack.config.js</code>里面的<code>devServer</code>配置项中添加一个<code>hot: true</code>(让<code>webpack-dev-server</code>开启热模块更新的功能)选项跟<code>hotOnly：true</code>(即便是HTML的功能没有生效，也不让浏览器自动重新刷新，)</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
</code></pre>
<p>然后我们在<code>webpack.config.js</code>中引入<code>webpack</code>，在<code>plugin</code>里面进行添加一个<code>webpack</code>的插件<code>webpack.HotModuleReplacementPlugin()</code>;代码如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');
module.exports = {
    //....
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.HotModuleReplacementPlugin()
    ]
 }
</code></pre>
<p>这样，如果只改了<code>css</code>样式，页面不会从新加载，只会重新加载<code>css</code>文件。<br>
如果对于<code>js</code>文件，也想通过热模块更新，在<code>webpack.config.js</code>里面的配置跟上面一样，但是我们在代码里面需要进行判断，加一些代码逻辑，用来判断是否开启热模块更新，然后进行处理我们的逻辑：需要进行监控我们需要修改的文件</p>
<pre><code class="language-js">// 如果支持热模块加载
if(module.hot) {
    // 监控number文件，如果发生改变，就会执行里面的代码。
    // 第一个参数为依赖的文件的名字，
  module.hot.accept('./number', ()=&gt; {
    document.body.removeChild(document.getElementById('number'))
    number();
  })
}
</code></pre>
<blockquote>
<p>查看官方文档<code>guides</code>里面的<code>Hot Module Replacement</code>中的内容深入了解，然后查看<code>api</code>查看<code>Hot Module Replacement</code>配置选项，然后进行查看<code>concepts</code>里面的<code>Hot Module Replacement</code>内容，进行更深入的了解。</p>
</blockquote>
<h4 id="8-使用-babel-处理-es6-语法">8. 使用 Babel 处理 ES6 语法</h4>
<h5 id="81-使用-babel-按需打包js文件">8.1 使用 Babel 按需打包js文件</h5>
<p>首先进行安装，输入命令<code>npm install --save-dev babel-loader @babel/core</code>，然后在<code>webpack.config.js</code>增加一个规则，如下：代码意思就是除了<code>node_modules</code>里面的<code>js</code>内容不检测，其他的<code>js</code>文件文件都通过<code>babel-loader</code>进行加载转换。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot; 
    }
  ]
}
</code></pre>
<p>其实<code>babel-loader</code>只是<code>Babel</code>与<code>webpack</code>之间的一个通讯工具，<code>babel-loader</code>并不会将<code>es6</code>语法翻译为<code>es5</code>语法，而<code>babel/preset-env</code>才是真正转换的工具。首选进行安装，输入命令：<code>npm install @babel/preset-env --save-dev</code>，然后进行配置在<code>webpack.config.js</code>：</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
         presets: [&quot;@babel/preset-env&quot;]
      }
    }
  ]
}
</code></pre>
<p>也可以新建一个<code>.babelrc</code>的文件，然后里面增加配置，启用一些插件。</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}
</code></pre>
<p>这种转换只是一部分，低版本的有些函数还是不存在的，比如<code>promise</code>等函数，我们还需要借助<code>@babel/polyfill</code>，进行对低版本浏览器对<code>es6</code>中这些函数的支持，输入命令进行安装：<code>npm install --save @babel/polyfill</code>,然后全局引入，放在业务代码的最顶部，</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;
</code></pre>
<p>这样全局引入，会将所有<code>es6</code>的新增的函数打包到<code>js</code>文件中，这样会使打包的文件体积增大。我们需要的是在该<code>js</code>文件中使用的<code>es6</code>函数的实现，在<code>webpack.config.js</code>进行配置;</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
       presets: [[&quot;@babel/preset-env&quot;,{
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>就会实现按需加载，如果<code>js</code>中有用到<code>es6</code>新增函数，会将对应的实现代码打包到<code>js</code>中，而不是将全部<code>es6</code>新增的函数实现方式打包进去。</p>
<h5 id="82-打包转换中的其他参数设置打包支持浏览器的版本-编写类库文件babel转换配置">8.2 打包转换中的其他参数（设置打包支持浏览器的版本、编写类库文件babel转换配置）</h5>
<p>我们在打包的选项中，还可以进行配置其他选项，比如可以进行配置打包支持浏览器的版本，<code>babel</code>可以根据打包后支持的浏览器，去进行判断需要打包哪一些<code>es6</code>语法的实现函数，代码如下：这句代码是设置了打包后的为高于谷歌67版本的浏览器。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
      presets: [[&quot;@babel/preset-env&quot;,{
        targets: {
           chrome: &quot;67&quot;,
         },
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>我们如果写业务代码需要使用<code>babel</code>转换的时候，使用上面的配置就可以了，我们如果编写一个类库或者一个UI组件，需要进行不同的配置，配置步骤如下：<br>
安装<code>plugin-transform-runtime</code>,输入命令：<code>npm install --save-dev @babel/plugin-transform-runtime</code>，然后进行安装<code>babel/runtime</code>，输入命令：<code>npm install --save @babel/runtime</code>,然后进行安装<code>babel/runtime-corejs2</code> ,输入命令：<code>npm install --save @babel/runtime-corejs2</code>，然后在<code>webpack.config.js</code>进行配置;这样配置的好处是，我们在使用<code>babel</code>转换的时候，借助<code>polyfill</code>在全局进行注入，这样会污染全局，使用下面的配置，他会以闭包的形式，进行注入支持<code>es6</code>语法的函数。不存在全局污染。</p>
<pre><code class="language-js">    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;,
            options: {
            &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;,{
                &quot;corejs&quot;: 2,
                &quot;helpers&quot;: true,
                &quot;regenerator&quot;: true,
                &quot;useESModules&quot;: false
              }]]
            } 
        }]
    },
</code></pre>
<p>如果我们配置的<code>options</code>会很多的时候，可以在项目里面新建一个<code>.babelrc</code>的文件，将<code>options</code>里面的内容写在这里。然后去掉<code>webpack.config.js</code>中我们配置的<code>babel-loader</code>中<code>options</code>里面的内容。</p>
<h4 id="9-webpack-实现对react框架代码的打包">9. Webpack 实现对React框架代码的打包</h4>
<p>写<code>react</code>首选需要安装他，输入命令<code>npm install react react-dom --save</code>,然后在我们的<code>js</code>文件写<code>react</code>代码，如下：</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;

import React, {Component} from 'react'

import ReactDom from 'react-dom'

class App extends Component {
  return () {
    return &lt;div&gt;Hello World&lt;/div&gt;
  }
}
ReactDom.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
<p>安装<code>babel/preset-react</code>，进行转换；输入命令<code>npm install --save-dev @babel/preset-react</code>,然后在<code>.babelrc</code>文件中增加配置：</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ]
}
</code></pre>
<p>这里的插件执行是从下往上执行的，就是先进行打包<code>react</code>代码，然后进行<code>es6</code>代码的转换。</p>
<h4 id="10-webpack-打包的一些坑">10. Webpack 打包的一些坑</h4>
<p>是遇到很多坑，比如使用了<code>html-webpack-plugin</code>插件，然后我们允许<code>webpack-dev-server</code>命令的时候，我们配置了打包入口的<code>html</code>模板，但是启动服务之后，没有页面显示，查看打包信息出现<code>Entrypoint undefined = index.html</code>，<code>webpack.config.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
        // sub: './src/index.js'
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpakcPlugin({
            template: './src/index.html'
        }),
        
    ],
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>后来经过测试，将输出配置成如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样就可以了，不要配置，打包输出的文件名以及地址就可以，虽然是解决了允许服务器没有显示页面的问题，但是这个解决办法还不是最佳。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1-webpack-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">1. WebPack 基础知识</a></li>
<li><a href="#2-webpack-%E5%AE%89%E8%A3%85-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E6%B5%85%E6%9E%90%E6%89%93%E5%8C%85%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9-loader-%E4%BD%BF%E7%94%A8-loader-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%9B%BE%E7%89%87%E7%AF%87-%E4%BD%BF%E7%94%A8-loader-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%A0%B7%E5%BC%8F%E7%AF%87">2. Webpack 安装、使用配置文件、浅析打包输出的内容、Loader、使用 Loader 打包静态资源（图片篇）、使用 Loader 打包静态资源（样式篇）</a>
<ul>
<li><a href="#21-%E5%AE%89%E8%A3%85%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E4%B8%8E%E5%B1%80%E9%83%A8%E5%AE%89%E8%A3%85">2.1 安装有两种方式：全局安装与局部安装</a></li>
<li><a href="#22-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">2.2 使用配置文件</a></li>
<li><a href="#23-%E6%B5%85%E6%9E%90%E6%89%93%E5%8C%85%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9">2.3 浅析打包输出的内容</a></li>
<li><a href="#24-loader%E8%A7%A3%E6%9E%90">2.4 Loader解析</a></li>
<li><a href="#25-%E4%BD%BF%E7%94%A8-loader-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%9B%BE%E7%89%87%E7%AF%87-url-loader%E7%9A%84%E4%BD%BF%E7%94%A8">2.5 使用 Loader 打包静态资源（图片篇）、url-loader的使用</a>
<ul>
<li><a href="#url-loader-%E7%9A%84%E4%BD%BF%E7%94%A8">url-loader 的使用:</a></li>
</ul>
</li>
<li><a href="#26-%E4%BD%BF%E7%94%A8-loader-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%A0%B7%E5%BC%8F%E7%AF%87">2.6 使用 Loader 打包静态资源（样式篇）</a>
<ul>
<li><a href="#261-%E5%AF%B9%E4%BA%8E-css-%E6%89%93%E5%8C%85%E8%BF%9B%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%8E%82%E5%95%86%E5%89%8D%E7%BC%80%E4%BD%BF%E7%94%A8postcss-loader%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%8E%82%E5%95%86%E5%89%8D%E7%BC%80">2.6.1 对于 css 打包进行添加厂商前缀，使用<code>postcss-loader</code>自动添加厂商前缀:</a></li>
<li><a href="#262-css-loader-%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9">2.6.2 css-loader 中一些常用的配置项：</a></li>
<li><a href="#263-css-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E5%8C%96%E6%89%93%E5%8C%85%E5%8F%AA%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%86%85%E6%9C%89%E6%95%88">2.6.3 css 文件模块化打包：只在一个模块内有效</a></li>
<li><a href="#264-%E6%89%93%E5%8C%85%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6">2.6.4  打包字体文件：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E4%BD%BF%E7%94%A8plugins%E8%AE%A9%E6%89%93%E5%8C%85%E6%9B%B4%E4%BE%BF%E6%8D%B7">3. 使用Plugins让打包更便捷</a>
<ul>
<li><a href="#3-1-html-webpack-plugin-%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%86html%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E5%B9%B6%E6%A0%B9%E6%8D%AE%E8%AE%BE%E7%BD%AE%E7%9A%84html%E6%A8%A1%E6%9D%BF%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85">3. 1    html-webpack-plugin 插件的使用——将html进行打包，并根据设置的html模板进行打包</a></li>
<li><a href="#32-clean-webpack-plugin-%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B8%85%E9%99%A4%E6%89%93%E5%8C%85%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%87%E4%BB%B6">3.2  clean-webpack-plugin 插件的使用——清除打包地址的文件</a></li>
</ul>
</li>
<li><a href="#4-entry-%E4%B8%8E-output-%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE">4. Entry 与 Output 的基础配置</a>
<ul>
<li><a href="#41-%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85">4.1 多个文件的打包</a></li>
<li><a href="#42-%E5%B0%86%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84js%E6%96%87%E4%BB%B6%E5%9C%A8html%E4%B8%AD%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AEcdn%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8C%E5%BC%95%E5%85%A5">4.2 将打包后的js文件在html中，通过配置cdn地址进行引入</a></li>
</ul>
</li>
<li><a href="#5-sourcemap-%E7%9A%84%E9%85%8D%E7%BD%AE">5. SourceMap 的配置</a></li>
<li><a href="#6-%E4%BD%BF%E7%94%A8-webpackdevserver-%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87">6. 使用 WebpackDevServer 提升开发效率</a>
<ul>
<li><a href="#61-%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8packagejson%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96">6.1 第一种：我们可以在package.json进行配置，监听文件变化</a></li>
<li><a href="#62-%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%9B%91%E5%90%AC%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%B9%B6%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E8%BD%BDhtml%E6%96%87%E4%BB%B6">6.2 第二种：监听打包文件变化，并自动启动服务器，加载html文件</a></li>
<li><a href="#63-%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%87%AA%E5%B7%B1%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCwebpack-dev-server%E7%9A%84%E6%95%88%E6%9E%9C">6.3 第三种：自己手写一个服务器，实现类似Webpack-dev-server的效果</a></li>
</ul>
</li>
<li><a href="#7-hot-module-replacement-%E7%83%AD%E6%A8%A1%E5%9D%97%E6%9B%B4%E6%96%B0">7. Hot Module Replacement 热模块更新</a></li>
<li><a href="#8-%E4%BD%BF%E7%94%A8-babel-%E5%A4%84%E7%90%86-es6-%E8%AF%AD%E6%B3%95">8. 使用 Babel 处理 ES6 语法</a>
<ul>
<li><a href="#81-%E4%BD%BF%E7%94%A8-babel-%E6%8C%89%E9%9C%80%E6%89%93%E5%8C%85js%E6%96%87%E4%BB%B6">8.1 使用 Babel 按需打包js文件</a></li>
<li><a href="#82-%E6%89%93%E5%8C%85%E8%BD%AC%E6%8D%A2%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%89%93%E5%8C%85%E6%94%AF%E6%8C%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC-%E7%BC%96%E5%86%99%E7%B1%BB%E5%BA%93%E6%96%87%E4%BB%B6babel%E8%BD%AC%E6%8D%A2%E9%85%8D%E7%BD%AE">8.2 打包转换中的其他参数（设置打包支持浏览器的版本、编写类库文件babel转换配置）</a></li>
</ul>
</li>
<li><a href="#9-webpack-%E5%AE%9E%E7%8E%B0%E5%AF%B9react%E6%A1%86%E6%9E%B6%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%93%E5%8C%85">9. Webpack 实现对React框架代码的打包</a></li>
<li><a href="#10-webpack-%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91">10. Webpack 打包的一些坑</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://jiegiser.github.io/newBlog/post/webpack-4x-gao-ji-gai-nian-bi-ji">
              <h3 class="post-title">
                WebPack 4.X 高级概念笔记
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/jiegiser" target="_blank">jiegiser</a> | 
  <a class="rss" href="https://jiegiser.github.io/newBlog/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
