<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiegiser.github.io/newBlog</id>
    <title>jiegiser的博客</title>
    <updated>2020-06-15T05:49:05.053Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiegiser.github.io/newBlog"/>
    <link rel="self" href="https://jiegiser.github.io/newBlog/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiegiser.github.io/newBlog/images/avatar.png</logo>
    <icon>https://jiegiser.github.io/newBlog/favicon.ico</icon>
    <rights>All rights reserved 2020, jiegiser的博客</rights>
    <entry>
        <title type="html"><![CDATA[geoserver 中 WMS 服务说明]]></title>
        <id>https://jiegiser.github.io/newBlog/post/geoserver-zhong-wms-fu-wu-shuo-ming</id>
        <link href="https://jiegiser.github.io/newBlog/post/geoserver-zhong-wms-fu-wu-shuo-ming">
        </link>
        <updated>2019-12-21T01:10:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p><code>OGC Web</code>地图服务（<code>WMS</code>）规范定义了一个<code>HTTP</code>接口，用于从服务器请求地理参考的地图图像。<code>GeoServer</code>支持<code>WMS 1.1.1</code>（使用最多的<code>WMS</code>版本）以及<code>WMS 1.3.0</code>。<br>
<code>GeoServer</code>还支持样式化图层描述符（<code>SLD</code>）标准对<code>WMS</code>规范的某些扩展，以控制地图输出的样式。</p>
<h3 id="wms可以做什么">WMS可以做什么</h3>
<p><code>WMS</code>提供了用于请求地理空间地图图像的标准接口。这样做的好处是<code>WMS</code>客户端可以从多个<code>WMS</code>服务器请求图像，然后将它们组合到一个用户视图中。该标准保证了这些图像都可以像现实中那样完全重叠。许多服务器和客户端支持<code>WMS</code>。</p>
<h3 id="功能">功能</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exceptions</td>
<td>发生异常</td>
</tr>
<tr>
<td>GetCapabilities</td>
<td>检索有关服务的元数据，包括支持的操作和参数以及可用层的列表</td>
</tr>
<tr>
<td>GetMap</td>
<td>检索指定区域和内容的地图图像</td>
</tr>
<tr>
<td>GetFeatureInfo</td>
<td>检索地图上像素位置的基础数据，包括几何和属性值</td>
</tr>
<tr>
<td>DescribeLayer</td>
<td>指示WFS或WCS检索有关该图层的其他信息。</td>
</tr>
<tr>
<td>GetLegendGraphic</td>
<td>检索地图生成的图例</td>
</tr>
</tbody>
</table>
<p>下面就详细介绍一个每个功能类型。</p>
<h4 id="exceptions">Exceptions</h4>
<p><code>WMS</code>可以报告异常的格式。支持的异常值为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML格式</td>
<td>EXCEPTIONS=application/vnd.ogc.se_xml</td>
<td>Xml输出。（默认格式）</td>
</tr>
<tr>
<td>图形</td>
<td>EXCEPTIONS=application/vnd.ogc.se_inimage</td>
<td>生成图像（在geoserver的图层预览功能中发生异常会使用）</td>
</tr>
<tr>
<td>空白</td>
<td>EXCEPTIONS=application/vnd.ogc.se_blank</td>
<td>生成空白图像</td>
</tr>
<tr>
<td>局部图</td>
<td>EXCEPTIONS=application/vnd.gs.wms_partial</td>
<td>这是一个GeoServer供应商参数，仅适用于getMap请求。返回渲染过程引发异常时渲染的所有内容。可以与WMS配置限制一起使用，以返回部分图像，即使由于超过这些限制之一而被终止的请求也是如此。它也可以与timeout vendor参数一起使用。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>EXCEPTIONS=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>EXCEPTIONS=text/javascript</td>
<td>返回以下格式的JsonP：paddingOutput（…jsonp…）。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<h4 id="getcapabilities">GetCapabilities</h4>
<p>该操作请求有关由<code>WMS</code>服务器提供的操作，服务和数据的元数据。<br>
<code>GetCapabilities</code>操作的参数为：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是一个1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetCapabilities。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>为<code>GetCapabilities</code>操作提供以下特定于供应商的参数。它们在<code>WMS</code>供应商参数部分中有完整记录。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>namespace</td>
<td>否</td>
<td>将响应限制为给定名称空间中的层</td>
</tr>
<tr>
<td>format</td>
<td>否</td>
<td>以某种格式请求功能文档</td>
</tr>
<tr>
<td>rootLayer</td>
<td>否</td>
<td>标记以启用/禁用标准“根”顶层图层元素。值是对还是错。如果为false，则仅当存在多个顶级层时才包括Root元素，如果只有一层，则它将是根层本身。指定后，将以相同的行为覆盖全局WMS设置或图层/组设置。</td>
</tr>
</tbody>
</table>
<p><code>GetCapabilities</code>请求的一个示例：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
service=wms&amp;
version=1.1.1&amp;
request=GetCapabilities
</code></pre>
<p>有被传递到<code>WMS</code>服务器，三个参数<code>service=wms</code>，<code>version=1.1.1</code>和<code>request=GetCapabilities</code>。该<code>service</code>参数告诉<code>WMS</code>服务器即将收到<code>WMS</code>请求。该<code>version</code>参数表示正在请求哪个版本的<code>WMS</code>。该<code>request</code>参数指定<code>GetCapabilities</code>操作。<code>WMS</code>标准要求请求始终包含这三个参数。<code>GeoServer</code>放宽了这些要求（如果省略则通过设置默认版本），但是对于标准合规性，应始终指定它们。</p>
<p>响应是功能<code>XML</code>文档，该文档是<code>WMS</code>服务的详细说明。它包含三个主要部分：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Service</td>
<td>包含服务元数据，例如服务于服务器的组织的服务名称，关键字和联系信息。</td>
</tr>
<tr>
<td>Request</td>
<td>描述WMS服务提供的操作以及每个操作的参数和输出格式。如果需要，可以将GeoServer配置为禁用对某些WMS操作的支持。</td>
</tr>
<tr>
<td>Request</td>
<td>列出可用的坐标系和图层。在GeoServer中，图层以“名称空间：图层”的形式命名。每一层都提供服务元数据，例如标题，摘要和关键字。</td>
</tr>
</tbody>
</table>
<h4 id="getmap">GetMap</h4>
<p><code>GetMap</code>操作是获取到服务器生成的地图。他的请求参数可以控制在地图上显示的一个或多个图层和样式，地图范围的边界框，目标空间参考系统以及输出的宽度，高度和格式。</p>
<p>响应是地图图像或其他地图输出工件，具体取决于请求的格式。<code>GeoServer</code>提供了多种输出格式，以<code>WMS</code>输出格式描述。</p>
<p><code>GetMap</code>操作的标准参数为：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值可以是1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetMap。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>要在地图上显示的图层。值是层名称的逗号分隔列表。</td>
</tr>
<tr>
<td>styles</td>
<td>是</td>
<td>渲染图层的样式。值是样式名称的逗号分隔列表，如果需要默认样式，则为空。列表中的样式名称可能为空，以使用默认的图层样式。</td>
</tr>
<tr>
<td>srs/crs</td>
<td>是</td>
<td>地图输出的空间参考系统。格式是<code>EPSG:nnn</code>。 crs是WMS 1.3.0中使用的参数。</td>
</tr>
<tr>
<td>bbox</td>
<td>是</td>
<td>地图范围的边界框。格式是 minx,miny,maxx,maxy以SRS 为单位。</td>
</tr>
<tr>
<td>width</td>
<td>是</td>
<td>地图输出的宽度（以像素为单位）。</td>
</tr>
<tr>
<td>height</td>
<td>是</td>
<td>地图输出的高度，以像素为单位。</td>
</tr>
<tr>
<td>format</td>
<td>是</td>
<td>地图输出的格式。有关支持的值，请参阅WMS输出格式。</td>
</tr>
<tr>
<td>transparent</td>
<td>否</td>
<td>地图背景是否应该透明。值是true或false。默认为false</td>
</tr>
<tr>
<td>bgcolor</td>
<td>否</td>
<td>地图图像的背景色。格式是RRGGBB。默认为FFFFFF（白色）。</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
<tr>
<td>time</td>
<td>否</td>
<td>地图数据的时间值或范围。有关更多信息，请参见GeoServer WMS中的时间支持。</td>
</tr>
<tr>
<td>sld</td>
<td>否</td>
<td>引用StyledLayerDescriptor XML文件的URL，该URL 可以控制或增强地图图层和样式</td>
</tr>
<tr>
<td>sld_body</td>
<td>否</td>
<td>URL编码的StyledLayerDescriptor XML文档，用于控制或增强地图图层和样式</td>
</tr>
</tbody>
</table>
<p>下面的示例是在<code>SRS:'EPGS：4326'</code>中使用默认样式,将图层输出为<code>PNG</code>的<code>WMS</code>请求：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
request=GetMap
&amp;service=WMS
&amp;version=1.1.1
&amp;layers=topp%3Astates
&amp;styles=population
&amp;srs=EPSG%3A4326
&amp;bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578&amp;
&amp;width=780
&amp;height=330
&amp;format=image%2Fpng
</code></pre>
<p>使用<code>GetMap XML</code>文档的示例<code>WMS</code>请求为：</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ogc:GetMap xmlns:ogc=&quot;http://www.opengis.net/ows&quot;
            xmlns:gml=&quot;http://www.opengis.net/gml&quot;
   version=&quot;1.1.1&quot; service=&quot;WMS&quot;&gt;
   &lt;StyledLayerDescriptor version=&quot;1.0.0&quot;&gt;
      &lt;NamedLayer&gt;
        &lt;Name&gt;topp:states&lt;/Name&gt;
        &lt;NamedStyle&gt;&lt;Name&gt;population&lt;/Name&gt;&lt;/NamedStyle&gt;
      &lt;/NamedLayer&gt;
   &lt;/StyledLayerDescriptor&gt;
   &lt;BoundingBox srsName=&quot;http://www.opengis.net/gml/srs/epsg.xml#4326&quot;&gt;
      &lt;gml:coord&gt;&lt;gml:X&gt;-130&lt;/gml:X&gt;&lt;gml:Y&gt;24&lt;/gml:Y&gt;&lt;/gml:coord&gt;
      &lt;gml:coord&gt;&lt;gml:X&gt;-55&lt;/gml:X&gt;&lt;gml:Y&gt;50&lt;/gml:Y&gt;&lt;/gml:coord&gt;
   &lt;/BoundingBox&gt;
   &lt;Output&gt;
      &lt;Format&gt;image/png&lt;/Format&gt;
      &lt;Size&gt;&lt;Width&gt;550&lt;/Width&gt;&lt;Height&gt;250&lt;/Height&gt;&lt;/Size&gt;
   &lt;/Output&gt;
&lt;/ogc:GetMap&gt;
</code></pre>
<p><code>time</code>参数允许按时间切片和空间图块过滤数据集以进行渲染。</p>
<h4 id="getfeatureinfo">GetFeatureInfo</h4>
<p><code>GetFeatureInfo</code>操作是请求地图上给定位置要素的空间和属性数据。它与<code>WFS GetFeature</code>操作类似，但是在输入和输出方面都不太灵活。由于<code>GeoServer</code>提供了<code>WFS</code>服务，因此建议尽可能不要使用<code>GetFeatureInfo</code>。<br>
<code>GetFeatureInfo</code>操作的一个优点是他的请求使用来自返回的<code>WMS</code>图像的（<code>x，y</code>）像素值。对于有时候获取不到地理参考坐标，这个操作还是很方便的。<br>
<code>GetFeatureInfo</code>操作的标准参数是：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是一个1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetFeatureInfo。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>styles</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>srs/crs</td>
<td>是}	同GetMap操作</td>
<td></td>
</tr>
<tr>
<td>bbox</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>width</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>height</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>query_layers</td>
<td>是</td>
<td>用逗号分隔的一层或多层查询列表。</td>
</tr>
<tr>
<td>info_format</td>
<td>否</td>
<td>功能信息响应的格式。有关值，请参见下文。</td>
</tr>
<tr>
<td>feature_count</td>
<td>否</td>
<td>要返回的最大特征数。默认值为1。</td>
</tr>
<tr>
<td>x / i</td>
<td>是</td>
<td>地图上查询点的X坐标，以像素为单位。左侧为0。 i是WMS 1.3.0中使用的参数键。</td>
</tr>
<tr>
<td>y / j</td>
<td>是</td>
<td>地图上查询点的Y坐标，以像素为单位。0是顶部。 j是WMS 1.3.0中使用的参数键。</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>支持多种<code>GetFeatureInfo</code>响应输出格式。默认的格式是服务器上定义的<code>HTML</code>格式。为了最大程度地控制和定制，客户端应使用<code>GML3</code>并对原始数据本身进行样式设置。支持的格式为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本</td>
<td>info_format=text/plain</td>
<td>简单文本输出。（默认格式）</td>
</tr>
<tr>
<td>GML 2</td>
<td>info_format=application/vnd.ogc.gml</td>
<td>仅适用于简单功能（请参阅复杂功能）</td>
</tr>
<tr>
<td>GML 3</td>
<td>info_format=application/vnd.ogc.gml/3.1.1</td>
<td>适用于简单功能和复杂功能（请参阅“ 复杂功能”）</td>
</tr>
<tr>
<td>HTML</td>
<td>info_format=text/html</td>
<td>使用服务器上定义的HTML模板。有关如何对HTML输出进行模板化的信息，请参见GetFeatureInfo模板。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>info_format=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>info_format=text/javascript</td>
<td>返回JSONP形式：parseResponse(...json...)。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>为<code>GetFeatureInfo</code>操作提供以下特定于供应商的参数。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>否</td>
<td>查询点周围搜索半径的宽度。</td>
</tr>
<tr>
<td>cql_filter</td>
<td>否</td>
<td>过滤返回的数据，采用ECQL格式</td>
</tr>
<tr>
<td>filter</td>
<td>否</td>
<td>以OGC过滤器格式过滤返回的数据</td>
</tr>
<tr>
<td>propertyName</td>
<td>否</td>
<td>要返回的特征属性</td>
</tr>
<tr>
<td>exclude_nodata_result</td>
<td>否</td>
<td>设置为true时，当要素的查询像素值为nodata时，将返回NaN。</td>
</tr>
</tbody>
</table>
<p>下面的示例是从<code>topp:states</code>图层以<code>HTML</code>格式请求要素信息：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
request=GetFeatureInfo
&amp;service=WMS
&amp;version=1.1.1
&amp;layers=topp%3Astates
&amp;styles=
&amp;srs=EPSG%3A4326
&amp;format=image%2Fpng
&amp;bbox=-145.151041%2C21.73192%2C-57.154894%2C58.961059
&amp;width=780
&amp;height=330
&amp;query_layers=topp%3Astates
&amp;info_format=text%2Fhtml
&amp;feature_count=50
&amp;x=353
&amp;y=145
&amp;exceptions=application%2Fvnd.ogc.se_xml
</code></pre>
<p>对<code>GeoJSON</code>格式的特征信息的示例请求为：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
&amp;INFO_FORMAT=application/json
&amp;REQUEST=GetFeatureInfo
&amp;EXCEPTIONS=application/vnd.ogc.se_xml
&amp;SERVICE=WMS
&amp;VERSION=1.1.1
&amp;WIDTH=970&amp;HEIGHT=485&amp;X=486&amp;Y=165&amp;BBOX=-180,-90,180,90
&amp;LAYERS=COUNTRYPROFILES:grp_administrative_map
&amp;QUERY_LAYERS=COUNTRYPROFILES:grp_administrative_map
&amp;TYPENAME=COUNTRYPROFILES:grp_administrative_map
</code></pre>
<p>请求的结果：</p>
<pre><code class="language-js">{
&quot;type&quot;:&quot;FeatureCollection&quot;,
&quot;features&quot;:[
   {
      &quot;type&quot;:&quot;Feature&quot;,
      &quot;id&quot;:&quot;dt_gaul_geom.fid-138e3070879&quot;,
      &quot;geometry&quot;:{
         &quot;type&quot;:&quot;MultiPolygon&quot;,
         &quot;coordinates&quot;:[
            [
               [
                  [
                     XXXXXXXXXX,
                     XXXXXXXXXX
                  ],
                  ...
                  [
                     XXXXXXXXXX,
                     XXXXXXXXXX
                  ]
               ]
            ]
         ]
      },
      &quot;geometry_name&quot;:&quot;at_geom&quot;,
      &quot;properties&quot;:{
         &quot;bk_gaul&quot;:X,
         &quot;at_admlevel&quot;:0,
         &quot;at_iso3&quot;:&quot;XXX&quot;,
         &quot;ia_name&quot;:&quot;XXXX&quot;,
         &quot;at_gaul_l0&quot;:X,
         &quot;bbox&quot;:[
            XXXX,
            XXXX,
            XXXX,
            XXXX
         ]
      }
   }
],
&quot;crs&quot;:{
   &quot;type&quot;:&quot;EPSG&quot;,
   &quot;properties&quot;:{
      &quot;code&quot;:&quot;4326&quot;
   }
},
&quot;bbox&quot;:[
   XXXX,
   XXXX,
   XXXX,
   XXXX
]
}
</code></pre>
<h4 id="describelayer">DescribeLayer</h4>
<p>该<code>DescribeLayer</code>操作主要是通过了解基于<code>SLD-WMS</code>客户端使用。为了制作<code>SLD</code>，需要知道数据的结构。<code>WMS</code>和<code>WFS</code>都有执行此操作的操作，因此<code>DescribeLayer</code>操作仅将客户端路由到适当的服务。<br>
<code>DescribeLayer</code>操作的标准参数是：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是1.1.1。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是DescribeLayer。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>同GetMap</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>支持多种<code>DescribeLayer</code>响应输出格式。最常用的格式是服务器样式的<code>HTML</code>模板。支持的格式为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本</td>
<td>output_format=text/xml</td>
<td>与默认值相同。</td>
</tr>
<tr>
<td>GML 2</td>
<td>output_format=application/vnd.ogc.wms_xml</td>
<td>默认格式。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>output_format=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>output_format=text/javascript</td>
<td>返回以下格式的JsonP：paddingOutput（…jsonp…）。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<p>对图层组上的<code>JSON</code>格式的特征描述的示例请求为：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?service=WMS
&amp;version=1.1.1
&amp;request=DescribeLayer
&amp;layers=sf:roads,topp:tasmania_roads,nurc:mosaic
&amp;outputFormat=application/json
</code></pre>
<p>请求结果：</p>
<pre><code class="language-js">{
  version: &quot;1.1.1&quot;,
  layerDescriptions: [
    {
        layerName: &quot;sf:roads&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wfs/WfsDispatcher?&quot;,
        owsType: &quot;WFS&quot;,
        typeName: &quot;sf:roads&quot;
    },
    {
        layerName: &quot;topp:tasmania_roads&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wfs/WfsDispatcher?&quot;,
        owsType: &quot;WFS&quot;,
        typeName: &quot;topp:tasmania_roads&quot;
    },
    {
        layerName: &quot;nurc:mosaic&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wcs?&quot;,
        owsType: &quot;WCS&quot;,
        typeName: &quot;nurc:mosaic&quot;
    }
  ]
</code></pre>
<h4 id="getlegendgraphic">GetLegendGraphic</h4>
<p>可以查看这篇文章 https://docs.geoserver.org/stable/en/user/services/wms/get_legend_graphic/index.html#get-legend-graphic</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/vue-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/vue-bi-ji">
        </link>
        <updated>2019-12-06T01:57:39.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-传统的-mvp-开发模式与-mvvm-开发模式对比">1. 传统的 MVP 开发模式与 MVVM 开发模式对比</h4>
<ol>
<li>对于传统的<code>mvp</code>开发模式，<code>m</code>也就是<code>model</code>一般是通过发送<code>ajax</code>请求获取到的数据，<code>v</code>也就是视图，<code>p</code>就是<code>Presenter</code>相当于控制器，</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-传统的-mvp-开发模式与-mvvm-开发模式对比">1. 传统的 MVP 开发模式与 MVVM 开发模式对比</h4>
<ol>
<li>对于传统的<code>mvp</code>开发模式，<code>m</code>也就是<code>model</code>一般是通过发送<code>ajax</code>请求获取到的数据，<code>v</code>也就是视图，<code>p</code>就是<code>Presenter</code>相当于控制器，</li>
</ol>
<!-- more -->
<p><code>Presenter</code>作为View和<code>Model</code>之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从<code>View</code>到<code>Model</code>和从<code>Model</code>到<code>View</code>的数据进行“手动同步”，这样<code>Presenter</code>显得很重，维护起来会比较困难。而且由于没有数据绑定，如果<code>Presenter</code>对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，<code>Presenter</code>也需要改动,我们大部分的关注点是在视图与数据，以及通过控制器进行操作。</p>
<ol>
<li>对于<code>vue</code>的开发模式<code>mvvm</code>，他把<code>View</code>和<code>Model</code>的同步逻辑自动化了，与<code>MVP</code>不同，没有了<code>View</code>为<code>Presenter</code>提供的接口，之前由<code>Presenter</code>负责的<code>View</code>和<code>Model</code>之间的数据同步交给了<code>ViewModel</code>中的数据绑定进行处理，当<code>Model</code>发生变化，<code>ViewModel</code>就会自动更新；<code>ViewModel</code>变化，<code>Model</code>也会更新。我们的关注点主要是在<code>model</code>与<code>view</code>之间，而<code>model</code>发生变化，<code>view</code>进行同步更新，这些都交给了<code>viewmodel</code>，<code>mvp</code>的模式我们大部分的关注点是在操作了<code>dom</code>，提高了开发效率。</li>
</ol>
<h4 id="2-一些指令以及使用技巧">2. 一些指令以及使用技巧</h4>
<h5 id="21-vue-中计算属性的使用技巧">2.1.  Vue 中计算属性的使用技巧</h5>
<p><code>get、set</code>；如果是获取数值，通过<code>get</code>获取到值，也可以通过<code>set</code>函数设置值，注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过可以通过其实例作为函数的第一个参数来访问：</p>
<pre><code class="language-js">computed: {
  aDouble: vm =&gt; vm.a * 2
}
</code></pre>
<p><code>get、set</code>用法：</p>
<pre><code class="language-js">var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // =&gt; 2
vm.aPlus = 3
vm.a       // =&gt; 2
vm.aDouble // =&gt; 4
</code></pre>
<blockquote>
<p>计算属性的结果会被缓存，除非依赖的变量变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 我们一般如果处理数据显示，如果声明函数、计算属性、侦听器这三者都可以实现的话，一般建议使用计算数据，因为存在缓存机制。</p>
</blockquote>
<p>计算属性设置值的时候直接使用<code>=</code>，如上面的<code>aPlus</code>数值，而不是与函数类似进行赋值。</p>
<pre><code class="language-js">aPlus = 10
</code></pre>
<h5 id="22-v-bind-绑定-class-与-内联样式">2.2. v-bind 绑定 class 与 内联样式</h5>
<h6 id="221-v-bind-绑定-class">2.2.1.  v-bind 绑定 class</h6>
<p>在<code>v-bind</code>中，绑定<code>class</code>，使用:<code>class=&quot;{active:isActive}&quot;</code>，前面的active如果没有在data中定义是不会报错的，他是一个对象表达式，意思就是<code>active</code>这个类的显示与否都在于<code>isActive</code>这个变量，该变量为布尔类型，为<code>true</code>为显示，为<code>false</code>是不显示。</p>
<pre><code class="language-html">&lt;div
  class=&quot;static&quot;
  v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
&gt;&lt;/div&gt;
</code></pre>
<p><code>data</code>：</p>
<pre><code class="language-js">data: {
  isActive: true,
  hasError: false
}
</code></pre>
<p>渲染的结果：如果<code>hasError</code>的值为<code>true</code>，<code>class</code> 列表将变为<code>&quot;static active text-danger&quot;</code></p>
<pre><code class="language-html">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;
</code></pre>
<p>而如果使用:<code>class=&quot;[chextType, active ]&quot;</code>，这样<code>chextType</code>这个必须在<code>data</code>中定义。<code>div</code>显示的类名就是显示<code>chextType、active</code>变量中存储的类名。另外他也可以与普通的	<code>class</code>共存</p>
<pre><code class="language-html">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p><code>data</code>：</p>
<pre><code class="language-js">data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
</code></pre>
<p>渲染的结果：如果<code>hasError</code>的值为<code>true</code>，<code>class</code> 列表将变为<code>&quot;static active text-danger&quot;</code></p>
<pre><code class="language-html">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这样写将始终添加<code>errorClass</code>，但是只有在<code>isActive</code> 是<code>true</code>时才添加 <code>activeClass</code>。不过，当有多个条件 <code>class</code> 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p>
<pre><code class="language-html">&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>当在一个自定义组件上使用 <code>class</code>属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。<br>
例如，如果你声明了这个组件：</p>
<pre><code class="language-js">Vue.component('my-component', {
  template: '&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;'
})
</code></pre>
<p>然后在使用它的时候添加一些 <code>class</code>：</p>
<pre><code class="language-html">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;
</code></pre>
<p><code>HTML</code> 将被渲染为:</p>
<pre><code class="language-html">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;
</code></pre>
<p>对于带数据绑定的<code>class</code>跟前面是一样的。</p>
<h6 id="222-绑定内联样式">2.2.2.  绑定内联样式</h6>
<p>对象语法：<br>
<code>v-bind:style</code> 的对象语法十分直观——看着非常像<code>CSS</code>，但其实是一个 <code>JavaScript</code> 对象。<code>CSS</code>属性名可以用驼峰式 或短横线分隔 (记得用引号括起来) 来命名：</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">data: {
  activeColor: 'red',
  fontSize: 30
}
</code></pre>
<p>直接绑定到一个样式对象通常更好，这会让模板更清晰：同样的，对象语法常常结合返回对象的计算属性使用。</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
</code></pre>
<p>数组语法:<br>
<code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>自动添加前缀：<br>
当 <code>v-bind:style</code> 使用需要添加浏览器引擎前缀的 <code>CSS</code>属性时，如<code>transform</code>，<code>Vue.js</code> 会自动侦测并添加相应的前缀。</p>
<h5 id="23-v-if-与-v-else-标签必须要连在一起使用不然会抛出错误">2.3. v-if 与 v-else 标签必须要连在一起使用，不然会抛出错误。</h5>
<h5 id="24-key-值">2.4. key 值</h5>
<p><code>Vue</code>在重新渲染页面的时候，会尝试复用页面里面的<code>dom</code>元素，如果页面有两个相同的标签可以添加一个<code>key</code>，这样，<code>vue</code>会区分，不会复用。</p>
<h5 id="25-v-for-循环">2.5.  v-for 循环</h5>
<p>一般在<code>v-for</code>循环的时候，一般建议加一个<code>:key</code>值，绑定一个唯一的标识，不建议直接绑定循环的<code>index</code>，会消耗性能，建议绑定后台传入的数据的主键。</p>
<h5 id="26-vue-中操作数组">2.6. Vue 中操作数组</h5>
<p><code>Vue</code>中，不能直接通过数组下标的方法，进行添加数据，这样页面不会渲染的，需要通过数据的操作函数进行增删改查：<code>push、pop、shift、unshift、splice、sort、reverse</code></p>
<h5 id="27-template-模板占位符">2.7.  template 模板占位符</h5>
<p><code>template</code>模板占位符，比如我们使用v-for要循环两个标签，可以在两个标签外层加一个<code>div</code>，但是这个<code>div</code>会在页面显示出来，我们可以把外层的<code>div</code>换成<code>template</code>，不会显示在页面。</p>
<h5 id="28-vue-中遍历对象进行渲染以及对根级别响应式对象添加属性">2.8. Vue 中遍历对象进行渲染以及对根级别响应式对象添加属性</h5>
<p>对象的循环：<code>key</code>是，键；<code>index</code>是位置信息，<code>item</code>是值；</p>
<pre><code class="language-html">&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;
  {{ index }}. {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre>
<p>渲染结果：</p>
<pre><code class="language-html">&lt;div id=&quot;v-for-object-value-name-index&quot; class=&quot;demo&quot;&gt;&lt;div&gt;
    0. title: How to do lists in Vue
  &lt;/div&gt;&lt;div&gt;
    1. author: Jane Doe
  &lt;/div&gt;&lt;div&gt;
    2. publishedAt: 2016-04-10
  &lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>给对象直接修改属性是可以再次进行渲染。<br>
给对象直接添加值，是不变的，可以直接改变引用，换成一个全新的对象，也可以使用<code>set</code>方法，<code>Vue.set(vm.userInfo,&quot;address&quot;,&quot;wuhan&quot;)</code>这样，<code>userInfo</code>对象会增加数据，页面也会变动，重新渲染。也可以使用实例的<code>$set方法</code>，<code>vm.$set(vm.userInfo,&quot;address&quot;,&quot;wuhan&quot;)</code><br>
对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, propertyName, value)</code>方法向嵌套对象添加响应式属性。</p>
<h5 id="29-对于数组的-set-方法">2.9. 对于数组的 set 方法</h5>
<p>对于数组的<code>set</code>方法。<code>Vue.set(vm.userInfo,4,5)</code>，将第四个位置的数据改成5，也可以用实例<code>vm.$set(vm.userInfo,4,5)</code>，所以改变数组的值有两种方法，第一个是使用js的数组操作函数，另一个是使用<code>vue</code>的<code>set</code>方法、</p>
<h5 id="210-v-text-与-v-html">2.10 v-text 与 v-html</h5>
<p>这两个指令旨在显示数值，跟我们直接在<code>html</code>中使用插值表达式类似：</p>
<pre><code class="language-html">&lt;div&gt;{{message}}&lt;/div&gt;
</code></pre>
<p><code>v-text</code>显示的结果与插值表达式一致的，而<code>v-html</code>会展示为<code>html</code>，如果字符串是一个<code>html</code>的字符串，他会进行渲染显示。</p>
<h4 id="3-组件的一些知识">3. 组件的一些知识</h4>
<h5 id="31-is属性">3.1. is属性</h5>
<p>有些 <code>HTML</code> 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。比如<code>tbody</code>里只能显示<code>tr</code>，我们希望在tr里放其他的内容，可以借助<code>is</code>属性：</p>
<pre><code class="language-html">&lt;table&gt;
  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;
&lt;/table&gt;
</code></pre>
<p>这个自定义组件<code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is 特性给了我们一个变通的办法：</p>
<pre><code class="language-html">&lt;table&gt;
  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>这句代码就是说，我们在<code>tbody</code>是显示<code>tr</code>，其实是<code>is</code>里面的组件；遇到组件上的小<code>bug</code>，可以使用<code>is</code>进行解决；比如<code>ol、select</code>等等。</p>
<h5 id="32-子组件中-data">3.2 . 子组件中 data</h5>
<p>子组件中<code>data</code>为函数；是为了保证每一个组件中的数据互不干扰；</p>
<h5 id="33-组件中操作-dom">3.3. 组件中操作 DOM</h5>
<p><code>ref</code>：引用 ，被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code>对象上。如果在普通的<code>DOM</code>元素上使用，引用指向的就是 <code>DOM</code> 元素；如果用在子组件上，引用就指向组件实例：</p>
<pre><code class="language-html">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;
&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;

&lt;!-- `vm.$refs.child` will be the child component instance --&gt;
&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
</code></pre>
<p>获取<code>dom</code>节点，通过<code>this.$refs.ref</code>的值这样获取<code>dom</code>节点；比如上面的结构，如果需要获取<code>this.$refs.child</code>就会获取到对应的<code>dom</code>信息。<br>
当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。<br>
关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
<h5 id="34-组件之间的通讯">3.4. 组件之间的通讯</h5>
<h6 id="341-子组件向父组件派发事件">3.4.1 子组件向父组件派发事件</h6>
<p>使用<code>this.$emit('change')</code>;在父组件触发change事件。<code>@change=&quot;handleChange&quot;;</code>父组件的<code>change</code>事件执行<code>handleChange</code>方法。</p>
<h6 id="342-父组件向子组件传递">3.4.2 父组件向子组件传递</h6>
<p>父组件向子组件传递是通过属性，用<code>v-bind</code>进行绑定，子组件尽量不要修改父组件传进来的参数，可以使用<code>data</code>复制一份传入的值；<br>
对于组件参数的校验，直接在<code>props</code>，接收的时候，为一个对象，<code>type</code>为类型，<code>default</code>为默认值，<code>required</code>为设置参数是否必须，<code>validator(value){return (value.length&gt;5)}</code>传入的值必须大于五；</p>
<pre><code class="language-js">Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<p>还是需要注意的是v-bind绑定的属性后面是一个对象，直接跟<code>class</code>一样绑定属性，为字符串；<code>props</code>传递的属性，在<code>dom</code>渲染出来的<code>HTML</code>上不会显示出来。</p>
<h5 id="35-组件绑定原生事件">3.5 组件绑定原生事件</h5>
<p>给父组件绑定事件，其实是一个自定义事件，想要给组件绑定事件，需要在<code>template</code>里面进行绑定。子组件想要触发自定义事件，需要使用<code>this.$emit('chandleClick')；</code>如果想在父组件添加事件，需要添加<code>native</code>事件修饰符:<code>@click.native=&quot;handleClick&quot;;</code></p>
<blockquote>
<p>这里在子组件向父组件传值定义事件名的时候需要注意，不同于组件和 <code>prop</code>，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。所以如果我们定义了一个<code>this.$emit('myEvent')</code>，然后在父组件监听的时候：<code>&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code>使用短横行的方式去监听，是监听不到的，因为不同于组件和<code>prop</code>，事件名不会被用作一个 <code>JavaScript</code> 变量名或属性名，所以就没有理由使用 <code>camelCase</code> 或 <code>PascalCase</code> 了。并且<code>v-on</code>事件监听器在<code>DOM</code>模板中会被自动转换为全小写 (因为 <code>HTML</code>是大小写不敏感的)，所以<code>v-on:myEvent</code>将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code>不可能被监听到。<br>
所以推荐我们一般使用短横线的方式去命名。</p>
</blockquote>
<h5 id="36-非父子组件传值-bus-总线发布订阅模式观察者模式">3.6. 非父子组件传值（ Bus 总线/发布订阅模式/观察者模式）</h5>
<pre><code class="language-javascript">Vue.prototype.bus = new Vue();
//子组件触发事件
this.bus.$emit('change',this.value)//来触发事件；然后组件进行监听：
//在父组件的mounted中去监听子组件触发的事件
mounted(){
  this.bus.$on('change',function(msg)
    {
      //...
    }
);
</code></pre>
<h5 id="37-插槽相关知识">3.7.  插槽相关知识</h5>
<p>在<code>slot</code>插槽中，如果在父组件中不进行插入<code>dom</code>，在子组件的<code>&lt;slot&gt;</code>默认内容<code>&lt;/slot&gt;</code>,里面的字会显示出来，自定义的内容放在<code>&lt;slot&gt;中间</code>，如果父组件有数据，则不会显示；具名插槽也可以有默认内容。<br>
具名插槽：<br>
有时我们需要多个插槽。例如对于一个带有如下模板的 <base-layout> 组件：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;!-- 我们希望把页头放这里 --&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;!-- 我们希望把主要内容放这里 --&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;!-- 我们希望把页脚放这里 --&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>对于这样的情况，<code>&lt;slot&gt;</code>元素有一个特殊的特性：<code>name</code>。这个特性可以用来定义额外的插槽：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>一个不带<code>name</code> 的 <code>&lt;slot&gt;</code>出口会带有隐含的名字<code>“default”</code>。<br>
在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以<code>v-slot</code>的参数的形式提供其名称：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有<code>v-slot</code>的<code>&lt;template&gt;</code>中的内容都会被视为默认插槽的内容。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code>中包裹默认插槽的内容：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>最终上面的代码渲染的结果为：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意 v-slot 只能添加在一个<code>&lt;template&gt;</code>上</p>
</blockquote>
<p>作用域插槽：在父组件向子组件传入内容时候，需要使用<code>template</code>标签进行包裹，这里的<code>template</code>是必须的</p>
<pre><code class="language-html">&lt;child&gt;
  &lt;template slot-scope=&quot;props&quot;&gt;
    &lt;h1&gt;{{props.item}}&lt;/h1&gt;
  &lt;/template&gt;
&lt;/child&gt;
</code></pre>
<p>在子组件中：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;ul&gt;
    &lt;slot 
       v-for=&quot;item of list&quot; 
       :item=item
       &gt;
    &lt;/slot&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>应用场景：子组件进行循环或者某一dom渲染的样式需要外部传入，进行不同的显示；作用域插槽也就相当于就是插槽之间的数据通讯。</p>
</blockquote>
<h5 id="38-动态组件">3.8.  动态组件</h5>
<p>动态组件：<code>component</code>标签的<code>is</code>属性来自动加载组件:<code>&lt;component :is=&quot;com-a&quot;&gt;&lt;/component&gt;,</code>显示<code>com-a</code>组件；不像<code>v-if</code>，它是将组件进行缓存在内存里面的。</p>
<h5 id="39-vue-中的动画">3.9. vue 中的动画</h5>
<p><code>vue</code>中的动画，需要使用<code>transition</code>标签进行包裹需要动画显示的组件，他会给里面包裹的元素添加多个类名<code>fade-enter、fade-enter-active、fade-enter-to</code>等， 前缀为<code>fade</code>是因为我们添加的<code>name</code>为<code>fade，vue</code>默认为<code>v-enter、v-enter-active</code>等等。<code>div</code>标签外只要使用<code>transition</code>包裹，<code>div</code>不管使用<code>v-show</code>还是<code>v-if</code>过渡动画都是可以显示的。如果我们需要自定义类名，直接在<code>transform</code>标签上添加 <code>enter-active-class=&quot;active&quot; leave-active-class=&quot;leave&quot;</code>对应的<code>active</code>以及<code>leave</code>是自定义的类名；<br>
<code>vue</code>中使用<code>animate.css</code>在<code>transition</code>标签上直接使用：<code>enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated shake&quot;</code>；<br>
为了让<code>div</code>能在初次进去页面的时候有动画，添加一个自定义属性<code>appear-active-class</code>,还需要加一个<code>appear</code>，意思就是让组件第一次显示的时候也有一个动画效果，就是<code>appear-active-class</code>；可以添加属性<code>type=&quot;&quot;</code>来指定动画播放时长；</p>
<h5 id="311-非-props-特性">3.11. 非 Props 特性</h5>
<p>一个非<code>prop</code>特性是指传向一个组件，但是该组件并没有相应 <code>prop</code>定义的特性。<br>
因为显式定义的 <code>prop</code> 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。<br>
例如，想象一下你通过一个 <code>Bootstrap</code> 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code>上用到一个 <code>data-date-picker</code>特性。我们可以将这个特性添加到你的组件实例上：<br>
然后这个<code>data-date-picker=&quot;activated&quot;</code>特性就会自动添加到<code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<h5 id="312-组件中替换合并已有的特性">3.12. 组件中替换/合并已有的特性</h5>
<p>如果定义了一个组件 <bootstrap-date-input> 的模板是这样的：</p>
<pre><code class="language-html">&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;
</code></pre>
<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<pre><code class="language-html">&lt;bootstrap-date-input
  data-date-picker=&quot;activated&quot;
  class=&quot;date-picker-theme-dark&quot;
&gt;&lt;/bootstrap-date-input&gt;
</code></pre>
<p>在这种情况下，我们定义了两个不同的<code>class</code> 的值:</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code>就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code>和<code>style</code> 特性会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h5 id="313-组件的禁用特性继承">3.13. 组件的禁用特性继承</h5>
<p>如果你不希望组件的根元素继承特性，也就是说你不希望你的组件的根元素取绑定你没有接受的属性值，你可以在组件的选项中设置 inheritAttrs: false。例如：</p>
<pre><code class="language-js">Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
</code></pre>
<p>这尤其适合配合实例的 <code>$attrs</code> 属性使用，该属性包含了传递给一个组件的特性名和特性值，例如：</p>
<pre><code class="language-js">{
  required: true,
  placeholder: 'Enter your username'
}
</code></pre>
<p>有了 <code>inheritAttrs: false</code>和<code>$attrs</code>，你就可以手动决定这些特性会被赋予哪个元素。在撰写基础组件的时候是常会用到的：</p>
<pre><code class="language-js">Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    &lt;label&gt;
      {{ label }}
      &lt;input
        v-bind=&quot;$attrs&quot;
        v-bind:value=&quot;value&quot;
        v-on:input=&quot;$emit('input', $event.target.value)&quot;
      &gt;
    &lt;/label&gt;
  `
})
</code></pre>
<blockquote>
<p>注意<code>inheritAttrs: false</code> 选项不会影响<code>style</code> 和 <code>class</code>的绑定。</p>
</blockquote>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 <code>HTML</code>元素，而不会担心哪个元素是真正的根元素：</p>
<pre><code class="language-html">&lt;base-input
  v-model=&quot;username&quot;
  required
  placeholder=&quot;Enter your username&quot;
&gt;&lt;/base-input&gt;
</code></pre>
<p>可以看到我们的组件并没有接收<code>required</code>以及<code>placeholder</code>属性，因此，<code>$attrs</code>的值就是：</p>
<pre><code class="language-js">{
  required: true,
  placeholder: 'Enter your username'
}
</code></pre>
<p>然后我们在组件中直接将这些属性进行绑定了：<code>v-bind=&quot;$attrs&quot;</code>，也就是说<code>$attrs</code>存储非<code>prop</code>特性，<code>inheritAttrs</code>控制<code>vue</code>对非<code>prop</code>特性默认行为，在标签内添加<code>$attrs</code>可以渲染上未注册的属性<code>inheritAttrs:false</code>是允许组件绑定的未注册属性渲染到组件根节点上的。<code>$attrs</code>是一个对象。</p>
<h4 id="4-vue-cli-以及-vue-router">4.  vue-cli 以及 vue-router</h4>
<h5 id="41-javascript-中-promise-对象与-callbacks-的区别">4.1. Javascript 中 Promise 对象与 callbacks 的区别</h5>
<p><code>Javascript</code>中<code>Promise</code>对象与<code>callbacks</code>的区别进行比较，显著的优点就是，<code>promise</code>对象减少了嵌套，有效的防止了进入回调地狱；并且可以一次触发多个<code>promise</code>对象：</p>
<pre><code class="language-javascript">	const eatMeal=Promise.all([firstPromise,burgerPromise,drinkPromise]) 
	.then([fries,burger,drinks]=&gt;{
	console.log(`Chomp. Awesome ${burger}`);
	console.log(`Chomp. Awesome ${fries}`);
	console.log(`Chomp. Awesome ${drinks}`);
	})；
</code></pre>
<p><code>reject</code>与<code>reslove</code>使用，在创建<code>promise</code>对象的时候进行判断，如果符合条件，就执行<code>resolve</code>，不符合就执行<code>reject</code>；<br>
然后就是<code>.then</code>，不管是成功还是失败，都会执行，也就是执行<code>reject</code>的时候会执行<code>.catch</code>；<code>.catch</code>是执行失败的时候会调用。</p>
<h5 id="42-vue-cli-知识">4.2. vue-cli 知识</h5>
<p><code>.vue</code>文件是代表<code>vue</code>的一个组件，在<code>js</code>文件中我们创建一个组件，是通过<code>Vue.component('com-a',{})</code>这样，在<code>vue</code>工程化中，我们使用<code>.vue</code>的文件进行创建组件。<br>
对于<code>vue-cli</code>脚手架的理解，首先我们在根目录的<code>main.js</code>文件中，可以看到：引用了<code>route</code>r以及<code>app</code>文件。</p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  // 局部组件
  components: { App },
  // 下面这句话意思是将app组件渲染在页面中，可以不在这里写，直接在index里面进行书写app标签。
  template: '&lt;App/&gt;'
})

// 路由 &lt;route-view&gt;显示的是当前路由地址所对应的内容
</code></pre>
<p>在<code>App.vue</code>文件中，我们可以看到：<code>&lt;route-view&gt;</code>显示的是当前路由地址所对应的内容 ,</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    [外链图片转存失败(img-cbxcO81D-1562120294364)(https://mp.csdn.net/mdeditor/assets/logo.png)]
    &lt;!-- &lt;route-view&gt;显示的是当前路由地址所对应的内容 --&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;
</code></pre>
<p>打开<code>Router</code>夹子中的<code>index.js</code>文件：它配置了当路由显示为<code>home</code>，也就是<code>http://localhost:8080/#/home</code>这样的时候，显示组件<code>HelloWorld</code>，这样控制到不同的路由显示不同的内容。</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/home',
      name: 'HelloWorld',
      component: HelloWorld
    }
  ]
})

</code></pre>
<p>下面的代码注释：</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import Home from '@/pages/home/Home'
import List from '@/pages/list/List'

Vue.use(Router)

export default new Router({
  routes: [
    // 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
    {
      path: '/',
      // 路由名字
      name: 'home',
      component: Home
    }, {
      // 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
      path: '/list',
      name: 'List',
      component: List
    }
  ]
})
</code></pre>
<p>有关<code>.vue</code>中的页面跳转，以前我们使用<code>a</code>标签进行跳转的，在<code>.vue</code>中，我们使用<code>&lt;router-link&gt;</code>，进行跳转，如下面代码：</p>
<pre><code class="language-javascript">&lt;template&gt;
&lt;!-- 这里需要注意的是template只能包裹一个内容，如果有多个，需要在外层再加一个div --&gt;
  &lt;div&gt;
    &lt;div&gt;home&lt;/div&gt;
    &lt;!-- 页面跳转 to里面是跳转到根路径下的list页面，就是路由里面配置--&gt;
    &lt;router-link to=&quot;/list&quot;&gt;列表&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // 组件的名字
  name: 'Home'
}
&lt;/script&gt;

&lt;style&gt;
div {
  font-size: 19px;
}
&lt;/style&gt;

</code></pre>
<p>当然我们可以使用<code>router</code>的函数式导航的方式进行跳转页面：可以看到跳转到了<code>backCar</code>页面，传入的参数为<code>id: carInfo.CARID</code>，在另一个组件接收传入的参数<code>this.$router.query.id</code> ， 对于页面传值的方式还有很多。</p>
<pre><code class="language-js">this.$router.push({ path: '/backCar', query: {ID: carInfo.CARID} });
</code></pre>
<blockquote>
<p><code>还有一个需要注意的是：&lt;template&gt;标签只能向外暴露一个根标签，如果有多个，需要再到外层加一个div</code>；<br>
单页应用：通过js进行控制页面的显示。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190505172511257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h5 id="43-项目中一些技巧">4.3. 项目中一些技巧</h5>
<h6 id="431-import-引入-css">4.3.1. import 引入 css</h6>
<p>通过import可以直接引用css，如下面代码，可以直接写在<code>main.js</code>中：</p>
<pre><code class="language-javascript">	import './assets/style/reset.css'
</code></pre>
<h6 id="432-移动端-click-事件延迟执行">4.3.2. 移动端 Click 事件延迟执行</h6>
<p>防止移动端中出现点击<code>click</code>事件，延迟300毫秒执行的插件，在工程中输入下面命令进行安装：</p>
<pre><code class="language-javascript">	cnpm install fastclick --save
</code></pre>
<p>然后在<code>main.js</code>中进行设置：</p>
<pre><code class="language-javascript">	// 使用attach方法，绑定到body中。
	fastClick.attach(document.body)
</code></pre>
<h6 id="433-vue-cl项目中配置路径别名">4.3.3. vue-cl项目中配置路径别名</h6>
<p>在<code>vue-cli</code>项目中配置路径引用的标记，我们经常在项目中看到@符号，代表就是<code>src</code>路径，<code>~@</code>代表的是<code>src</code>路径下的两层路径，有时候我们的层级特别多，不能使用@符号，我们可以进行配置我们的简写路径。打开配置文件，修改如下：<br>
<code>styles</code>就是代表我们的<code>src/assets/style</code>这个路径。</p>
<pre><code class="language-js">	  resolve: {
	    extensions: ['.js', '.vue', '.json'],
	    alias: {
	      'vue$': 'vue/dist/vue.esm.js',
	      '@': resolve('src'),
	      'styles': resolve('src/assets/style'),
	    }
	  },
</code></pre>
<p>所以我们在引用该目录下的文件的直接就直接这样写：</p>
<pre><code class="language-js">	import 'styles/border.css'
	import 'styles/iconfont.css'
</code></pre>
<h6 id="434-vue-cl项目中使用-stylus">4.3.4. vue-cl项目中使用 stylus</h6>
<p>引入<code>stylus</code>,他类似<code>sass</code>或者<code>less</code>这种，可以直接在css中进行定义变量；帮助我们工程化代码；输入下面的命令进行安装：</p>
<pre><code class="language-js">	npm install stylus --save
	npm install stylus-loader --save
</code></pre>
<pre><code>然后我们可以在我们的项目中使用，如下面的`&lt;style&gt;`标签内，需要添加一个`lang=&quot;stylus&quot;`属性，这样就直接可以使用`stylus`进行写css代码，
</code></pre>
<pre><code class="language-css">	&lt;style lang=&quot;stylus&quot; scoped&gt;
	@import '~styles/varibles.styl'
	  .header
	    display: flex
	    line-height: .86rem
	    background: $bgColor
	    color: #fff
	    .header-left
	      width: .64rem
	      float: left
	      .back-icon
	        text-align: center
	        font-size: .4rem
	&lt;/style&gt;
</code></pre>
<p>这里还有需要注意的是，我们可以使用<code>stylus</code>，新建一个<code>varibles.styl</code>文件，来进行定义变量，比如我们主题的颜色，在很多css文件中都要使用，如果后期需要更换主题颜色，就很麻烦；这时候，我们可以通过新建一个<code>styl</code>后缀的文件，在里面进行定义我们的变量，这样后期维护就比较方便；<code>varibles.styl</code>文件内如下：</p>
<pre><code class="language-css">	$bgColor = #00bcd4
	$darkTextColor = #333
	$headerHeight = .86rem
	```
	然后我们引入这个文件，直接可以使用在里面定义的变量，代码如下：
	```css
	@import '~styles/varibles.styl'
	  .header
	    display: flex
	    line-height: .86rem
	    background: $bgColor
</code></pre>
<h6 id="435-移动端像素问题">4.3.5. 移动端像素问题</h6>
<p>首先需要明白<code>rem</code>与<code>px</code>像素单位之间的转化；<code>1rem = html font-size = 50px</code>；经常为了方便处理转换<code>rem</code>；我们会将<code>html</code>的<code>font-size</code>设置为<code>50px</code>，这样我们直接在页面中写<code>rem</code>的时候就方便计算了，直接是像素(<code>px</code>)/100这样计算就可以了。比如我们要设置<code>width=86px</code>，直接写成<code>width=.86rem</code>就可以了。</p>
<blockquote>
<p>需要注意的一个问题是，如果修改了<code>webpack</code>里面的配置项，需要重新启动服务才会有效。</p>
</blockquote>
<h4 id="5-项目开发中的一些知识">5. 项目开发中的一些知识</h4>
<h5 id="51-开发流程">5.1. 开发流程</h5>
<p>开发项目中的流程：大多数公司在进行开发一个项目的时候，都会首先建立一个主分支(<code>master</code>),然后将其他功能的编写，都放在其他分支上，最后将其他分支合并到主分支这样的开发流程。<br>
在码云上新建分支，然后在项目文件夹下输入命名：<br>
<code>git push</code> 他会提示提交到哪一个分支上，然后输入命令：<code>git checkout index-swiprer</code> 其中<code>index-swiprer</code>是我们新建的一个分支。<br>
将分支内容提交到主分支，还是通过<code>git add . ; git commit -m '&quot; ; git push</code>提交之后，然后输入命令<code>git checkout master</code>切换到主分支，然后进行合并，输入命令:<code>git merge origin/index-swiper</code>其中<code>index-swiprer</code>是我们要合并的分支；最后再<code>git push</code></p>
<h5 id="52-vue-第三方轮播图插件-vue-awesome-swiper">5.2. vue 第三方轮播图插件 vue-awesome-swiper</h5>
<p><code>vue</code>第三方轮播图插件<code>vue-awesome-swiper</code>，安装如下：<br>
输入命令<code>npm install vue-awesome-swiper@2.6.7 --save</code>然后根据官网的操作步骤，就可以使用了。官网地址：https://github.com/surmon-china/vue-awesome-swiper</p>
<h5 id="53-浏览器的小技巧模拟网络">5.3. 浏览器的小技巧模拟网络</h5>
<p>浏览器的小技巧：可以点击调试面试的<code>network</code>右侧有一个<code>offline</code>右侧的向下的箭头，可以模拟不同的网速，比如可以选择<code>slow 3G</code>模拟<code>3G</code>网络。</p>
<h5 id="54-css-代码技巧">5.4.  css 代码技巧</h5>
<h6 id="541-宽高保持一定的百分比">5.4.1. 宽高保持一定的百分比</h6>
<p>高度根据宽度撑开百分比，设置宽高始终保持在<code>31.25%</code>如下面的代码：</p>
<pre><code class="language-css">	  overflow: hidden
	  width: 100%
	  height: 0
	  /*高度会根据宽度自动撑开31.25% */
	  padding-bottom: 31.25%
</code></pre>
<p>或者直接写一个<code>height：31.25vm</code>，把<code>overflow</code>以及<code>padding-bottom</code>删除 ,也是可以的。</p>
<h6 id="542-修改第三方插件样式">5.4.2. 修改第三方插件样式</h6>
<p>查找<code>wrapper</code>下面的<code>swiper-pagination-bullet-active</code>类都加一个背景色。应用场景是，有时候引用了第三方的插件，需要改插件的颜色，直接通过加<code>! important</code>是不行的，可以通过下面的方法进行修改。</p>
<pre><code class="language-css">.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active
  background: #fff
</code></pre>
<p>另一个技巧：当页面显示的时候有可能显示的字体会很多，我们可以设置多余的显示为<code>...</code>，可以通过css类控制：</p>
<pre><code class="language-css">  overflow: hidden
  white-space: nowrap
  text-overflow: ellipsis
</code></pre>
<p>我们可以借助<code>stylus</code>进行封装css函数，如下面代码：</p>
<pre><code class="language-css">	ellipsis()
	  overflow: hidden
	  white-space: nowrap
	  text-overflow: ellipsis
</code></pre>
<p>然后在css中进行引入：<code>mixins.styl</code>文件就是我们写的代码，直接加一个<code>ellipsis()</code>就可以了。</p>
<pre><code class="language-css">	@import '~styles/mixins.styl'
	  .icon-desc
	    position: absolute
	    left: 0
	    right: 0
	    bottom: 0
	    height: .44rem
	    line-height: .44rem
	    text-align: center
	    color: $darkTextColor
	    ellipsis()
</code></pre>
<h6 id="543-div-元素垂直居中">5.4.3. div 元素垂直居中</h6>
<p><code>CSS</code>技巧：让给<code>div</code>中的元素垂直居中：</p>
<pre><code class="language-css">	  display: flex
	  flex-direction: column
	  justify-content: center
</code></pre>
<p>然后里面的可以设置<code>css</code>进行水平居中：</p>
<pre><code class="language-css">	    line-height: .44rem
	    text-align: center
</code></pre>
<h6 id="544-移动端获取元素离顶部元素真实高度">5.4.4. 移动端获取元素离顶部元素真实高度</h6>
<p>对于页面中获取离上面元素高度：</p>
<pre><code class="language-javascript">	        // 元素离顶部元素的高度
	        const startY = this.$refs['A'][0].offsetTop
	        // 获取到手离开屏幕的高度，他是获取到设备的最顶部到手指离开时的高度，这里高度需要减去顶部的header
	        //touch事件会传入一个手势参数，第一个存储着变量，跟点击事件一样，存储事件属性。
	        const touchY = e.touches[0].clientY - 79
</code></pre>
<h5 id="55-vue-cli-项目中的静态资源访问以及代码提交配置">5.5.  vue-cli 项目中的静态资源访问以及代码提交配置</h5>
<p><code>vue-cli</code>项目中，我们一般是将就静态文件放在<code>static</code>文件夹中，因为整个项目，只能那个文件夹可以被外部访问到。访问其他文件夹中的内容会自动跳转到主页面。我们可以修改项目中的<code>.gitignore</code>文件，进行配置在git提交代码的时候，提交哪些文件。如下面代码。设置将<code>static</code>下面的<code>mock</code>文件夹内的东西不进行提交:</p>
<pre><code class="language-javascript">	.DS_Store
	node_modules/
	/dist/
	npm-debug.log*
	yarn-debug.log*
	yarn-error.log*
	static/mock
	
	# Editor directories and files
	.idea
	.vscode
	*.suo
	*.ntvs*
	*.njsproj
	*.sln
	
</code></pre>
<h5 id="56-项目接口的转接">5.6. 项目接口的转接</h5>
<p>我们在写项目代码的时候，前端写的模拟数据，通过自己写的模拟接口，有可能是通过模拟的<code>json</code>数据，但是当项目 上线的时候需要进行替换真的<code>API</code>接口，如果在上线前进行替换，是有风险的，我们可以通过<code>webpack</code>提供的配置，在<code>config</code>文件夹下通过配置，将接口进行跳转，如下面的配置：</p>
<pre><code class="language-javascript">	    proxyTable: {
	      '/api': {
	        target: 'http://localhost:8080',
	        pathRewrite: {
	          '^/api': 'static/mock'
	        }
	      }
	    },
</code></pre>
<p>代码的意思是，将有<code>/api</code>请求的路径替换成<code>http://localhost:8080/static/mock</code>这样</p>
<h5 id="57-math-对象的一些方法">5.7. Math 对象的一些方法</h5>
<p><code>Math.round()，Math.ceil()，Math.floor()，Math.trunc</code>的区别：<code>Math.floor()</code>首先是向下取整，<code>Math.ceil()</code>是向上取整，<code>Math.round()</code>就类似我们的四舍五入,<code>Math.trunc()</code>方法会将数字的小数部分去掉，只保留整数部分。</p>
<h5 id="58-css-的-rem-以及-vm">5.8. CSS 的 rem 以及 vm</h5>
<p><code>rem</code> 是 <code>CSS3</code>新增的一个相对单位<code>（root em）</code>，即相对 <code>HTML</code> 根元素的字体大小的值。<br>
<code>em</code> 也是一个相对单位，却是相对于当前对象内文本的字体大小。<br>
一般建议在 <code>line-height</code>使用<code>em</code>。因为在需要调整字体大小的时候，只需修改<code>font-size</code> 的值，而<code>line-height</code>已经设置成了相对行高了。<br>
首行缩进两个字符：<code>text-indent: 2em</code><br>
视口单位 <code>vw | vh</code>:</p>
<blockquote>
<p>vw: 1vw = 视口宽度的 1%<br>
vh: 1vh = 视口高度的 1%</p>
</blockquote>
<h5 id="59-better-scroll-插件">5.9. Better-scroll 插件</h5>
<p><code>Better-scroll</code>插件的用法：<br>
首先进行安装，输入命令：<code>cnpm install better-scroll --save</code><br>
然后在页面就可以使用，如下面的代码：它主要的功能是做一个滚动，还有一个弹性的动画。</p>
<pre><code class="language-javascript">	import Bscroll from 'better-scroll'
	export default {
	  name: 'CityList',
	  mounted () {
	    //   传入dom元素
	    this.scroll = new Bscroll(this.$refs.wrapper)
	  }
	}
</code></pre>
<p>可以使用该插件自带的方法，进行滚动到对应的<code>DOM</code>元素，<code>element</code>是对应要滚动到的元素<code>DOM</code>节点，代码如下</p>
<pre><code class="language-javascript">	this.scroll.scrollToElement(element)
</code></pre>
<p>在<code>vue</code>中，我们获取组件，通常是在组件添加一个<code>ref</code>属性，然后通过<code>this.$refs.wrapper</code>获取到对应的组件，其中<code>wrapper</code>是我们定义组件的<code>ref</code>属性名字。</p>
<h5 id="510-防抖节流的例子">5.10. 防抖节流的例子</h5>
<p>一个防抖节流的例子：这个是做了一个类似通讯录滑动右侧字母列表进行显示对应首字母的人员，我们会通过<code>touch</code>事件来完成。思路是这样的：首先获取到<code>A</code>到顶部的距离，然后获取到手指滑动结束后的位置，用手指滑动后的位置减去<code>A</code>的位置，就是之间的距离差，然后根据距离差除以每一个字母的高度，就可以获取到到第几个位置，然后显示对应的数据。<br>
<img src="https://img-blog.csdnimg.cn/20190507212023344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
但是当我们手指拖动的时候，会频繁的触发触摸事件，所以我们在这里就可以做一个节流的操作，定义一个计时器，每次移动完之后，首先清除上次的定时器，然后重新定义计时器，每隔16毫秒执行一次事件。这样避免了频繁调用事件，下面是实现的代码：</p>
<pre><code class="language-javascript">	    handleTouchMove (e) {
	      if (this.touchStatus) {
	        if (this.timer) {
	          clearTimeout(this.timer)
	        }
	        // 延迟16毫秒执行
	        this.timer = setTimeout(() =&gt; {
	          // 获取到手离开屏幕的高度，他是获取到设备的最顶部到手指离开时的高度，这里高度需要减去顶部的header
	          const touchY = e.touches[0].clientY - 79
	          const index = Math.floor((touchY - this.startY) / 20)
	          if (index &gt;= 0 &amp;&amp; index &lt; this.letter.length) {
	            this.$emit('change', this.letter[index - 1])
	          }
	        }, 16)
	      }
	    },
</code></pre>
<h5 id="511-touch-事件与-click-事件的冲突">5.11.  touch 事件与 click 事件的冲突</h5>
<p>有时候我们做的拖动页面，比如通讯录的右侧拖动字母表，显示对应的人，但是发现拖动的时候整个页面也会动，这个时候就需要阻止<code>touchstart</code>事件的默认行为，需要在给组件绑定该事件的时候加一个事件修饰符，如下代码：</p>
<pre><code class="language-javascript">          @click=&quot;handleLetterClick&quot;
          @touchstart.prevent=&quot;handleTouchStart&quot;
          @touchmove=&quot;handleTouchMove&quot;
          @touchend=&quot;handleTouchEnd&quot;
</code></pre>
<h5 id="512-解决手机不支持-es6-新特性">5.12.  解决手机不支持 es6 新特性</h5>
<p>有些手机会不支持<code>promise</code>对象，进行发送<code>ajax</code>请求，这时候我们需要使用一个插件来解决；在项目中安装插件，输入下面的命令：<br>
这个插件，会检测浏览器是否支持<code>es6</code>的新特性，如果不支持，会进行修改。</p>
<pre><code class="language-javascript">	  npm install babel-polyfill --save
</code></pre>
<p>然后在<code>main.js</code>文件中直接引入该插件就可以了<code>import 'babel-polyfill'</code></p>
<h4 id="6-vuex-知识">6. vuex 知识</h4>
<h5 id="61-vuex-的使用">6.1.  vuex 的使用</h5>
<p>他是为了在多个组件共享数据的时候，方便我们管理共享状态；首先如果需要使用该插件，还是等进行安装。可以看下面的<code>vuex</code>实现步骤：<br>
<img src="https://img-blog.csdnimg.cn/2019050812593849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
每一个 <code>Vuex</code> 应用的核心就是 <code>store</code>（仓库）。<code>“store”</code>基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>);所以在使用的使用进行实例化<code>Store</code>对象，如下面的代码：</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	
	Vue.use(Vuex)
	
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  //  组件可以直接调用commit进行修改数据，可以不进行事件的派发dispatch
	  //   actions: {
	  //     changeCity (ctx, city) {
	  //       //  通过触发commit事件，来触发mutations来修改数据
	  //       ctx.commit('changeCity', city)
	  //     }
	  //   },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>从上面的示意图可以看到，如果需要改变状态里面的数据，首先得执行<code>Dispatch</code>进行分发一个事件，去执行一个<code>Actions</code>，然后通过<code>commit</code>去触发<code>Motations</code>里面的方法，去改变状态值；下面代码是<code>Dispatch</code>进行分发一个事件：</p>
<pre><code class="language-javascript">	      // 触发changeCity这个Action
       this.$store.dispatch('changeCity', city)
</code></pre>
<p>在<code>Store</code>对象的<code>Actions</code>里面我们这样写</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	Vue.use(Vuex)
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  //  组件可以直接调用commit进行修改数据，可以不进行事件的派发dispatch
	   actions: {
	       changeCity (ctx, city) {
	         //  通过触发commit事件，来触发mutations来修改数据
	       ctx.commit('changeCity', city)
	       }
	     },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>组件可以直接通过commit调用执行mutation里面的方法就行修改数据，在页面直接这样写</p>
<pre><code class="language-javascript">	  // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
      this.$store.commit('changeCity', city)
</code></pre>
<p>然后在<code>Store</code>对象的<code>Mutations</code>直接写对应的处理函数<code>changeCity</code>,代码：</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	
	Vue.use(Vuex)
	
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>在页面中，我们直接这样访问<code>store</code>对象里面的数值：</p>
<pre><code class="language-html">	  &lt;div class=&quot;header-right&quot;&gt;
          {{this.$store.state.city}}
          &lt;span class=&quot;iconfont arrow-icon&quot;&gt;&amp;#xe64a;&lt;/span&gt;
      &lt;/div&gt;
</code></pre>
<h5 id="62-页面之间跳转">6.2. 页面之间跳转</h5>
<p>对于页面跳转的，不仅可以使用<code>&lt;router-link to=&quot;/&quot;&gt;&lt;/router-link&gt;</code>这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以，代码如下：</p>
<pre><code class="language-javascript">	  methods: {
	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      this.$store.commit('changeCity', city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    }
	  },
</code></pre>
<h5 id="63-访问-vuex-数据技巧">6.3. 访问 vuex 数据技巧</h5>
<h6 id="631-组件中访问state数据">6.3.1. 组件中访问state数据</h6>
<p>由于 <code>Vuex</code>状态存储是响应式的，从<code>store</code>实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p>
<pre><code class="language-js">// 创建一个 Counter 组件
const Counter = {
  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
</code></pre>
<p>调用<code>Vue.use(Vuex)</code>状态从根组件“注入”到每一个子组件中：</p>
<pre><code class="language-js">const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    &lt;div class=&quot;app&quot;&gt;
      &lt;counter&gt;&lt;/counter&gt;
    &lt;/div&gt;
  `
})
</code></pre>
<p>然后在组件中可以使用：</p>
<pre><code class="language-js">const Counter = {
  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
</code></pre>
<h6 id="632-mapstate-辅助函数">6.3.2. mapState 辅助函数</h6>
<p>访问<code>vuex</code>数据技巧：前面写了可以通过<code>this.$store.state.city</code>这样来获取到我们在<code>Store</code>对象中定义的<code>state</code>里面的数据，我们也可以这样写：需要注意的是，遍历命名只能使<code>mapState</code>这样，下面的代码就是将<code>store</code>里面的<code>city</code>映射到计算属性里面的<code>city</code></p>
<pre><code class="language-javascript">	import { mapState } from 'vuex'
	  computed: {
	    // 展开运算符 把 store里面的city映射到计算属性里面的city
	    ...mapState(['city'])
	  }
</code></pre>
<p>其实<code>mapState</code>里面也可以包含一个对象，这样写，如下面的代码：代码意思是将<code>vuex</code>的<code>city</code>映射到计算属性的<code>currentCity</code></p>
<pre><code class="language-javascript">	import { mapState } from 'vuex'
		  computed: {
	    // 将vuex的city映射到计算属性的currentCity
	    ...mapState({
	      currentCity: 'city'
	    })
	  },
</code></pre>
<p>同样对于通过<code>commit</code>调用<code>Mutations</code>中的方法，也可以进行改写，之前是这样的：</p>
<pre><code class="language-javascript">	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      this.$store.commit('changeCity', city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    },
</code></pre>
<p>可以借助 <code>vuex</code>的简单方法，进行改写如下：需要注意的是<code>changeCity</code>这个方法要对应你在<code>store</code>对象的<code>Mutations</code>中定义的一致。还有需要注意的是，需要进行引入<code>import { mapState, mapMutations } from 'vuex'</code></p>
<pre><code class="language-javascript">	import { mapState, mapMutations } from 'vuex'
	  methods: {
	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      // this.$store.commit('changeCity', city)
	      // 可以用下面的方法这样写
	      this.changeCity(city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    },
	    ...mapMutations(['changeCity'])
	  },
</code></pre>
<h6 id="633-使用常量替代-mutation-事件类型">6.3.3. 使用常量替代 Mutation 事件类型</h6>
<p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code>实现中是很常见的模式。这样可以使<code>linter</code>之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个<code>app</code> 包含的<code>mutation</code>一目了然：</p>
<pre><code class="language-js">// mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION'
</code></pre>
<pre><code class="language-js">// store.js
import Vuex from 'vuex'
import { SOME_MUTATION } from './mutation-types'

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})
</code></pre>
<h5 id="64-vuex-中的-getters-属性">6.4.  vuex 中的 getters 属性</h5>
<p><code>vuex</code>中的<code>getters</code>属性：他类似<code>vue</code>的计算属性一样，可以根据<code>state</code>中的数据计算出其他数据，也就是从<code>state</code>中派生出一些状态;比如下面的代码。我需要获取到我的城市名，出现两次，代码如下:下面是<code>store</code>里面的代码</p>
<pre><code class="language-javascript">	  getters: {
	    doubleCity (state) {
	      return state.city + ' ' + state.city
	    }
	  }
</code></pre>
<p>然后在页面中，我们同样首先引入<code>mapGetters</code>,代码如下：</p>
<pre><code class="language-javascript">	import { mapGetters } from 'vuex'
		  computed: {
	    // 展开运算符 把 store里面的doubleCity映射到计算属性里面的doubleCity
	    ...mapGetters(['doubleCity'])
	  }
</code></pre>
<h5 id="65-使用-keep-alive-优化性能">6.5. 使用 keep-alive 优化性能</h5>
<p>使用<code>keep-alive</code>优化性能：我们的页面每次切换之后，都会进行重新的<code>ajax</code>请求，这样会耗费性能，我们可以在<code>&lt;router-view/&gt;</code>外层包裹一个<code>&lt;keep-alive&gt;</code>，他是只要路由渲染过的页面，会存储在内存中，再一次加载的时候，不会进行重新渲染 相当于添加了一个缓存</p>
<pre><code class="language-html">	    &lt;!-- keep-alive是只要路由渲染过的页面，会存储在内存中，再一次加载的时候，不会进行重新渲染 相当于添加了一个缓存--&gt;
	    &lt;keep-alive&gt;
	      &lt;router-view/&gt;
	    &lt;/keep-alive&gt;
</code></pre>
<p>但是有的时候，我们需要重新渲染页面，而不是读取缓存的内容，在使用<code>keep-alive</code>会触发一个<code>activated</code>方法，只要缓存的页面，再次显示，都会执行这个方法。我们可以在这里进行判断某些值是否改变，用不用重新发送请求。</p>
<pre><code class="language-javascript">	  activated () {
	    // 如果添加了keep-alive会有这个事件
	    if (this.lastCity !== this.city) {
	      this.lastCity = this.city
	      this.getHomeInfo()
	    }
	  },
</code></pre>
<h5 id="66-router-link-一些知识">6.6. router-link 一些知识</h5>
<h6 id="661-tag-属性">6.6.1. tag 属性</h6>
<p><code>router-link</code>一些知识：对于<code>router-link</code>，<code>vue</code>会渲染成一个<code>a</code>标签，当我们点击跳转到其他页面之后，会变颜色，当然我们可以通过<code>css</code>进行控制跳转后链接的颜色，我们还可以直接将其他元素改为 <code>router-link</code>然后添加一个<code>tag</code>属性，等于替换的标签，如下面的代码：下面的代码。本身是一个<code>li</code>标签，用<code>router-link</code>替换之后，添加一个<code>tag=&quot;li&quot;</code>属性</p>
<pre><code class="language-html">	            &lt;router-link tag=&quot;li&quot; class=&quot;item border-bottom&quot; v-for=&quot;item of list&quot; :key=&quot;item.id&quot; to=&quot;/detail&quot;&gt;
	                ![在这里插入图片描述]()
	                &lt;div class=&quot;item-info&quot;&gt;
	                    &lt;p class=&quot;item-title&quot;&gt;{{item.title}}&lt;/p&gt;
	                    &lt;p class=&quot;item-desc&quot;&gt;{{item.desc}}&lt;/p&gt;
	                    &lt;button class=&quot;item-button&quot;&gt;查看详情&lt;/button&gt;
	                &lt;/div&gt;
	            &lt;/router-link&gt;
</code></pre>
<h6 id="662-返回到前一页">6.6.2. 返回到前一页</h6>
<p><code>router-link</code>中：如果想要返回到前一个页面，属性<code>to='/'</code>这样就可以了,代码如下</p>
<pre><code class="language-html">	        &lt;router-link tag=&quot;div&quot; to=&quot;/&quot; class=&quot;header-abs&quot;&gt;
	            &lt;div class=&quot;iconfont header-abs-back&quot;&gt;&amp;#xe624;&lt;/div&gt;
	        &lt;/router-link&gt;
</code></pre>
<h5 id="67-keep-alive-一些知识点">6.7.   &lt;keep-alive&gt;  一些知识点</h5>
<p><code>&lt;keep-alive&gt;</code>一些知识点：对全局事件解析解绑；当我们在全局使用它进行包裹我们的组件的时候，前面也说了，会将我们的组件进行缓存，但是，他会因此产生两个生命周期函数，上面介绍了一个每次进入缓存页面的时候，执行的<code>activated</code>钩子函数，还有一个与之对应的钩子函数就是<code>deactivated</code>函数，就是离开这个页面的时候执行的方法。比如现在我们有一个页面，需要在<code>windoes</code>对象绑定<code>scroll</code>事件，但是如果在这个页面进行绑定了该事件之后，在其他的页面，还是会执行这个方法，所以我们需要对全局事件进行解绑。代码如下：<code>activated</code>钩子函数是当进入到使用<code>&lt;keep-alive&gt;</code>缓存的页面的时候执行的方法，我们在整理进行绑定了滚动事件,<code>deactivated</code>是当要离开缓存的这个页面的时候，执行的钩子函数，我们在这里进行移除绑定的滚动事件。</p>
<pre><code class="language-javascript">	  activated () {
	    window.addEventListener('scroll', this.handleScroll)
	  },
	  deactivated () {
	    window.removeEventListener('scroll', this.handleScroll)
	  }
</code></pre>
<h5 id="68-vuex-中的插件">6.8.  vuex 中的插件</h5>
<p><code>Vuex</code> 的 <code>store</code> 接受 <code>plugins</code> 选项，这个选项暴露出每次<code>mutation</code>的钩子。<code>Vuex</code>插件就是一个函数，它接收<code>store</code> 作为唯一参数：</p>
<pre><code class="language-js">const myPlugin = store =&gt; {
  // 当 store 初始化后调用
  store.subscribe((mutation, state) =&gt; {
    // 每次 mutation 之后调用
    // mutation 的格式为 { type, payload }
  })
}

</code></pre>
<p>使用：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  // ...
  plugins: [myPlugin]
})
</code></pre>
<h5 id="68-严格模式">6.8.  严格模式</h5>
<p>开启严格模式，仅需在创建<code>store</code> 的时候传入<code>strict: true</code>：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  // ...
  strict: true
})
</code></pre>
<h4 id="7-vue-router-知识点">7. vue-router 知识点</h4>
<h5 id="71-路由中参数的传递">7.1. 路由中参数的传递</h5>
<p>如果需要在路由带参数，直接在路由后面写上<code>:id</code>这样，<code>id</code>是参数名；如下面的代码：</p>
<pre><code class="language-javascript">    {
      // 动态路由 id为参数
      path: '/detail/:id',
      name: 'Detail',
      component: Detail
    }
</code></pre>
<p>如果需要在页面中需要获取路由中的参数，如下面的代码：使用<code>this.$route.params.id</code>来进行获取该页面中的参数</p>
<pre><code class="language-javascript">	    getDetailInfo () {
	      axios.get('/api/detail.json?id=', {
	        params: {
	          id: this.$route.params.id
	        }
	      }).then(this.handleGetDataSucc)
	    }
</code></pre>
<blockquote>
<p>一般我们发送<code>ajax</code>请求的时候，一般是在页面挂载之后执行，也就是<code>mounted</code>钩子函数里面去执行发送请求。</p>
</blockquote>
<p>还有一种传递参数的方式：</p>
<pre><code class="language-html">          &lt;router-link :to=&quot;{path:'/mailDetail',query:{id: item.id, type: 'rec'}}&quot; :key=&quot;item.id&quot;&gt;
            &lt;InfoList :info=&quot;item&quot;&gt;&lt;/InfoList&gt;
          &lt;/router-link&gt;
</code></pre>
<p>在组件中接收参数：</p>
<pre><code class="language-js">  data () {
    return {
      form: {},
      fjhref:'',
      activeName: '1',
      id: this.$route.query.id,
      type: this.$route.query.type,
    }
  },
</code></pre>
<h5 id="72-组件中-name-的用法总结">7.2 组件中 name 的用法总结</h5>
<p>组件中<code>name</code>的用法：组件的递归、去除缓存 、清除页面滚动。</p>
<h6 id="721-去除缓存">7.2.1. 去除缓存</h6>
<p>在指定页面去除缓存：在<code>keep-alive</code>组件中添加一个属性<code>exclude</code>,属性内容就是要去除缓存的页面的<code>name</code>值，如下面的代码：<br>
这里我的组件名叫<code>Detail</code>，前面我们是通过缓存的两个钩子函数<code>activated</code>和<code>deactivated</code>配合清除缓存的，下面是另一种方法。<br>
代码意思就是除了<code>Detail</code>这个页面不被缓存，其他页面都是被缓存的。</p>
<pre><code class="language-html">    &lt;keep-alive exclude=&quot;Detail&quot;&gt;
      &lt;router-view/&gt;
    &lt;/keep-alive&gt;
</code></pre>
<h6 id="722-清除页面滚动">7.2.2. 清除页面滚动</h6>
<p>清除页面滚动行为：我们在前面时候写到一个请求滚动的也是通过缓存的两个钩子函数<code>activated</code>和<code>deactivated</code>配合清除滚动的，其实在<code>vue-router</code>中，有一个配置项，是清除页面滚动行为的，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code>能做到，而且更好，它让你可以自定义路由切换时页面如何滚动，在<code>router</code>添加下面的代码，如下：<code>scrollBehavior</code>选项意思就是每次进行路由切换，始终回到最顶部。</p>
<pre><code class="language-javascript">	export default new Router({
		routes: [
			// 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
			{
				path: '/',
				// 路由名字
				name: 'home',
				component: Home
			}, {
				// 动态路由 id为参数
				path: '/detail/:id',
				name: 'Detail',
				component: Detail
			}
		],
		scrollBehavior (to, from, savedPosition) {
			return { x: 0, y: 0 }
		}
	})
</code></pre>
<h6 id="723-组件的递归">7.2.3. 组件的递归</h6>
<p>递归组件：有时候我们在页面中，会有类似折叠菜单的这种，样式是一样的，使用同一个组件，这就需要使用递归组件，如下面数据：</p>
<pre><code class="language-javascript">     categoryList&quot;: [{
        &quot;title&quot;: &quot;成人票&quot;,
        &quot;children&quot;: [{
          &quot;title&quot;: &quot;成人三馆联票&quot;,
          &quot;children&quot;: [{
            &quot;title&quot;: &quot;成人三馆联票 - 某一连锁店销售&quot;
          }]
        },{
          &quot;title&quot;: &quot;成人五馆联票&quot;
     }]
</code></pre>
<p>递归组件就是在组件中调用他本身，上面的数据，只要有<code>children</code>我们就进行调用它本身，代码如下：</p>
<pre><code class="language-html">        &lt;div class=&quot;item&quot; v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt;
            &lt;div class=&quot;item-title border-bottom&quot;&gt;
                &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;
                {{item.title}}
            &lt;/div&gt;
            &lt;div class=&quot;item-chilren&quot; v-if=&quot;item.children&quot;&gt;
                &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<blockquote>
<p>需要注意的是<code>detail-list</code>这个是改组件的<code>name</code>值，这就是组件<code>name</code>的其他用法</p>
</blockquote>
<h5 id="73-响应路由参数的变化">7.3. 响应路由参数的变化</h5>
<p>当使用路由参数时，例如从 <code>/user/foo</code>导航到<code>/user/bar</code>，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <code>watch</code>(监测变化) <code>$route</code>对象：</p>
<pre><code class="language-js">const User = {
  template: '...',
  watch: {
    '$route' (to, from) {
      // 对路由变化作出响应...-----可以再次请求数据
    }
  }
}
</code></pre>
<p>或者使用 2.2 中引入的<code>beforeRouteUpdate</code>导航守卫：</p>
<pre><code class="language-js">const User = {
  template: '...',
  beforeRouteUpdate (to, from, next) {
    // react to route changes...
    // don't forget to call next()
  }
}
</code></pre>
<h5 id="74-路由中传递参数">7.4. 路由中传递参数</h5>
<p>函数式编程导航：</p>
<pre><code class="language-js">// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
</code></pre>
<p>这里需要注意：如果提供了<code>path</code>，<code>params</code>会被忽略，上述例子中的 <code>query</code>并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的<code>name</code>或手写完整的带有参数的<code>path</code>：</p>
<pre><code class="language-js">const userId = '123'
router.push({ name: 'user', params: { userId }}) // -&gt; /user/123
router.push({ path: `/user/${userId}` }) // -&gt; /user/123
// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -&gt; /user
</code></pre>
<h5 id="75-命名路由">7.5. 命名路由</h5>
<p>我们在写路由对象的时候可以给路由对象加一个<code>name</code>属性，通过一个名称来表示一个路由会显得更方便一些：</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    }
  ]
})
</code></pre>
<p>要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：</p>
<pre><code class="language-js">&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;
</code></pre>
<p>或者使用编程式导航的方式：</p>
<pre><code class="language-js">router.push({ name: 'user', params: { userId: 123 }})
</code></pre>
<p>两种方式导航的地址：<code>/user/123</code></p>
<h5 id="76-命名视图">7.6. 命名视图</h5>
<p>如果我们的一个页面需要展示多个视图，就可以使用命名视图，如果 <code>router-view</code>没有设置名字，那么默认为 <code>default</code>。</p>
<pre><code class="language-html">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;
</code></pre>
<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code>配置 (带上 <code>s</code>)：</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})
</code></pre>
<h5 id="77-组建内的守卫">7.7. 组建内的守卫</h5>
<p>组建内的守卫有三种：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code></li>
<li><code>beforeRouteLeave</code></li>
</ul>
<pre><code class="language-js">const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
</code></pre>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code>来取消。</p>
<pre><code class="language-js">beforeRouteLeave (to, from , next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
</code></pre>
<h5 id="78完整的导航解析流程">7.8.完整的导航解析流程</h5>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h4 id="8-项目上线准备">8. 项目上线准备</h4>
<h5 id="81-api-接口的替换">8.1. API 接口的替换</h5>
<p>在项目上线的时候，需要前后台的联调，需要使用真实的<code>api</code>接口进行测试，这时候，我们需要在<code>config</code>文件夹下的<code>index</code>进行配置后台的接口，地址，配置如下面的代码:这里，我的后台的对应的地址是<code>http://localhost:80</code></p>
<pre><code class="language-javascript">    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
      '/api': {
        target: 'http://localhost:80',
        pathRewrite: {
          '^/api': 'static/mock'
        }
      }
</code></pre>
<p>如果后台跟前台写的<code>api</code>地址是一样的，可以不进行配置<code>pathRewrite</code>选项，如下：</p>
<pre><code class="language-javascript">    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
      '/api': {
        target: 'http://localhost:80'
      }
</code></pre>
<h5 id="82-移动端项目真机调试">8.2. 移动端项目真机调试</h5>
<p>在<code>vue</code>项目中，<code>webpack</code>服务器默认是不能通过<code>ip</code>地址进行访问我们的项目，比如运行<code>cmd</code>输入<code>ipconfig</code>查看我们的<code>ip</code>地址，输入到网页，是看不到我们的项目，输入端口80是可以看到的，我们可以通过修改配置，只需要修改项目中的<code>package.json</code>文件的配置项，代码如下：</p>
<pre><code class="language-javascript">		&quot;scripts&quot;: {
			&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot;,
			&quot;start&quot;: &quot;npm run dev&quot;,
			&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,
			&quot;build&quot;: &quot;node build/build.js&quot;
		},
</code></pre>
<h5 id="83-项目打包">8.3. 项目打包</h5>
<p><code>vue</code>项目打包上线：输入命令<code>npm run build</code>将我们的代码进行打包编译，然后我们的项目会多出来一个<code>dist</code>的文件夹。里面就是我们打包项目的代码。直接将<code>dist</code>文件夹放在后台的站点就可以运行了，但是有时候我们的站点需要放在后台服务器的一个文件夹里面，比如说，我们需要将前台的代码放在一个<code>project</code>的文件夹中，如果直接放进去，运行项目，你会发现报错，这个时候，我们需要修改<code>config</code>文件夹中的<code>inedx.js</code>里面的打包项：主要是<code>assetsPublicPath: '/project',</code>这个</p>
<pre><code class="language-javascript">	    build: {
				index: path.resolve(__dirname, '../dist/index.html'),

				// Paths
				assetsRoot: path.resolve(__dirname, '../dist'),
				assetsSubDirectory: 'static',
				assetsPublicPath: '/project',
			}
</code></pre>
<h4 id="9-vue-学习路线">9. vue 学习路线</h4>
<p><code>vue</code>学习思路：边缘知识点进行查看，查看生态系统<code>v-router</code>中的路由别名等等，查看<code>vuex</code>中的一些核心概念，然后查看服务器端渲染，然后学习<code>vue</code>的插件，查看官网的<code>vue</code>资源。最后研究<code>vue</code>源码，查看<code>commit</code>，了解每次提交的的添加的功能的思路。</p>
<h4 id="10-其他">10. 其他</h4>
<ol>
<li>使用<code>JSX</code>，需要注意的是：如果使用<code>JSX</code>，需要在<code>webpack</code>中进行配置<code>babel-plugin-transform-vue-jsx</code>，</li>
<li>看了一篇文章，有关个人技术突破的，首先要了解技术门槛，认清自己当下局势。然后进行习惯养成与指定目标计划，<br>
比如读源码，或者整理原理图，当完成目标可以给自己奖励，也可以不断测试自己的底线，调整目标。然后就是训练自己的<br>
思维，善于对问题进行提问：问题是什么，当前真相是什么，为什么会发生。最后，，就是不怕吃亏。。</li>
<li>Vue中的插件开发：使用一个公开的方法<code>install</code>；<code>v-router</code>（实现原理跟使用is用来设置显示组件一样）、<code>v-vuex</code>（非父子组件之间通讯的原理）等插件。</li>
<li>浏览器的基本工作原理从输入url到使用各种线程渲染页面。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack4.X 基础知识笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack4x-ji-chu-zhi-shi-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack4x-ji-chu-zhi-shi-bi-ji">
        </link>
        <updated>2019-12-06T01:50:32.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-webpack-基础知识">1. WebPack 基础知识</h4>
<p>首先需要明白<code>webpack</code>为什么会出现，作用是什么，总之他就是一个模块打包工具；<br>
<code>commonJS</code>的模块导出方式为:</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-webpack-基础知识">1. WebPack 基础知识</h4>
<p>首先需要明白<code>webpack</code>为什么会出现，作用是什么，总之他就是一个模块打包工具；<br>
<code>commonJS</code>的模块导出方式为:</p>
<!-- more -->
<pre><code class="language-javascript">function SiderBar() {
    var dom = document.getElementById('root');
    var siderbar = document.createElement('div');
    siderbar.innerHTML = 'siderbar';
    dom.append(siderbar);
}

module.exports = SiderBar
</code></pre>
<p><code>commonJS</code>的模块导入(引入)方式为:</p>
<pre><code class="language-javascript">var SiderBar = require('./siderbar.js')
</code></pre>
<p><code>webpack</code>是一个打包工具，，他能识别任何一个模块引入的语法，包括<code>ES Module(也就是 import export)、CommonJS 、CMD 、AMD</code>都可以识别。<code>webpack</code>都能够进行很好的翻译。</p>
<h4 id="2-webpack-安装-使用配置文件-浅析打包输出的内容-loader-使用-loader-打包静态资源图片篇-使用-loader-打包静态资源样式篇">2. Webpack 安装、使用配置文件、浅析打包输出的内容、Loader、使用 Loader 打包静态资源（图片篇）、使用 Loader 打包静态资源（样式篇）</h4>
<h5 id="21-安装有两种方式全局安装与局部安装">2.1 安装有两种方式：全局安装与局部安装</h5>
<ul>
<li>全局安装：<code>npm install webpack webpack-cli -g</code> 不推荐使用,卸载<code>npm uninstall webpack webpack-cli -g</code>;</li>
<li>局部安装：<code>npm install webpack webpack-cli --save-dev</code> 或者<code>npm install webpack webpack-cli -D</code>是等价的。局部安装的直接输入<code>webpack -v</code>是不能运行这个命令的，可以通过 <code>npx webpack -v</code>去运行命令。<code>npx</code>会从项目的<code>node_modul</code>去找<code>wenpack</code>包，所以可以通过<code>npx</code>去查找我们在项目中的<code>webpack</code>包;可以在不同的项目中使用不同版本的<code>webpack</code> ；<br>
输入<code>npm info webpack</code>可以查看包的信息，包括版本等信息。</li>
<li>安装指定版本的<code>webpack</code>:<code>npm install webapck@版本号 webpack-cli -D</code></li>
</ul>
<h5 id="22-使用配置文件">2.2 使用配置文件</h5>
<p><code>webpack</code>在进行打包的时候，首先会查找项目中是否存在配置文件<code>webpack.config.js</code>，如果没有，他会使用默认的配置文件进行打包。<br>
在项目的目录下新建<code>webpack.config.js</code>文件，里面输入内容：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,改成bundle就是说，打包后的文件放在bundle文件夹中
      path: path.resolve(__dirname,'bundle')
    }
}
</code></pre>
<p>代码的注释很详细，就不在重复；上面代码就是说将我们项目中的<code>/src/index.js</code>文件进行打包到<code>bundle</code>文件夹下的<code>bundle.js</code>中。<br>
一般情况，我们将我们的源代码放在<code>src</code>目录下。</p>
<blockquote>
<p>需要注意的是： <code>webpack</code>中默认的配置文件是<code>webpack.config.js</code>，我们可以输入命令<code>npx webpack --config webpackconfig.js</code>将默认的配置文件指向<code>webpackconfig.js</code>这个文件。</p>
</blockquote>
<p>我们每次进行打包的时候，都需要输入命令<code>npm webpack</code>,我们可以在<code>webpack.config.js</code>这个文件中进行配置我们允许的命令；如下面代码：</p>
<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;bundle&quot;: &quot;webpack&quot;
  },
</code></pre>
<p>上面的配置就是当我们输入<code>npm run build</code>的时候相当于输入 <code>npm webpack</code>,进行打包我们的文件。这里运行 <code>npm webpack</code>是不会进行全局检测是否安装了 <code>webpack</code>，而是从项目的<code>node_module</code>去查找。</p>
<blockquote>
<p>补充：查看官网的<code>guides</code>中的<code>Getting started</code>里面的内容</p>
</blockquote>
<h5 id="23-浅析打包输出的内容">2.3 浅析打包输出的内容</h5>
<p>我们输入命令<code>npm run bundle</code>或者<code>npx webpack</code>之后，控制台会输出下面的内容：</p>
<pre><code>Hash: 7d4f5a28d798a39e7e58
Version: webpack 4.31.0
Time: 293ms
Built at: 2019-05-16 08:56:10
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]

WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
</code></pre>
<p><code>Hash</code>：是对应打包成功后文件的<code>Hash</code>值是唯一值；<br>
<code>bundle.js</code>：我们打包出的文件；<br>
<code>Chunks</code>：我们打包后的文件，每一个文件都会有一个自己的<code>id</code>值，这里面存放该文件的<code>id</code>值跟与其他打包后的文件有关系的对应文件的<code>id</code>值；<br>
<code>Chunk Names</code>:存放<code>Chunks</code>中每一个<code>id</code>值对应的名字。这里的<code>main</code>，这里的入口文件，对应的名字就是<code>main</code>；我们前面说到配置打包的入口文件：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: './src/index.js',
</code></pre>
<p>其实是下面的简写形式：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: {
      main: './src/index.js',
    },
</code></pre>
<p><code>WARNING in configuration</code>:这里的警告说，我们在进行打包的时候，没有配置打包的模式与打包的环境；其实我们在没有配置模式的情况下默认是<code>production</code>，如下面的代码：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')
module.exports = {
    // 配置打包模式
    mode: 'production',
    // 入口文件
    entry: {
      main: './src/index.js',
    },
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
      path: path.resolve(__dirname,'dist')
    }
}
</code></pre>
<p>添加之后，再次进行打包就不会出现警告了：</p>
<pre><code>Hash: 81601a0beb210cf86adc
Version: webpack 4.31.0
Time: 632ms
Built at: 2019-05-16 15:20:51
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]
</code></pre>
<p>这个<code>production</code>模式打包后的文件，会对文件进行压缩，上面打包后的文件内容如下：打包为一行；</p>
<pre><code class="language-javascript">!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},t.t=function(e,n){if(1&amp;n&amp;&amp;(e=t(e)),8&amp;n)return e;if(4&amp;n&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;n&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return t.d(n,&quot;a&quot;,n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p=&quot;&quot;,t(t.s=0)}([function(e,n,t){var r=t(1),o=t(2),u=t(3);new r,new o,new u},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;header&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;SiderBar&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;content&quot;,e.append(n)}}]);
</code></pre>
<p>我们将打包模式配置成<code>mode: 'development'</code>;打包后的内容就不会进行压缩，内容如下：</p>
<pre><code class="language-javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
</code></pre>
<h5 id="24-loader解析">2.4 Loader解析</h5>
<p><code>webpack</code>本身只是识别<code>js</code>文件的打包，当我们需要进行打包比如图片等文件时，需要在配置文件里面进行配置；<code>webpack</code>在进行打包的时候，首先是直接打包<code>js</code>文件，然后其他的文件会通过配置文件里面的<code>module</code>里面进行查找对应文件的打包规则；如果我们需要对图片文件进行打包，配置如下：</p>
<pre><code class="language-javascript">    module: {
      rules: [{
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: 'file-loader'
        }
      }]
    },
</code></pre>
<p>然后记得进行安装对应的<code>loader</code>；输入命令：<code>npm install file-loader --save-dev</code>然后运行打包命令就可以了；<br>
<code>loader</code>就是一个打包方案，只要不是.<code>js</code>文件，就需要进行配置打包的规则。</p>
<h5 id="25-使用-loader-打包静态资源图片篇-url-loader的使用">2.5 使用 Loader 打包静态资源（图片篇）、url-loader的使用</h5>
<p>如果我们在打包静态资源的时候，比如图片，默认打包后的结果是会生成一个字符串为图片命名，我们现在希望我们打包之后他的文件名以及扩展名，也就是文件类型都是不会改变，可以进行如下配置：<code>[name].[ext]</code>分别代表的是之前文件的文件名以及之前文件的后缀，他其实就是一个<code>webpack</code>的一个占位符。可以在官网的<code>file-loader</code>里面可以看到很多占位符的用法。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                  // 占位符 Placeholders
                  name: '[name].[ext]'
                }
            }
        }]
    },
</code></pre>
<p>同时我们可以设置打包后输出的的文件夹的位置：下面是将图片文件打包在<code>images</code>文件夹中。可以查看官网的文档里面<code>file-loader</code>的相关配置。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/'
                }
            }
        }]
    },
</code></pre>
<h6 id="url-loader-的使用">url-loader 的使用:</h6>
<p><code>url-loader</code>可以进行上面的打包，但是唯一不同的是，<code>url-loader</code>是将图片直接打包成一个<code>base:64</code>的字符串，进行显示在<code>src</code>中。<br>
<img src="https://img-blog.csdnimg.cn/20190516200022406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这个会有一些问题，是减少了发送<code>http</code>请求，但是如果文件很大，加载的时间也是很长，页面会显示空白。如果图片小，可以使用这种方式进行打包。如果图片很大，需要将图片通过<code>file-loader</code>打包到一个文件夹，这样更适合项目。其实在<code>url-loader</code>中已经考虑到了，我们可以进行添加一个配置进行限制：<code>limit: 2048</code>意思就是如果图片超过2048个字节，也就是<code>2kb</code>就将图片打包到<code>imagees</code>文件夹中，如果小于，就直接生成一个<code>base:64</code>的字符串进行显示。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 2048
                }
            }
        }]
    },
</code></pre>
<p>可以查看官网<code>API</code>进行深入的研究这两个<code>loader</code>；</p>
<h5 id="26-使用-loader-打包静态资源样式篇">2.6 使用 Loader 打包静态资源（样式篇）</h5>
<p>首先需要进行配置打包<code>css</code>文件的打包配置，需要使用<code>style-loader、css-loader</code>两个<code>loader</code>进行打包。其中<code>css-loader</code>他是可以解析我们<code>css</code>文件之间的依赖关系，比如我们的<code>index.css</code>中引用了<code>avatar.css</code>文件，如下：<code>@import './avatar.css';</code>他就会进行解析，之间的依赖关系，最终将这些文件打包到一个文件中。<code>style-loader</code>的作用是，当得到<code>css-loader</code>打包后的内容之后，会将这些挂载到页面的<code>header部分</code>，也就是放在了<code>style</code>标签中。配置如下：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }]
    },
</code></pre>
<p>如果我们需要打包<code>.sass、scss</code>这些其他<code>css</code>文件，我们需要引入<code>sass-loader</code>进行打包:<code>npm install sass-loader node-sass webpack --save-dev</code>如下的配置：</p>
<pre><code class="language-javascript">    module: {
        rules: [ {
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader'
            ]
        }]
    },
</code></pre>
<p>其实<code>loader</code>的执行是有先后顺序的：从上到下、从右到左；比如上面的配置，首先是通过<code>sass-loader</code>进行处理，然后通过<code>css-loader</code>进行处理文件关系，最后通过<code>style-loader</code>进行挂载到页面。</p>
<h6 id="261-对于-css-打包进行添加厂商前缀使用postcss-loader自动添加厂商前缀">2.6.1 对于 css 打包进行添加厂商前缀，使用<code>postcss-loader</code>自动添加厂商前缀:</h6>
<p>首先进行安装<code>npm i -D postcss-loader</code>;然后新建<code>postcss.config.js</code>文件，然后进行安装一个<code>autoprefixer</code>插件，输入命令：<code>npm install autoprefixer -D</code>。<code>postcss.config.js</code>文件配置如下：</p>
<pre><code class="language-javascript">module.exports = {
    plugins: [
      require('autoprefixer')
    ]
}
</code></pre>
<p>最后需要记得在打包配置里面进行添加<code>postcss-loader</code>配置项：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>其实我们的厂商前缀是由<code>postcss-loader</code>里面我们添加的<code>autoprefixer</code>插件给我们添加的厂商前缀。</p>
<h6 id="262-css-loader-中一些常用的配置项">2.6.2 css-loader 中一些常用的配置项：</h6>
<p>我们在进行配置<code>loader</code>的时候，如果里面需要配置参数，那么将<code>loader</code>写成一个对象，而不是数组里面的字符串，我们给<code>css-loader</code>添加一个选项：<code>importLoaders: 2</code>，如下面代码：<code>importLoaders: 2</code>参数的意思是：如果我们在<code>js</code>文件里面通过<code>import</code>语句进行引入<code>scss</code>文件是可以进行打包的，按照我们前面说的，从下往上执行<code>loader</code>,但是如果我们的在<code>js</code>文件中引入的<code>scss</code>文件中还通过<code>import</code>引入了其他<code>scss</code>文件，那么这里的<code>scss</code>文件在进行打包的时候不会进行类似在<code>js</code>文件中<code>scss</code>打包的过程从下往上执行<code>loader</code>，所以我们需要添加配置项<code>importLoaders: 2</code>，意思就是我们在打包<code>scss</code>文件的时候（或者<code>css</code>）需要执行前面两个<code>loader</code>，这样就保证了不管<code>scss</code>文件（或者<code>css</code>）中通过<code>import</code>引入多少其他的<code>scss</code>文件（或者<code>css</code>），都能够正常的打包，都会依次从上到下依次执行<code>loader</code>进行打包。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<h6 id="263-css-文件模块化打包只在一个模块内有效">2.6.3 css 文件模块化打包：只在一个模块内有效</h6>
<p>我们在写<code>css、scss</code>的时候会直接将他们在代码中进行引入，如下：这会导致如果页面创建元素，所有的元素的样式都会受到影响，</p>
<pre><code class="language-javascript">import  './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<p>在<code>createAvatar.js</code>文件中也是创建一个<code>img</code>标签：</p>
<pre><code class="language-javascript">import avater from './avater.png'
function createAvatar () {
    var img = new Image();
    img.src = avater;
    img.classList.add('avater')
    var dom = document.getElementById('root');
    dom.append(img);
}
export default createAvatar
</code></pre>
<p>在<code>index.scss</code>中，代码如下：</p>
<pre><code class="language-css">
body {
    .avater {
        height: 150px;
        width: 150px;
        transform: translate(100px, 100px);
    }
}
</code></pre>
<p>这样写会导致页面中两个图片显示都一样，都使用了<code>index.scss</code>中的样式；解决这个问题，就是我们可以在打包<code>css</code>这些文件的时候，实现模块化打包，如下面代码：<br>
在打包的时候，进行配置打包为模块;<code>modules: true</code>意思就是开启模块化打包。</p>
<pre><code class="language-javascript">module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2,
                    modules: true
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>然后在代码中通过<code>style.avater</code>这种方法，进行添加样式，这样就不影响全部文件了。</p>
<pre><code class="language-javascript">import style from './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(style.avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<h6 id="264-打包字体文件">2.6.4  打包字体文件：</h6>
<p>我们项目里面也经常会用到图片库中的小图片，比如<code>iconfont</code>里面的小图片，我们查看<code>iconfont.css</code>发现，里面引入了<code>eot|ttf|svg|woff</code>这些文件，如下面代码：</p>
<pre><code class="language-css">@font-face {
    font-family: &quot;iconfont&quot;;
    src: url('./font/iconfont.eot?t=1558162704401'); /* IE9 */
    src: url('./font/iconfont.eot?t=1558162704401#iefix') format('embedded-opentype'), /* IE6-IE8 */
    url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAASIAAsAAAAACQgAAAQ7AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCfgqFVIRuATYCJAMMCwgABCAFhG0HWxvRBxHVoy2Q/SxwzuYE2hXq6ImKdq351ClK774P+U+55ftJYCczKxZYca2qhqqHlK24nUQMelK9FgLpdvvtgwTDKPAeOIriDMIYEisANjdD9/zrCMWSnOf9tMy0dKYX0l//czm9awvOD5TLXMuOegGGvYACGmPbAgq0QBL0luFVB7kbx4EAXIwsNBq16ABGoY8jAN1DB/cFS+goFcWEIdaCpQV60LG2WLoDYKX3ffpREAyQWBL61DaDGg5Anff0XpJ1r+50EPD7swBgVwEyIAugAB2FtjaQg1gWGZdtiqTqSgXBe8nrdXDEm+0fHkAkoAm6zBcT0+ISvCeLv2t8jAN/31cBVgAD/KeVEEN3tJC34tqkxgXGTXfu3rlOc+Hr8MTcgtOSZ+3EUtPhtPGde0E3oi52evhU0NLOz59jd2fHqMcOJzH9aVu+ZJ1uCLHUbjdt5HAiDzx61pbXhwd6tFHySNO01ZCj8/OxS00ix/7dJ0PLqOZyCt95MQyuS8liz5VIqjb2mDW2dlPIXA/rQrkT1MMuDA2uc6mtTW+mbvTjrn1LDzj2L9k7nXc2x/GEdvDtNJpV1zp2gypowHGWmss91q3j/kucZHGY9gDD0AZ06pO7BjY2dOwwyZt01y77UnvnPY7KoDOqqHeEt4hBq+jG0Q2HDWvo3qU1Wiwqad9EuDX31jEYFDiWezSPWuu6WdkBXdvGt4yfOiXOrmmLLgk3fnYYtWktF5e2b/3+HjE28ELhIt/x3G1z8/Kr68rbo2ub+FZxU6bGtUxo2zWhbvgrVVl9RW0Z2zqmcVRDu79wi7pB4of00ieV0apXehC7x4L0V6uIUZ1JeW/lSTsn1Ss7KmKZ/kpX76nOnVhdS//Izv3GW+tyT3G/NHRKGJQwMKEjSpfDB3r3Ghz6PXTSnDnclEwKxJNTvXY8GOzXzW/Qg3cPJnmPmsy2+BxQ37ELrJt6fsw7fT/z45fmG22bHfdtLL5pblGya8Ku8ZWrLf/OW/gez1jlt7tslshAHwCA91KekTNJ4nqek8v/ld8g8P38sHdA1T8mFADAS8u9QOzxXirAHAC7m3aCP4MPrFMUoa6XS+JZPC0pO4x+77XgihNe6K5gnvYKDVwIEEaLQOIjGmRMEqoQs8BCKAIrpjZwmRqvFkKMg4xKBZBhPgIS6AhI/F0BWaC7qEJ0g4XNN7AKDBm4ThSypZASuFU74yK4w/oDu1HSplGUX3xDU8LCcaFHfSGfNghd3aaTV0zIfcw436YX0aCZIozoNAyBIDM53KQ+RPLQNLroRfVGsVLqMy6CO1h/wG6UtNNcVObzNzQlLFyBKbO+kE/bOejUWgB6lSUQ5lx6n2/TE9HUKM0UwYgtGIwYgVw8yOEmtaNFJA8a0khDZfX4inh922CmT81okVHCriWZ/1FMit0iU0QrfosS7CXX8isp8K5UVQA=') format('woff2'),
    url('./font/iconfont.woff?t=1558162704401') format('woff'),
    url('./font/iconfont.ttf?t=1558162704401') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
    url('./font/iconfont.svg?t=1558162704401#iconfont') format('svg'); /* iOS 4.1- */
  }
</code></pre>
<p>我们如果直接使用<code>webpack</code>打包会提示报错，无法打包那些后缀的文件，我们可以通过<code>file-loader</code>进行打包这些字体文件，在<code>webpack.config.js</code>里面进行配置，如下：使得将字体文件打包到<code>dist</code>的相对路径里面，我们直接使用。</p>
<pre><code class="language-js">    module: {
        rules: [ {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }]
    },
</code></pre>
<blockquote>
<p>然后我们可以继续深入，查看官网的<code>document</code>中的<code>GUIDS</code>里面的<code>Asset Management</code>里面的内容，还有<code>loader</code>里面的<code>sass-loader、css-loader、postcss-loader</code>进行深入了解。</p>
</blockquote>
<h4 id="3-使用plugins让打包更便捷">3. 使用Plugins让打包更便捷</h4>
<h5 id="3-1-html-webpack-plugin-插件的使用将html进行打包并根据设置的html模板进行打包">3. 1    html-webpack-plugin 插件的使用——将html进行打包，并根据设置的html模板进行打包</h5>
<p>我们在打包的时候，每次打包之后，打包后的文件，并没有<code>index.html</code>就是我们在<code>src</code>文件夹里面写的网页，都需要我们进行复制到<code>dist</code>目录里面，很是麻烦，我们可以使用<code>webpack</code>插件，来帮助我们解决这个问题。<br>
首先需要安装这个插件:<code>cnpm install --save-dev html-webpack-plugin</code>,然后在<code>webpack.config.js</code>里面进行配置，代码如下：</p>
<pre><code class="language-javascript">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>这样，打包之后，会将我们的<code>html</code>文件也会进行打包，<code>html-webpack-plugin</code>这个插件在打包结束后，自动生成一个<code>html</code>文件，并把打包生成的<code>js</code>自动引入到这个<code>html</code>中。我们打开打包后的<code>html</code>文件，会发现，我们在里面的<code>html</code>结构没有显示，比如我们在里面写的<code>&lt;div&gt;&lt;/div&gt;</code>没有被打包显示，这个时候，我们需要对<code>html-webpack-plugin</code>这个插件进行配置一个<code>template</code>选项，让他根据模板进行打包我们的<code>html</code>文件，模板文件也就是我们需要打包的文件，也就是以模板文件进行打包。配置如下：</p>
<pre><code class="language-js">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    })],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p><code>Plugin</code>可以在<code>webpack</code>运行到某一时刻的时候，帮你做一些事情，很类似<code>vue</code>的声明周期函数；</p>
</blockquote>
<h5 id="32-clean-webpack-plugin-插件的使用清除打包地址的文件">3.2  clean-webpack-plugin 插件的使用——清除打包地址的文件</h5>
<p>我们在查看我们打包后的内容，我们如果将<code>output</code>配置里面的输出文件名修改为其他的，我们重新进行打包，会发现，打包是成功了，但是我们修改之前打包的<code>js</code>文件还是存在在<code>dist</code>文件夹中，我们需要做的是，每次打包之前，需要将<code>dist</code>中之前打包的文件先进行删除，然后再次进行打包<code>js</code>文件。这个时候，我们需要引入一个插件<code>clean-webpack-plugin</code>,<br>
首先输入命令进行安装：<code>npm install clean-webpack-plugin -D</code><br>
然后在<code>webpack.config.js</code>里面进行配置，如下：<code>new CleanWebpackPlugin()</code>意思是每次打包之前删除<code>dist</code>里面所有的内容。</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    }),new CleanWebpackPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p>这里需要注意的是<code>HtmlWebpakcPlugin</code>是在打包之后运行的插件，<code>CleanWebpackPlugin</code>是在打包之前运行的插件。还有一个需要注意的是<code>new CleanWebpackPlugin(['dist'])</code>这里的<code>dist</code>是不需要添加的，直接<code>new CleanWebpackPlugin()</code>就好了</p>
</blockquote>
<h4 id="4-entry-与-output-的基础配置">4. Entry 与 Output 的基础配置</h4>
<h5 id="41-多个文件的打包">4.1 多个文件的打包</h5>
<p>我们在打包文件的时候，经常会遇到打包多个文件，而不是一个<code>js</code>文件，这时候我们需要修改我们的配置；比如，下面代码，我们打包<code>main</code>跟<code>sub</code>的文件：</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        sub: './src/index.js'
    },
</code></pre>
<p>如果我们还是用之前的打包输出的配置；就会报错，提示多个文件打包到一个文件的错误:</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'main.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这个时候我们需要配置输出的文件，让他根据入口配置的文件，也就是那个对象的键，根据键来进行打包输出文件，配置如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样，打包后输出的文件分别为<code>main.js</code>跟<code>sub.js</code>；这样就完成了多个文件的打包。</p>
<h5 id="42-将打包后的js文件在html中通过配置cdn地址进行引入">4.2 将打包后的js文件在html中，通过配置cdn地址进行引入</h5>
<p>我们经常会遇到，我们在打包我们的<code>js</code>代码之后，会将<code>js</code>文件放在<code>cdn</code>服务器上，通过<code>cdn</code>服务器的地址来在页面进行引入脚本。比如，我们希望在<code>html</code>引入<code>js</code>的时候地址前面加上<code>cdn</code>域名：<code>http://cdn.com/main.js</code>这样。我们需要在<code>output</code>里面进行配置一个<code>publicPath</code>的选项：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        publicPath: 'http://cdn.com.cn',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>打包后<code>html</code>的引入如下：</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/main.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/sub.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>进一步学习：查看官网的<code>document</code>里的<code>configuration</code>中的<code>output</code>的配置参数。然后进行查看<code>guides</code>里面的<code>output management</code>里的内容。查看<code>plugins</code>里面的<code>htmlwebpackplugin</code>插件，查看该插件对应的官网。</p>
<h4 id="5-sourcemap-的配置">5. SourceMap 的配置</h4>
<p>我们在前面配置了我们的打包模式 为开发者模式：<code>mode: 'development',</code>在这个模式，默认<code>SourceMap</code>已经被配置进去了，我们可以关掉认<code>SourceMap</code>，配置如下：</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'none',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101150701.png" alt="在这里插入图片描述"><br>
如果我们关闭了<code>SourceMap</code>，我们如果在写代码的时候，不小心制造一个小<code>bug</code>，比如说我们把<code>console</code>写成了<code>conssole</code>这样，在打包时，是不会出现问题的，但是在页面的控制台会提示，该方法不存在，我们点击之后，提示打包后的文件的第153行报错，其实我们真正 想知道的不是打包后文件哪里出错，而是我们在源代码里哪个位置出现错误；而<code>SourceMap</code>他是一个映射关系，他知道<code>dist</code>目录下的<code>main.js</code>也就是我们打包生成的文件153行实际上对应是<code>src</code>目录下<code>index.js</code>文件也就是我们的源代码文件中的第58行。我们可以通过<code>SourceMap</code>获取到<code>index.js</code>中第一行代码出错了；所以我们需要进行配置<code>SourceMap</code>，来根据<code>SourceMap</code>的映射关系，找到我们源代码出错位置：我们查看打包后的文件，会多出一个<code>main.js.map</code>的文件，就是我们的源文件，存放着映射关系。</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'source-map',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101052959.png" alt="在这里插入图片描述"><br>
我们可以查看官网有关<code>SourceMap</code>的配置，也就是<code>devtool</code>的配置，其中如果将<code>devtool</code>配置成<code>inline-cheap-source-map</code>意思他会将打包后的<code>SourceMap</code>直接通过地址放在在打包的文件代码的底部：</p>
<pre><code class="language-js">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQ
</code></pre>
<p>这里，需要说明的是，前面我们进行配置成<code>source-map</code>，点击报错，他会提示代码报错位置的行与列，其实我们在查看问题的时候，并不需要精确到哪一列代码出现问题，只需要知道在哪一行；这时候我们可以将<code>devtool</code>配置成<code>cheap-source-map</code>，他只会提示代码在哪一行报错。<br>
这里的<code>cheap-source-map</code>他就会映射我们写的业务代码，比如打包的文件<code>index.js</code>而不会将我们在<code>loder</code>里面引入的第三方模块代码的映射，如果需要映射<code>loder</code>里面的的代码需要将配置修改为<code>cheap-module-inline-source-map</code><br>
还有一种打包方式就是<code>eval</code>，他是打包速度最快的，但是如果代码过多，也会影响打包速度；</p>
<blockquote>
<p>这里建议我们配置<code>sourceMap</code>的打包方式，如果是在<code>development</code>环境进行打包的时候，将<code>devtool</code>配置成<code>cheap-module-eval-source-map</code>，提示的错误比较全，打包速度也是比较快。如果我们代码已经上线，也就是在<code>production</code>模式下，我们可以将<code>devtool</code>配置成<code>cheap-module-source-map</code>，这样提示效果会好一些。</p>
</blockquote>
<h4 id="6-使用-webpackdevserver-提升开发效率">6. 使用 WebpackDevServer 提升开发效率</h4>
<p>我们现在每次进行打包的时候还要需要输入打包命令，打包之后在将<code>html</code>打开，查看打包结果；这样操作是比较麻烦的，我们需要的是可以监听到我们改动的文件，然后自动进行重新打包，我们有三种方法进行配置；</p>
<h5 id="61-第一种我们可以在packagejson进行配置监听文件变化">6.1 第一种：我们可以在package.json进行配置，监听文件变化</h5>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;
  },
</code></pre>
<p>他的意思是，会进行监听我们打包的文件，只要打包文件发生变化，就会重新打包。</p>
<h5 id="62-第二种监听打包文件变化并自动启动服务器加载html文件">6.2 第二种：监听打包文件变化，并自动启动服务器，加载html文件</h5>
<p>我们的第二种打包方式是，我们不仅需要监听打包文件的变化并重新打包，而且需要在打包完成之后，直接打开我们的<code>html</code>文件，类似在服务器中。前提是首先安装<code>webpack-dev-server</code>,输入命令：<code>npm install webpack-dev-server -D</code>。<br>
我们可以在<code>webpack.config.js</code>添加一个<code>devServer</code>配置：</p>
<pre><code class="language-js">module.exports = {
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist'
    }
}
</code></pre>
<p>然后在<code>package.json</code>里面添加一个运行命令，来运行我们的服务器：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;start&quot;: &quot;webpack-dev-server&quot;
  },
</code></pre>
<p>这时候会启动一个服务器，<code>webpack-dev-server</code>比我们之前配置的<code>webpack --watch</code>这种方式的好处是，他不仅会监听我们打包文件变化，并进行更新打包，而且也会重新刷新我们的网页。我们还可以在<code>webpack.config.js</code>中的<code>devServer</code>配置添加一个<code>open: true</code>选项，他会在打开服务器后，自动打开浏览器，并自动访问启动的服务器地址，打开网页，不用我们手动进行将服务器启动后的地址输入到浏览器进行打开：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true
    },
</code></pre>
<p>还有一个就是我们在使用<code>vue-cli</code>脚手架的时候，我们会在<code>devServer</code>里面配置一个<code>proxy</code>选项，用来模拟后台<code>API</code>请求地址或者转发我们的接口<code>API</code>地址，解决跨域代理；如下面的配置：他的意思是当我们访问<code>localhost:8080/api</code>地址的时候，他会自动将地址转发到<code>localhost:3000</code>端口。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      }
    },
</code></pre>
<h5 id="63-第三种自己手写一个服务器实现类似webpack-dev-server的效果">6.3 第三种：自己手写一个服务器，实现类似Webpack-dev-server的效果</h5>
<p>首先在<code>package.json</code>里面进行配置命令，使得运行命令之后，就运行我们的脚本文件：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;middleware&quot;: &quot;node server.js&quot;
  },
</code></pre>
<p>我们可以借助<code>node</code>的框架，去搭建服务器，这里使用<code>express</code>框架来实现，首先进行安装该框架：<code>npm install express webpack-dev-middleware -D</code>,我们这里同时安装了一个<code>webapck</code>的<code>webpack-dev-middleware</code>中间件，用来监听我们打包文件的变化，来自动进行打包。<br>
然后我们修改<code>webpack.config.js</code>里面的<code>output</code>配置，添加一个<code>publicPath: '/'</code>将文件打包成功后的引用地址前面都加一个根路径，确保打包生成文件的引用路径不会出现错误。</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: '/',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>然后我们的<code>server.js</code>代码如下：</p>
<pre><code class="language-js">const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const config = require('./webpack.config.js');
// 进行webpack编译--执行编译器，进行打包一次代码,
// 在node中直接使用webpack
const complier = webpack(config);

const app = express();
// 只要打包的文件内容发生变化，就会重新打包，通过编译器；将打包的文件放在跟webpack.config.js配置的一致
app.use(webpackDevMiddleware(complier, {
  publicPath: config.output.publicPath
}));

app.listen(3000, () =&gt; {
  console.log('server is run')
})
</code></pre>
<p>上面的我们是直接通过调用<code>webpack</code>配置在<code>node</code>里面使用<code>webpack</code>，我们也可以直接在命令行里去执行<code>webpack</code>，可以在官网的<code>API</code>里面的<code>Command Line Interface</code>查找到很多的命令：比如<code>webpack index.js -o main.js</code>将<code>index.js</code>打包成<code>main.js</code>输出。如果需要查找在<code>node</code>里面运行<code>webpack</code>，可以查看<code>node.js APi</code>里面去查找。</p>
<blockquote>
<p>深入学习：打开官网的<code>documentation</code>里面的<code>Guides</code>中的<code>development</code>里面的内容阅读，然后查看<code>configuration</code>里面有关<code>devtool、devServer</code>里面的内容。</p>
</blockquote>
<h4 id="7-hot-module-replacement-热模块更新">7. Hot Module Replacement 热模块更新</h4>
<p>我们使用<code>webpack-dev-server</code>帮助我们进行打包，会发现不会产生一个<code>dist</code>，因为他会生成一个打包文件，不过没有放在文件里面而是放在了计算机的内存中，可以有效提升打包的速度。<br>
我们在写代码的时候，经常会碰到，我们在修改了我们的<code>css</code>文件后，只是想每次在更新页面的时候，只是将样式文件重新加载，进行渲染，并不想让整个页面进行重新加载，破坏了我们页面的状态；我们想做的就是每次改完样式文件之后，只是重新加载样式文件，不破坏页面的状态；我们可以使用热模块更新来解决这个问题：我在<code>webpack.config.js</code>里面的<code>devServer</code>配置项中添加一个<code>hot: true</code>(让<code>webpack-dev-server</code>开启热模块更新的功能)选项跟<code>hotOnly：true</code>(即便是HTML的功能没有生效，也不让浏览器自动重新刷新，)</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
</code></pre>
<p>然后我们在<code>webpack.config.js</code>中引入<code>webpack</code>，在<code>plugin</code>里面进行添加一个<code>webpack</code>的插件<code>webpack.HotModuleReplacementPlugin()</code>;代码如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');
module.exports = {
    //....
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.HotModuleReplacementPlugin()
    ]
 }
</code></pre>
<p>这样，如果只改了<code>css</code>样式，页面不会从新加载，只会重新加载<code>css</code>文件。<br>
如果对于<code>js</code>文件，也想通过热模块更新，在<code>webpack.config.js</code>里面的配置跟上面一样，但是我们在代码里面需要进行判断，加一些代码逻辑，用来判断是否开启热模块更新，然后进行处理我们的逻辑：需要进行监控我们需要修改的文件</p>
<pre><code class="language-js">// 如果支持热模块加载
if(module.hot) {
    // 监控number文件，如果发生改变，就会执行里面的代码。
    // 第一个参数为依赖的文件的名字，
  module.hot.accept('./number', ()=&gt; {
    document.body.removeChild(document.getElementById('number'))
    number();
  })
}
</code></pre>
<blockquote>
<p>查看官方文档<code>guides</code>里面的<code>Hot Module Replacement</code>中的内容深入了解，然后查看<code>api</code>查看<code>Hot Module Replacement</code>配置选项，然后进行查看<code>concepts</code>里面的<code>Hot Module Replacement</code>内容，进行更深入的了解。</p>
</blockquote>
<h4 id="8-使用-babel-处理-es6-语法">8. 使用 Babel 处理 ES6 语法</h4>
<h5 id="81-使用-babel-按需打包js文件">8.1 使用 Babel 按需打包js文件</h5>
<p>首先进行安装，输入命令<code>npm install --save-dev babel-loader @babel/core</code>，然后在<code>webpack.config.js</code>增加一个规则，如下：代码意思就是除了<code>node_modules</code>里面的<code>js</code>内容不检测，其他的<code>js</code>文件文件都通过<code>babel-loader</code>进行加载转换。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot; 
    }
  ]
}
</code></pre>
<p>其实<code>babel-loader</code>只是<code>Babel</code>与<code>webpack</code>之间的一个通讯工具，<code>babel-loader</code>并不会将<code>es6</code>语法翻译为<code>es5</code>语法，而<code>babel/preset-env</code>才是真正转换的工具。首选进行安装，输入命令：<code>npm install @babel/preset-env --save-dev</code>，然后进行配置在<code>webpack.config.js</code>：</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
         presets: [&quot;@babel/preset-env&quot;]
      }
    }
  ]
}
</code></pre>
<p>也可以新建一个<code>.babelrc</code>的文件，然后里面增加配置，启用一些插件。</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}
</code></pre>
<p>这种转换只是一部分，低版本的有些函数还是不存在的，比如<code>promise</code>等函数，我们还需要借助<code>@babel/polyfill</code>，进行对低版本浏览器对<code>es6</code>中这些函数的支持，输入命令进行安装：<code>npm install --save @babel/polyfill</code>,然后全局引入，放在业务代码的最顶部，</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;
</code></pre>
<p>这样全局引入，会将所有<code>es6</code>的新增的函数打包到<code>js</code>文件中，这样会使打包的文件体积增大。我们需要的是在该<code>js</code>文件中使用的<code>es6</code>函数的实现，在<code>webpack.config.js</code>进行配置;</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
       presets: [[&quot;@babel/preset-env&quot;,{
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>就会实现按需加载，如果<code>js</code>中有用到<code>es6</code>新增函数，会将对应的实现代码打包到<code>js</code>中，而不是将全部<code>es6</code>新增的函数实现方式打包进去。</p>
<h5 id="82-打包转换中的其他参数设置打包支持浏览器的版本-编写类库文件babel转换配置">8.2 打包转换中的其他参数（设置打包支持浏览器的版本、编写类库文件babel转换配置）</h5>
<p>我们在打包的选项中，还可以进行配置其他选项，比如可以进行配置打包支持浏览器的版本，<code>babel</code>可以根据打包后支持的浏览器，去进行判断需要打包哪一些<code>es6</code>语法的实现函数，代码如下：这句代码是设置了打包后的为高于谷歌67版本的浏览器。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
      presets: [[&quot;@babel/preset-env&quot;,{
        targets: {
           chrome: &quot;67&quot;,
         },
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>我们如果写业务代码需要使用<code>babel</code>转换的时候，使用上面的配置就可以了，我们如果编写一个类库或者一个UI组件，需要进行不同的配置，配置步骤如下：<br>
安装<code>plugin-transform-runtime</code>,输入命令：<code>npm install --save-dev @babel/plugin-transform-runtime</code>，然后进行安装<code>babel/runtime</code>，输入命令：<code>npm install --save @babel/runtime</code>,然后进行安装<code>babel/runtime-corejs2</code> ,输入命令：<code>npm install --save @babel/runtime-corejs2</code>，然后在<code>webpack.config.js</code>进行配置;这样配置的好处是，我们在使用<code>babel</code>转换的时候，借助<code>polyfill</code>在全局进行注入，这样会污染全局，使用下面的配置，他会以闭包的形式，进行注入支持<code>es6</code>语法的函数。不存在全局污染。</p>
<pre><code class="language-js">    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;,
            options: {
            &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;,{
                &quot;corejs&quot;: 2,
                &quot;helpers&quot;: true,
                &quot;regenerator&quot;: true,
                &quot;useESModules&quot;: false
              }]]
            } 
        }]
    },
</code></pre>
<p>如果我们配置的<code>options</code>会很多的时候，可以在项目里面新建一个<code>.babelrc</code>的文件，将<code>options</code>里面的内容写在这里。然后去掉<code>webpack.config.js</code>中我们配置的<code>babel-loader</code>中<code>options</code>里面的内容。</p>
<h4 id="9-webpack-实现对react框架代码的打包">9. Webpack 实现对React框架代码的打包</h4>
<p>写<code>react</code>首选需要安装他，输入命令<code>npm install react react-dom --save</code>,然后在我们的<code>js</code>文件写<code>react</code>代码，如下：</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;

import React, {Component} from 'react'

import ReactDom from 'react-dom'

class App extends Component {
  return () {
    return &lt;div&gt;Hello World&lt;/div&gt;
  }
}
ReactDom.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
<p>安装<code>babel/preset-react</code>，进行转换；输入命令<code>npm install --save-dev @babel/preset-react</code>,然后在<code>.babelrc</code>文件中增加配置：</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ]
}
</code></pre>
<p>这里的插件执行是从下往上执行的，就是先进行打包<code>react</code>代码，然后进行<code>es6</code>代码的转换。</p>
<h4 id="10-webpack-打包的一些坑">10. Webpack 打包的一些坑</h4>
<p>是遇到很多坑，比如使用了<code>html-webpack-plugin</code>插件，然后我们允许<code>webpack-dev-server</code>命令的时候，我们配置了打包入口的<code>html</code>模板，但是启动服务之后，没有页面显示，查看打包信息出现<code>Entrypoint undefined = index.html</code>，<code>webpack.config.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
        // sub: './src/index.js'
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpakcPlugin({
            template: './src/index.html'
        }),
        
    ],
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>后来经过测试，将输出配置成如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样就可以了，不要配置，打包输出的文件名以及地址就可以，虽然是解决了允许服务器没有显示页面的问题，但是这个解决办法还不是最佳。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebPack 4.X 高级概念笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-4x-gao-ji-gai-nian-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-4x-gao-ji-gai-nian-bi-ji">
        </link>
        <updated>2019-12-06T01:39:56.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-tree-shaking-概念详解">1. Tree Shaking 概念详解</h4>
<h5 id="11-babelpolyfill与babelpreset-env之间的引用小冲突">1.1 babel/polyfill与babel/preset-env之间的引用小冲突</h5>
<p>在<code>webpack 4.x</code>的版本中，如果我们在业务代码里面引用了<code>impport @babel/polyfill</code>，而且我们还对<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，我们在打包的时候，会提示下面的信息：</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-tree-shaking-概念详解">1. Tree Shaking 概念详解</h4>
<h5 id="11-babelpolyfill与babelpreset-env之间的引用小冲突">1.1 babel/polyfill与babel/preset-env之间的引用小冲突</h5>
<p>在<code>webpack 4.x</code>的版本中，如果我们在业务代码里面引用了<code>impport @babel/polyfill</code>，而且我们还对<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，我们在打包的时候，会提示下面的信息：</p>
<!-- more -->
<p><img src="https://img-blog.csdnimg.cn/20190523200107374.png" alt="在这里插入图片描述"><br>
提示的意思是，如果我们在<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，可以不再业务代码里面，再次引入<code>impport @babel/polyfill</code>，<code>@babel/preset-env</code>插件会自动进行查看代码中<code>es6</code>语法进行添加对应的实现函数。</p>
<h5 id="12-tree-shaking-概念">1.2 Tree Shaking 概念</h5>
<p>我们在打包文件的时候，比如下面代码，有一个<code>math.js</code>文件，然后在<code>index.js</code>进行引入，代码如下：<br>
<code>math.js</code>文件</p>
<pre><code class="language-js">export const add = (a, b) =&gt;{
  console.log(a + b)
}
export const minus = (a, b) =&gt;{
  console.log(a - b)
}
</code></pre>
<p>·<code>index.js</code>里面内容</p>
<pre><code class="language-js">import { add } from './math.js';
add(1, 2);
</code></pre>
<p>这样，我们只是引入了<code>add</code>方法，但是我们查看打包的内容，会发现，他会将<code>math.js</code>文件所有的文件，都会打包到打包输出文件中，我们并不想让没有引入的方法等打包输出：</p>
<pre><code class="language-js">/*! exports provided: add, minus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;add\&quot;, function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;minus\&quot;, function() { return minus; });\nconst add = (a, b) =&gt; {\n  console.log(a + b);\n};\nconst minus = (a, b) =&gt; {\n  console.log(a - b);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoLmpzPzVhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PntcclxuICBjb25zb2xlLmxvZyhhICsgYilcclxufVxyXG5leHBvcnQgY29uc3QgbWludXMgPSAoYSwgYikgPT57XHJcbiAgY29uc29sZS5sb2coYSAtIGIpXHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/math.js\n&quot;);

</code></pre>
<p>这个时候，我们需要使用<code>Tree Shaking</code>功能来实现，不过需要注意的是<code>Tree Shaking</code>只支持<code>ES Module</code>，也就是只支持<code>import</code>这种方式的引入，不支持<code>require</code>这种<code>CommonJS</code>的引入方式，是因为<code>ES Module</code>这种底层是静态引入的方式，而<code>import</code>这种方式底层是动态的引入方式，<code>Tree Shaking</code>只支持静态引入的这种方法。我们在<code>webpack.config.js</code>中进行下面的配置：这里需要注意的是，我们下面的配置在开发模式下的配置<code>mode</code>为<code>development</code>；</p>
<pre><code class="language-js">   ....
module.exports = {
    // 配置打包模式
    mode: 'development',
   ....
    optimization: {
      usedExports: true
    },
   ....
}
</code></pre>
<p><code>usedExprots: true</code>意思就是我们去查看哪些导出的模块被使用，然后再进行打包；然后我们在<code>package.json</code>中进行下面的配置：添加<code>&quot;sideEffects&quot;: false,</code>意思就是，对所有的模块都进行<code>Tree Shaking</code>也就是将没有引入的方法等不进行打包到打包输出文件中。</p>
<pre><code class="language-js">{
  &quot;name&quot;: &quot;webpack&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;sideEffects&quot;: false,
  &quot;description&quot;: &quot;&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;bundle&quot;: &quot;webpack&quot;,
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;start&quot;: &quot;webpack-dev-server&quot;,
    &quot;server&quot;: &quot;node server.js&quot;
  },
</code></pre>
<blockquote>
<p>这里的<code>&quot;sideEffects</code>有很大的用途，比如我们在使用<code>@babel/polyfill</code>的时候，他的内部并没有使用<code>export</code>导出任何模块，他只是通过类似<code>windows.Promise</code>这样给全局T添加一些函数，但是我们使用<code>Tree Shaking</code>这种去打包的时候，他会发现这个模块我们并没有通过<code>import</code>引入任何模块，他会以为，我们并没有使用这个模块，不会对他进行打包，这时候，我们需要这样配置：添加<code>&quot;sideEffects&quot;: [&quot;@babel/polyfill&quot;]</code>这样，我们在打包的时候不会对这个模块进行<code>Tree Shaking</code>检查。</p>
</blockquote>
<p>一般我们在配置<code>sideEffects</code>选项的时候会配置成下面的：意思就是除了我们通过这种<code>import &quot;./strle.css&quot;</code>也不进行<code>Tree Shaking</code>检查，其他的对进行<code>Tree Shaking</code>检查，因为如果进行检查，会忽略我们的样式。</p>
<pre><code class="language-js">  &quot;sideEffects&quot;: [
   &quot;*.css&quot;
]
</code></pre>
<p>然后我们对上面的<code>inedx.js</code>进行重新打包，查看打包内容：<code>exports used: add</code>意思只有<code>add</code>方法被使用了。<code>Tree Shaking</code>并没有生效，因为开发环境下<code>Tree Shaking</code>会保留我们没用引入的代码，因为我们在查看报错的时候，如果去除了没有引入的代码，显示的行数会跟源代码不一致。如果我们的<code>mode</code>为<code>production</code>的时候，<code>Tree Shaking</code>就会生效了，其实在<code>mode</code>为<code>production</code>的时候，<code>optimization: { usedExports: true}</code>已经是配置好的，我们没必要再次进行配置，但是<code>package.json</code>中的<code>sideEffects</code>配置，还是需要的；同时将<code>devtool</code>改成：<code>devtool: 'cheap-module-source-map',</code></p>
<pre><code class="language-js。">/*! exports provided: add, minus */
/*! exports used: add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
eval(&quot;/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;a\&quot;, function() { return add; });\n/* unused harmony export minus */\nconst add = (a, b) =&gt; {\n  console.log(a + b);\n};\nconst minus = (a, b) =&gt; {\n  console.log(a - b);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoLmpzPzVhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PntcclxuICBjb25zb2xlLmxvZyhhICsgYilcclxufVxyXG5leHBvcnQgY29uc3QgbWludXMgPSAoYSwgYikgPT57XHJcbiAgY29uc29sZS5sb2coYSAtIGIpXHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/math.js\n&quot;);

</code></pre>
<h4 id="2-develoment-和-production-模式的区分打包">2. Develoment 和 Production 模式的区分打包</h4>
<p>我们一般写项目的时候，会对<code>webpack</code>进行两个配置，一个是生成版本的配置，一个是开发版本的配置；这里我的<code>Develoment</code>模式的配置文件在<code>webpack.dev.js</code>，我的<code>Production</code>模式的配置文件在<code>webapck.prod.js</code>中，然后我们在<code>package.json</code>进行配置我们允许的命令：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,
  },
</code></pre>
<p>这样，方面我们进行开发；<code>webpack.dev.js</code>配置如下：主要不同的是配置了打包的模式，开发环境的<code>devtool</code>配置为<code>cheap-module-eval-source-map</code>，生产环境的配置为：<code>cheap-module-source-map</code>,；我们在开发环境中使用下面的配置，每次修改js文件，需要进行手动刷新一次页面，我们去掉<code>hotOnly: true</code>，这样如果改变了<code>js</code>文件，就会自动刷新。</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpakcPlugin({
            template: './src/index.html'
        }),
        
    ],
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>我们查看我们的生产环境的配置以及开发环境的配置，会发现，有很多相同的配置，比如打包的规则，入口出口的配置等等，我们可以新建一个<code>webpack.common.js</code>文件，来存放两个配置中相同的部分，然后删除公共的部分；如下面的代码：<br>
<code>webpack.dev.js</code>配置如下：</p>
<pre><code class="language-js">
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    optimization: {
      usedExports: true
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
}
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">
module.exports = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
}
</code></pre>
<p><code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')

module.exports = {
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>然后我们通过<code>webpack-merage</code>插件来进行合并我们的配置文件，输入命令：<code>npm install webpack-merge -D</code>进行安装；然后修改我们的<br>
<code>webpack.prod.js</code>以及<code>webpack.dev.js</code>中的代码，修改后如下：<br>
<code>webpack.dev.js</code>配置如下：</p>
<pre><code class="language-js">
const webpack = require('webpack');
const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const devConfig = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    optimization: {
      usedExports: true
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
}
module.exports = merge(commonConfig, devConfig)
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
}
//模块导出的是两个文件的合并
module.exports = merge(commonConfig, prodConfig)
</code></pre>
<p>一般情况，我们会新建一个<code>build</code>文件夹来存放我们的这三个配置文件，然后修改我们的<code>package.json</code>中的命令：这样就可以了。</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;,
  },
</code></pre>
<h4 id="3-webpack-和-code-splitting">3. Webpack 和 Code Splitting</h4>
<h5 id="31-打包配置的一些问题">3.1 打包配置的一些问题</h5>
<p>我们在上面将开发版本以及生产版本的配置都通过提取方式写在了一个文件中，并放在了<code>build</code>文件夹中，但是我们没有修改打包输出文件的地址以及<code>clean-webpack-plugin</code>插件中清除文件夹的地址，所以我们修改<code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">    plugins: [
        new CleanWebpackPlugin(['dist'], {
            root: path.resolve(__dirname, '../')
        }),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
         publicPath: './',
         filename: '[name].js',
        path: path.resolve(__dirname, '../dist')
    }
</code></pre>
<p><code>clean-webpack-plugin</code>添加的<code>root</code>的配置意思的，重新设置了根目录，默认是认为配置文件所在的地址为根目录，这里我们的配置文件在<code>build</code>中，所以根目录在他的上一级。我查看<code>clean-webpack-plugin</code>的插件，并没有配置这个<code>root</code>选项；不知道哪个版本里面的，我们直接用如下的配置即可:还有我删除了打包输出文件的一些配置，因为<code>html-webpack-plugin</code>插件会有<code>bug</code>在我的基础文章笔记里面写了，可以去看看。</p>
<pre><code class="language-js">    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, '../dist')
    }
</code></pre>
<h5 id="32-code-splitting代码分割">3.2 Code Splitting代码分割</h5>
<p>我们在写代码的时候，经常会遇到引用很多第三方的包，来方便我们处理业务逻辑，比如我们使用<code>lodash</code>，但是这样会导致我们打包输出的时候，会将业务逻辑代码以及第三方库的代码打包到到一起；如果我们的业务网逻辑代码很多，会导致打包成功后的文件很大；页面加载速度很慢，如果我们修改了业务代码；这样整个页面得重新加载我们的代码。这个时候我们可以进行代码的分割：</p>
<h6 id="321-第一种方式自己实现代码分割将其他引用的第三方库进行分离写在另一个js脚本中">3.2.1 第一种方式：自己实现代码分割：将其他引用的第三方库进行分离写在另一个js脚本中</h6>
<p>将其他引用的第三方库进行分离写在另一个js脚本中，然后我们进行修改打包配置，进行配置多个入口如下：<br>
我们之前写的<code>index.js</code>代码：</p>
<pre><code class="language-js">import _ from 'lodash';
// ...业务逻辑
console.log(_.join(['a','b','c'],'***'))
</code></pre>
<p>修改后的配置文件</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        lodash: './src/lodash.js',
    },
</code></pre>
<p>将<code>index.js</code>分离出一个<code>lodash.js</code>文件，内容如下：</p>
<pre><code class="language-js">import _ from 'lodash';
windows._ = _;
</code></pre>
<p>在<code>index.js</code>中我们不在引入<code>lodash</code>，因为他已经被挂载到了全局对象上，我们直接可以使用，这样，减少了如果业务逻辑代码频繁修改后页面重新加载很大的打包输出文件；减少了业务逻辑代码的体积；如果我们改变了业务代码，页面只会重新加载业务代码，第三方的<code>lodash.js</code>文件会被缓存起来，不会重新加载。</p>
<h6 id="322-第二种方式使用webpack的代码分割同步加载包进行打包使用插件配置进行code-splitting">3.2.2  第二种方式：使用webpack的代码分割：同步加载包进行打包，使用插件配置进行Code Splitting</h6>
<p>我们在<code>webpack.common.js</code>中添加一个配置，代码如下：意思就是帮我们做代码分割</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'all'
      }
    },
</code></pre>
<p>然后我们查看打包输出文件，会打包出一个<code>main.js</code>的业务逻辑代码，以及<code>vendors~main.js</code>的第三方库文件的代码：<br>
<img src="https://img-blog.csdnimg.cn/20190525150350385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<code>vendors~main.js</code>文件内容：</p>
<pre><code class="language-js">(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;vendors~main&quot;],{

/***/ &quot;./node_modules/_lodash@4.17.11@lodash/lodash.js&quot;:
/*!*******************************************************!*\
  !*** ./node_modules/_lodash@4.17.11@lodash/lodash.js ***!
  \*******************************************************/
</code></pre>
<p><code>webpack</code>插件会很智能的分割我们的代码；</p>
<h6 id="323-第三种方式使用webpack的代码分割异步引入模块的代码分割">3.2.3  第三种方式：使用webpack的代码分割：异步引入模块的代码分割</h6>
<p>上面的包模块是一种同步的引入方式，然后<code>webpack</code>会先处理这些，然后进行处理我们的业务逻辑代码；我们这里再说一种异步b包模块引入的代码分割：我们的<code>index.js</code>代码如下</p>
<pre><code class="language-js">function getComponent () {
  return import('lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}

getComponent ().then((element) =&gt; {
  document.body.appendChild(element)
})
</code></pre>
<p>上面的代码通过<code>return import</code>这种引入方式是实验性质的语法会报错，我们可以通过一个<code>babel</code>的插件来解决这个问题，输入命令：<code>npm install babel-plugin-dynamic-import-webpack --save-dev</code>，然后在我们的<code>.babelrc</code>文件里面进行配置：多加一个<code>plugins: [&quot;dynamic-import-webpack&quot;]</code>配置</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ],
    plugins: [&quot;dynamic-import-webpack&quot;]
}
</code></pre>
<p>可以查看打包的日志：会生成两个<code>js</code>文件，<code>0.js</code>里面就是我们引入包的打包文件；<br>
<img src="https://img-blog.csdnimg.cn/20190525152610582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>这里需要注意的是：首先代码分割跟我们的<code>webpack</code>是无关的，我们只是通过代码分割这种思想来提升我们项目的性能；<code>webpack</code>中实现代码分割两种方式：</p>
<ol>
<li>同步代码：只需要在<code>webpack.common.js</code>中做<code>optimization</code>的配置；</li>
<li>异步代码（<code>import</code>）：无需做任何配置，会自动进行代码分割；</li>
</ol>
</blockquote>
<h4 id="4-splitchunksplugin-配置参数详解">4 SplitChunksPlugin 配置参数详解</h4>
<h5 id="41-修改打包输出的文件名">4.1 修改打包输出的文件名</h5>
<p>其实我们上面讲的<code>webpack</code>代码分割是使用了<code>SplitChunksPlugin</code>这个插件来实现的；我们查看打包结果，他会将<code>lodash</code>的第三方库打包成<code>0.js</code>的文件，我们如果想要改这个生成的文件名，可以通过魔法注释的方法来实现：我们在引入<code>lodash</code>前加了一个<code>/* webpackChunkName = &quot;lodash&quot;*/</code>意思就是打包后，这个模块的名字叫做<code>lodash.js</code></p>
<pre><code class="language-js">function getComponent () {
  return import(/* webpackChunkName:&quot;lodash&quot;*/'lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}

getComponent ().then((element) =&gt; {
  document.body.appendChild(element)
})
</code></pre>
<p>然后移除掉我们前面安装的<code>babel-plugin-dynamic-import-webpack</code>插件，因为这个插件不支持我们的魔法注释这种功能；在<code>package.json</code>删除<code>babel-plugin-dynamic-import-webpack</code>，然后在<code>.babelrc</code>文件里面去除我们的配置；然后我们使用官方提供的动态引入第三库的插件；输入命令：<code>npm install --save-dev @babel/plugin-syntax-dynamic-import</code>;然后在<code>.babelrc</code>文件中我们引入这个插件：</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ],
    plugins: [&quot;@babel/plugin-syntax-dynamic-import&quot;]
}
</code></pre>
<p>这样修改还是不行，他打包出的文件会在前面加一个<code>vendors~lodash.js</code>这样，我们需要去除这个前缀，打开<code>webpack.common.js</code>,修改<code>optimization</code>的配置如下：这样，打包之后的文件名就是我们所想要的了。</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: false,
          default: false
        }
      }
    },
</code></pre>
<p>其实我们不进行<code>splitChunks</code>配置，也可以进行打包的，因为，它本身有一个默认的配置，配置内容如下：</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'async',//代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all
        minSize: 30000,//设置模块大小大于30kb才会进行代码分割
        maxSize: 0,//设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出
        minChunks: 1,//当一个模块被用了至少多少次的时候，才进行分割。
        maxAsyncRequests: 5,//同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割
        maxInitialRequests: 3,//入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割
        automaticNameDelimiter: '~',//打包输出文件的连接符，例如vendors~main.js；vendors是组名，后面就是连接符；vendors~main.js意思是vendors组的入口文件是main.js
        name: true,
        cacheGroups: {
            // 如果引入的包是node_modules里面的内容，会进入到这里的配置
          vendors: {
            test: /[\\/]node_modules[\\/]/,//检测引入的第三方库是不是node_modules里面的内容
            priority: -10,
            filename: 'vendors.js' //如果是node_modules里面的内容，会打包到这个文件里面
          },
          // 如果引入的包不是node_modules里面的内容，会进入到这里的配置
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true,
            filename: 'common.js'
          }
        }
      }
   }
</code></pre>
<h5 id="42-splitchunksplugin-配置参数的意义">4.2 SplitChunksPlugin 配置参数的意义</h5>
<p>各个参数的意义：</p>
<ul>
<li><code>chunks</code>：设置打包是对异步代码（<code>async</code>）f分割；还是对同步代码（<code>initial</code>）做代码分割；还是对所有（<code>all</code>）的代码都打包；如果设置<code>all</code>或者<code>initial，他会进入到</code>cacheGroups`这个配置项，查看打包的配置；</li>
<li><code>vendors</code>：<code>test</code>是检测引入的包是不是<code>node_modules</code>里面的内容；如果是，他会将这库打包到<code>vendors</code>这个组中，打包后的文件会加一个<code>vendors~</code>前缀，代表是<code>vendors</code>这个组中；也就是这个库是<code>node_modules</code>里面的内容；我们可以加一个<code>filename: 'vendors.js'</code>这个配置项，这样，打包出来的所有的文件都会在<code>vendors.js</code>这个文件中；如果不是<code>node_modules</code>里面的内容，他会进入到<code>default</code>的配置中。</li>
<li><code>minSize</code>：设置模块大小大于30kb才会进行代码分割，设置打包文件的最小体积。</li>
<li><code>maxSize</code>：设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出</li>
<li><code>minChunks</code>：当一个模块被用了至少多少次的时候，才进行分割。</li>
<li><code>maxAsyncRequests</code>：同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割</li>
<li><code>maxInitialRequests</code>：入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割</li>
<li><code>automaticNameDelimiter</code>：打包输出文件的连接符，例如<code>vendors~main.js</code>；<code>vendors</code>是组名，后面就是连接符；<code>vendors~main.js</code>意思是<code>vendors</code>组的入口文件是<code>main.js</code></li>
<li><code>cacheGroups</code>：具体的打包输出文件的规则；注意这里的<code>priority</code>，其实大部分的包都是满足既是<code>node_modules</code>中的，又是满足默认的配置，我们通过<code>priority</code>设置优先级，优先执行哪个配置；数越大，优先级越高；越先执行。</li>
<li><code>reuseExistingChunk</code>：配置为<code>true</code>就是如果之前打包过该模块，再次遇到不会进行打包，只是复用以前打包的模块。</li>
</ul>
<h4 id="5-lazy-loading-懒加载chunk-是什么">5. Lazy Loading 懒加载，Chunk 是什么？</h4>
<h5 id="51-懒加载">5.1 懒加载</h5>
<p>我们的页面有时候会引入很多的包，或者第三方库文件；这时候整个页面加载速度会特别慢，我们可以通过懒加载的方式去加载这些包；来提高页面的响应速度。懒加载也就是说，我们在页面初始化的时候，不加载那些初始化不需要的包文件，只在需要包的函数中，进行异步加载包文件，如下面代码：这里，只要我们点击页面的时候才会需要<code>lodash</code>包，所以，我们通过异步加载，在页面首次加载的时候，不对该包进行加载；这样来提高页面的响应速度。</p>
<pre><code class="language-js">function getComponent () {
  return import(/* webpackChunkName:&quot;lodash&quot;*/'lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}
// 点击页面才会执行
document.addEventListener('click', () =&gt; {
  getComponent ().then((element) =&gt; {
    document.body.appendChild(element)
  })
})
</code></pre>
<p>可以使用异步函数<code>async</code>来改写上面的函数：</p>
<pre><code class="language-js">async function getComponent () {
  const {default: _} = await import(/* webpackChunkName:&quot;lodash&quot;*/'lodash');
  const element = document.createElement('div')
  element.innerHTML = _.join(['a','b','c'],'***')
  return element
}
// 点击页面才会执行
document.addEventListener('click', () =&gt; {
  getComponent ().then((element) =&gt; {
    document.body.appendChild(element)
  })
})
</code></pre>
<h5 id="52-chunk-是什么">5.2 Chunk 是什么？</h5>
<p>我们打包输出的每一个<code>js</code>文件，都是一个<code>Chunk</code>;可以查看我们打包输出的日志：<br>
<img src="https://img-blog.csdnimg.cn/2019052720265522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
比如我们前面配置的<code>chunks: 'async',</code>代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all，还有就是我们配置进行打包最小引用次数;<code>minChunks: 1</code>当一个模块被用了至少多少次的时候，才进行分割。</p>
<h4 id="6-打包分析preloading-prefetching">6. 打包分析，Preloading, Prefetching</h4>
<h5 id="61-打包分析工具">6.1 打包分析工具</h5>
<p><code>webpack</code>打包分析工具：<code>https://github.com/webpack/analyse</code>,如果要使用这个工具对我们打包生成的代码进行分析，我们首先需要生成一个打包过程的描述文件；通过这样命令<code>webpack --profile --json &gt; stats.json</code>，我们在<code>package.json</code>里面进行配置我们的打包命令：代码意思是，我们会将打包过程的描述信息放置到<code>stats.json</code>这个文件中；</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev-build&quot;: &quot;webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js&quot;
  },
</code></pre>
<p>然后点击进入这个网站<code>http://webpack.github.io/analyse/</code>（需要科学上网），上传我们打包的描述信息文件，会生成一个分析结果：<br>
<img src="https://img-blog.csdnimg.cn/20190527205335701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190527205400861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
我的<code>webpack</code>版本是<code>4.31.0</code>这里，显示的是不合适。我们也可以使用其他的检测工具<code>https://webpack.js.org/guides/code-splitting#bundle-analysis</code>这里介绍了很多。比如这个<code>https://alexkuz.github.io/webpack-chart/</code>也可以进行检查；</p>
<h5 id="62-preloading-prefetching">6.2 Preloading, Prefetching</h5>
<h6 id="621-异步加载交互代码提高性能">6.2.1  异步加载交互代码提高性能</h6>
<p>页面中一些交互的代码，比如点击页面才会执行的事件，或者点击按钮执行的事件这些；</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  const element = document.createElement('div')
  element.innerHTML = 'jiegiser'
  document.body.appendChild(element)
})
</code></pre>
<p>我们在页面初始化的时候，并没有用到这些；我们可以打开控制台，按<code>ctrl+shift+p</code>然后输入<code>&gt;show coverage</code>来查看我们文件的利用率：绿色的是页面加载有用的内容。<br>
<img src="https://img-blog.csdnimg.cn/20190527212614385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到我们在与页面交互的代码，没有被利用；页面一开始并没有使用这个交互式的函数，所以在页面初始化加载的时候，将这些代码全部下载进行加载，会浪费项目的性能。这种交互的代码最好是放在一个异步加载的模块里面，我们新建一个<code>click.js</code>文件，里面写我们异步加载模块等实现的交互式代码：</p>
<pre><code class="language-js">function handleClick () {
    const element = document.createElement('div')
    element.innerHTML = 'jiegiser'
    document.body.appendChild(element)
}

export default handleClick;
</code></pre>
<p>然后在<code>index.js</code>这样去引入我们的	<code>click.js</code>模块：</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  // func就是我们导出的handleclick方法
  import('./click.js').then(({default: func}) =&gt; {
    func();
  })
})
</code></pre>
<p>再次打开控制台的<code>&gt;show coverage</code>来查看我们文件的利用率：会发现比之前的高跟多；<br>
<img src="https://img-blog.csdnimg.cn/2019052808100047.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这也就说明了为什么<code>webpack</code>的<code>chunks: 'async'</code>默认的配置项是打包异步的代码，<code>webpack</code>真正希望的是我们多写这种异步加载模块的代码，进行打包，来提升性能。</p>
<h6 id="622-利用preloading-prefetching优化异步加载交互代码提高性能">6.2.2  利用Preloading, Prefetching优化异步加载交互代码提高性能</h6>
<p>我们前面写的只有页面需要展示的内容在页面初始化的时候进行加载，其他的交互式的代码可以通过异步加载的方式提高性能；但是比如我们有一个交互式的是一个点击按钮之后，打开一个模态框；这种交互式的如果等到用户点击按钮的时候再进行异步加载代码，是会等待很长时间的，我们可以通过<code>Preloading, Prefetching</code>（<code>https://webpack.js.org/guides/code-splitting#prefetchingpreloading-modules</code>）来优化加载，等到页面全部加载完成，网络空闲之后，再进行加载我们的异步交互代码；通过添加一个<code>/* webpackPrefetch: true */</code>魔法注释来实现，等到页面主要的<code>js</code>文件加载完成之后，再进行加载我们的交互代码；</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  // func就是我们导出的handleclick方法
  import(/* webpackPrefetch: true */ './click.js').then(({default: func}) =&gt; {
    func();
  })
})
</code></pre>
<p><code>Preloading</code>,和<code>Prefetching</code>基本是一样的；<code>Prefetching</code>是等到页面主要核心的<code>js</code>文件加载完成之后，带宽空闲的时候再进行加载异步加载的代码；<code>Preloading</code>是跟主要的业务逻辑代码一起加载的。</p>
<h4 id="7-css-文件的代码分割">7. CSS 文件的代码分割</h4>
<h5 id="71-使用minicssextractplugin-插件进行css代码分割">7.1 使用MiniCssExtractPlugin 插件进行css代码分割</h5>
<p>我们在输出配置的时候可以添加一个<code>chunkFilename</code>的配置项；我们配置的入口文件在打包输出的时候其实是根据<code>filename: '[name].js',</code>我们配置的这个进行打包输出，而其他的打包输出文件会根据我们配置的<code>chunkFilename</code>的配置项，来进行打包输出；我们之前打包<code>css</code>，打包成功之后会将<code>css</code>与<code>js</code>文件打包在一起；我们现在想把我们的<code>css</code>文件打包输出的时候也跟打包<code>js</code>文件一样单独输出，这时候就需要这个<code>MiniCssExtractPlugin</code>插件，来帮助我们：<br>
输入命令<code>npm install --save-dev mini-css-extract-plugin</code>进行安装这个插件，需要注意的是，这个插件不支持热更新，在开发环境的时候使用，开发效率较低，我们修改<code>css</code>样式之后，得手动刷新浏览器；一般我们在线上环境会使用这个插件。在开发环境的配置中添加下面的配置：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
    plugins: [
      new MiniCssExtractPlugin({})
    ]
}
// 模块导出的是两个文件的合并
module.exports = merge(commonConfig, prodConfig)
</code></pre>
<p>然后在打包的规则中，配置打包<code>css</code>文件的时候使用该插件提供的<code>loader</code>，把<code>css</code>单独打包成一个文件。然我们修改生产环境的配置，配置打包<code>css</code>文件的规则，如下代码：开发环境的打包<code>css</code>的规则可以不用修改</p>
<pre><code class="language-js">    module: {
      rules: [
        {
            test: /\.scss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'postcss-loader'
            ]
        },
      ]
    },
</code></pre>
<p>然后我们只想打包会发现并没有生成一个<code>css</code>文件，是因为我们前面配置了<code>tree shaking</code>会检测引入的包是否使用，如果没有使用就会去除，不会进行打包；我们可以修改<code>package.json</code>里面的配置，让其不对<code>css</code>文件进行检查：</p>
<pre><code class="language-js">  &quot;sideEffects&quot;: [
    &quot;*.css&quot;
  ],
</code></pre>
<p>然后将配置时候启用<code>tree shaking</code>检查的配置放在公用的配置文件（<code>webpack.common.js</code>）中：</p>
<pre><code class="language-js">    optimization: {
        usedExports: true
      },
</code></pre>
<p>修改后如下：</p>
<pre><code class="language-js">    // 修改配置，进行代码分割进行打包，以及去除打包成功之后添加的vendors~前缀
    optimization: {
      usedExports: true,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: false,
          default: false
        }
      }
    },
</code></pre>
<p>我们还可以在<code>MiniCssExtractPlugin</code>添加很多配置项，如下面代码：当打包的文件直接引入到页面的时候他的命名规则会走<code>filename</code>的配置项，如果是间接引入到页面，就会走下面的<code>chunkFilename</code>的配置项。如果页面直接引入了多个<code>css</code>文件，会直接将这些文件合并打包到一个<code>main.css</code>文件中。</p>
<pre><code class="language-js">    plugins: [
      new MiniCssExtractPlugin({
        filename: '[name].css',
        chunkFilename: '[name].chunk.css',
      })
    ]
</code></pre>
<h5 id="72-对打包输出的css文件进行压缩">7.2 对打包输出的css文件进行压缩</h5>
<p>需要压缩<code>css</code>文件，我们使用一个插件，输入命令进行安装：<code>npm install --save-dev optimize-css-assets-webpack-plugin</code>,然后在<code>webpack.prod.js</code>里面引入这个插件，进行配置如下：</p>
<pre><code class="language-js">const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const prodConfig = {
......
    optimization: {
      minimizer: [new OptimizeCssAssetsPlugin({})]
    },
  }
......
</code></pre>
<h5 id="73-多个js入口文件引入的css文件打包输出为一个文件">7.3 多个js入口文件引入的css文件打包输出为一个文件</h5>
<p>我们需要通过代码分割的配置添加一个<code>styles</code>的组，配置如下：<code>enforce: true,</code>就是说忽略掉我们配置的其他有关<code>css</code>文件打包的默认参数；</p>
<pre><code class="language-js">    splitChunks: {
      cacheGroups: {
        styles: {
          name: 'styles',
          test: /\.css$/,
          chunks: 'all',
          enforce: true,
        },
      },
    },
</code></pre>
<h5 id="74-根据配置入口js文件不同对其中引入的css文件进行单独打包">7.4 根据配置入口js文件不同，对其中引入的css文件进行单独打包</h5>
<p>我们还可以根据我们配置的<code>js</code>文件，对每个文件中引入的<code>css</code>文件打包输出成单独的一个文件。如下面配置：入口文件有<code>foo</code>跟<code>bar</code>，分别进行打包输出为不同的文件。</p>
<pre><code class="language-js">    splitChunks: {
      cacheGroups: {
        fooStyles: {
          name: 'foo',
          test: (m, c, entry = 'foo') =&gt;
            m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
        barStyles: {
          name: 'bar',
          test: (m, c, entry = 'bar') =&gt;
            m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
      },
    },
</code></pre>
<h4 id="8-webpack-与浏览器缓存-caching">8. Webpack 与浏览器缓存( Caching )</h4>
<h5 id="81-去除打包输出性能警告提示">8.1 去除打包输出性能警告提示</h5>
<p>我们有时候在打包文件的时候，控制台会抛出一个警告：警告我们打包输出的文件太大了超过了最大的<code>244kb</code>的大小。<br>
<img src="https://img-blog.csdnimg.cn/20190530083501241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
我们可以去除这个性能的警告，在<code>webpack.common.js</code>中添加配置</p>
<pre><code class="language-js">module.exports = {
    ........
    //去除控制台提示性能的问题
    performance: false,
    ........
}
</code></pre>
<h5 id="82-浏览器缓存">8.2 浏览器缓存</h5>
<p>我们每次打包之后的文件，如果不做添加文件修改，打包输出的文件每次都是一样的；这会导致浏览器加在我们的代码的时候出现使用缓存中已经缓存好的文件；这时候我们可以在打包输出的配置进行修改添加一个打包输出文件的唯一标识符：<code>contenthash</code>是文件的<code>hash</code>值；如果打包输出的文件没有变化，这个值不变，如果有变化，对应的这个值也会变化。</p>
<pre><code class="language-js">    output: {
      filename: '[name].[contenthash].js',
      chunkFilename: '[name].[contenthash].js'
    }
</code></pre>
<p>对于新版本的<code>webpack4.x</code>打包之后如果文件没有更改，会保持不变，但是老版本的<code>webpack4.x</code>货值之前的版本，有可能会发生变化，这个时候我们需要在<code>optimization</code>选项中添加下面的配置：</p>
<pre><code class="language-js">    optimization: {
      runtimeChunk: {
          name: 'runtime'
      },
    }
</code></pre>
<p>我们会发现打包生成后，多出来一个<code>runtime--.js</code>的文件，这个文件保存着库代码与业务代码之间的引用关系。</p>
<h4 id="9-shimming的作用">9. Shimming的作用</h4>
<h5 id="91-shimming的使用">9.1 Shimming的使用</h5>
<p><code>webpack</code> 编译器(<code>compiler</code>)能够识别遵循<code>ES2015</code>模块语法、<code>CommonJS</code>或 <code>AMD</code>规范编写的模块。然而，一些第三方的库(<code>library</code>)可能会引用一些全局依赖（例如 <code>jQuery</code>中的<code>$</code>）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 <code>shimming</code>发挥作用的地方，在<code>webpack</code>中，每个库文件是单独的，彼此隔离的；如下面的代码：<br>
新建的一个<code>jquery.ui.js</code>我们使用了<code>jquery</code>但事故我们的库文件没有引入他。</p>
<pre><code class="language-js">export function ui () {
  $('body').css('background', 'red')
}

</code></pre>
<p><code>index.js</code>文件：</p>
<pre><code class="language-js">import _ from 'lodash'
import $ from 'jquery'
import { ui } from './jquery.ui.js'
ui();
const dom = $('&lt;div&gt;')
dom.html(_.join(['dell', 'lee'], '---'))
$('body').append(dom)
</code></pre>
<p>这样会提示<code>$</code>没有定义，我们原本想着前面引入了<code>jquery</code>为什么还是没用，就是因为在<code>webpack</code>中，每个库文件是单独的，彼此隔离的，我们一般引入的库文件是第三方的，存放在<code>node_module</code>中，我们也不可能去修改它里面的内容，所以这时候就需要使用<code>Shimming</code>来解决问题；修改我们的<code>webpack.common.js</code>:<code>new webpack.ProvidePlugin</code>这个<code>webpack</code>自带的插件会进行对打包文件进行检查，如果检测到你的代码中有<code>$</code>这个符号，他会自动帮你引入<code>jquery</code>模块。然后将<code>jwuery</code>模块赋值给<code>$</code>字符串。</p>
<pre><code class="language-js">const webpack = require('webpack')
module.exports = {
    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        .....
        new webpack.ProvidePlugin({
            $: 'jquery'
        })
    ],
}
</code></pre>
<p>同样这里的配置我们还可以直接将某一个包的方法进行配置到这里，比如：我想使用<code>lodash</code>模块中的<code>join</code>方法，之前我们是引入<code>import _ from 'lodash'</code>这样引入，然后<code>_.join</code>这样调用他的<code>join</code>方法，但是我这里就想<code>_join</code>这样去调用<code>join</code>方法，我们可以在<code>webpack.common.js</code>进行配置</p>
<pre><code class="language-js">export function ui () {
  $('body').css('background', 'red')
  $('body').html(_join(['ddd', 'ddd'],'----'))
}
</code></pre>
<p>配置如下：<code>_join: ['lodash', 'join']</code>意思就是，当我们打包的时候遇到<code>_join</code>，就去引入<code>lodash</code>，将<code>lodash</code>中的<code>join</code>方法，赋值给他。</p>
<pre><code class="language-js">    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.ProvidePlugin({
            $: 'jquery',
            _join: ['lodash', 'join']
        })  
    ],
</code></pre>
<h5 id="92-利用shimming改变模块中this指向window">9.2 利用Shimming改变模块中this指向window</h5>
<p>我们在模块中，比如我们的入口文件，我们打印<code>console.log(this === window);</code>会发现，里面的<code>this</code>指向并不是<code>window</code>对象，我们可以借助一些<code>loader</code>:输入命令进行安装<code>npm install imports-loader --save-dev</code>,然后进行修改<code>webpack.common.js</code>中打包<code>js</code>文件的配置：<code>loader: &quot;imports-loader?this=&gt;window&quot;</code>当我们打包<code>js</code>文件的时候，会走下面的规则，然后将我们每个模块中的<code>this</code>指向我们的<code>windos</code>对象。</p>
<pre><code class="language-js">    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
          ]
        }]
       }
</code></pre>
<blockquote>
<p>深入学习：查看<code>webpack</code>官网中<code>guides</code>里所有内容。</p>
</blockquote>
<h4 id="10-webpack环境变量的使用方法">10. Webpack环境变量的使用方法</h4>
<p>之前我们是将我们的配置文件分成了三个部分<code>webpack.dev.js webapck.common.js webapck.prod.js</code>然后在<code>package.json</code>配置命令如下：进行运行不同的文件：<br>
<code>package.json</code>之前的配置：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.dev.js&quot;,
  },
</code></pre>
<p>我们现在可以修改一下我们之前的配置，将<code>webpack.dev.js</code>配置如下：直接导出配置；</p>
<pre><code class="language-js">
const webpack = require('webpack');
// const merge = require('webpack-merge')
// const commonConfig = require('./webpack.common.js')
const devConfig = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    module: {
      rules: [
        {
          test: /\.scss$/,
          use: [
              'style-loader',
              {
                loader: 'css-loader',
                options: {
                  importLoaders: 2
                }
              },
              'sass-loader',
              'postcss-loader'
          ]
      }, {
          test: /\.css$/,
          use: [
              'style-loader',
              'css-loader',
              'postcss-loader'
          ]
      },
      ]
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
    // output: {
    //   filename: '[name].js',
    //   chunkFilename: '[name].js'
    // }
}
// module.exports = merge(commonConfig, devConfig)

module.exports = devConfig;
</code></pre>
<p>对应的<code>webpack.prod.js</code>修改为：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
// const merge = require('webpack-merge')
// const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    // 暂时先屏蔽输出source文件
    // devtool: 'cheap-module-source-map',
    module: {
      rules: [
        {
            test: /\.scss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'postcss-loader'
            ]
        },
      ]
    },
    optimization: {
      minimizer: [new OptimizeCssAssetsPlugin({})]
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: '[name].css',
        chunkFilename: '[name].chunk.css',
      })
    ],
    output: {
      filename: '[name].[contenthash].js',
      chunkFilename: '[name].[contenthash].js'
    }
}
// 模块导出的是两个文件的合并
// module.exports = merge(commonConfig, prodConfig)
module.exports = prodConfig;
</code></pre>
<p>然后我们在<code>webpack..common.js</code>进行根据我们在<code>package.json</code>中配置的命令进行判断是使用哪一个配置文件：<br>
首先修改<code>package.json</code>：<code>--env.production</code>为传入参数；表示是生产环境的配置</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.common.js&quot;,
    &quot;test&quot;: &quot;webpack-dev-server&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后在<code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p><code>webpack.common.js</code>文件内容：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')

//重新配置环境变量
/**************** */

const merge = require('webpack-merge');
const devConfig = require('./webpack.dev.js')
const prodConfig = require('./webpack.prod.js')

/*************** */
const webpack = require('webpack')
// module.exports = {
const commonConfig = {
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
          ]
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        },  {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.ProvidePlugin({
            $: 'jquery',
            _join: ['lodash', 'join']
        })  
    ],
    //去除控制台提示性能的问题
    performance: false,
    // 修改配置，进行代码分割进行打包，以及去除打包成功之后添加的vendors~前缀
    optimization: {
      runtimeChunk: {
          name: 'runtime'
      },
      usedExports: true,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10,
            name: 'vendors'
          },
        }
      }
    },
  //   optimization: {
  //     splitChunks: {
  //       chunks: 'async',//代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all
  //       minSize: 30000,//设置模块大小大于30kb才会进行代码分割
  //       maxSize: 0,//设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出
  //       minChunks: 1,//当一个模块被用了至少多少次的时候，才进行分割。
  //       maxAsyncRequests: 5,//同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割
  //       maxInitialRequests: 3,//入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割
  //       automaticNameDelimiter: '~',//打包输出文件的连接符，例如vendors~main.js；vendors是组名，后面就是连接符；vendors~main.js意思是vendors组的入口文件是main.js
  //       name: true,//
  //       cacheGroups: {
  //           // 如果引入的包是node_modules里面的内容，会进入到这里的配置
  //         vendors: {
  //           test: /[\\/]node_modules[\\/]/,//检测引入的第三方库是不是node_modules里面的内容
  //           priority: -10,
  //           filename: 'vendors.js' //如果是node_modules里面的内容，会打包到这个文件里面
  //         },
  //         // 如果引入的包不是node_modules里面的内容，会进入到这里的配置
  //         default: {
  //           minChunks: 2,
  //           priority: -20,
  //           reuseExistingChunk: true,
  //           filename: 'common.js'
  //         }
  //       }
  //     }
  //  },
    // 打包出的文件配置/*这里的配置会跟打包HTML的插件冲突 */
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        // publicPath: './',
        // // 文件名
        // filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        // 非入口文件打包输出走下面的配置项
        // chunkFilename: '[name].chunk.js',
        path: path.resolve(__dirname, '../dist')
    }
}

module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p>我们也可以进行传参数，这样：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env production --config ./build/webpack.common.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后<code>webpack.common.js</code>这样：</p>
<pre><code class="language-js">module.exports = (production) =&gt; {
    if (production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p>或者在传参数的时候传入一个字符串：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env.production =abc --config ./build/webpack.common.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后<code>webpack.common.js</code>这样：</p>
<pre><code class="language-js">module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production === 'abc) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack实战配置案例]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-shi-zhan-pei-zhi-an-li</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-shi-zhan-pei-zhi-an-li">
        </link>
        <updated>2019-12-06T01:37:45.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-library打包">1. Library打包</h4>
<h5 id="11-对库文件进行打包">1.1 对库文件进行打包</h5>
<p>库文件的打包：我们新建一个工程，新建<code>index.js math.js string.js</code>,代码如下：</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-library打包">1. Library打包</h4>
<h5 id="11-对库文件进行打包">1.1 对库文件进行打包</h5>
<p>库文件的打包：我们新建一个工程，新建<code>index.js math.js string.js</code>,代码如下：</p>
<!-- more -->
<p><code>index.js</code>文件</p>
<pre><code class="language-js">import * as math from './math.js'
import * as string from './string.js'
export default { math, string }
</code></pre>
<p><code>math.js</code>文件：</p>
<pre><code class="language-js">export function add (a, b) {
 return a + b;
}
export function minius (a, b) {
  return a - b;
}
export function multiply (a, b) {
  return a * b;
}
export function division (a, b) {
  return a / b;
}
</code></pre>
<p><code>string.js</code>文件</p>
<pre><code class="language-js">export function join (a, b) {
    return a + ' ' + b
}
</code></pre>
<p>然后我们打包输出，我们这个库，在给被人使用的是，别人会有很多种方式，进行使用；比如：<br>
<code>ES module</code>：</p>
<pre><code class="language-js">import library from ‘library’
</code></pre>
<p><code>commonJS</code>方式：</p>
<pre><code class="language-js">const library = require('library')
</code></pre>
<p><code>AMD</code>引入方式：</p>
<pre><code class="language-js">require(['library'], function () {

})
</code></pre>
<p>我们如果想让我们的库文件，在外面可以用上面的这些方式引入，我们可以进行配置，在<code>webpack.config.js</code>中配置如下：<code>libraryTarget: 'umd'</code>代码意思就是不管是在<code>AMD</code>的环境，还是<code>CommonJS</code>的环境、或者是<code>import</code>方式引入，都可以正确使用我们的库文件。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd'
    }
}
</code></pre>
<p>如果我们想用</p>
<pre><code class="language-js">&lt;script src=&quot;library.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这种方式引入，然后使用<code>library.math</code>这种全局变量来使用我们的库，这时候我们需要在<code>webpack.config.js</code>中添加一个配置项：<code>library: 'library',</code>意思是将<code>library</code>挂载到了全局变量上，这样，就可以通过<code>script</code>引入，然后进行使用了。</p>
<pre><code class="language-js">    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
</code></pre>
<p>其实<code>libraryTarget</code>跟<code>library</code>相互作用的，如果配置成上面的，是没有多大关系的，我们可以修改 <code>libraryTarget: 'this'</code>意思就是它不支持<code>AMD commonJS</code>等这些语法引入了，但是我们的<code>library</code>会挂载到全局的<code>this</code>上面。同样，也可以是<code>window</code>；，如果在<code>nodeJS</code>环境下，也可以配置 <code>global</code>；</p>
<pre><code class="language-js">    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'this'
    }
</code></pre>
<p>我们有时候在我们的库文件中，我们使用了第三方的库文件，比如我们将我们的<code>string.js</code>代码改成下面的：我们引入了<code>lodash</code>,</p>
<pre><code class="language-js">import _ from 'lodash'
export function join (a, b) {
    return _.join([a, b],' ')
}
</code></pre>
<p>然后别人在使用我们的库文件的时候，有可能也会使用<code>lodash</code>这个库文件，这样可能会导致一个问题，用户打包后的代码会出现两个<code>lodash</code>文件，我们可以通过配置，来去除这种重复引用;<code>externals: ['lodash'],</code>意思就是打包过程中，如果遇到<code>lodash</code>就忽略这个库文件，然后比尔使用我们这个库的使用还是需要在自己的业务代码中引入<code>lodash</code>库。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    externals: ['lodash'],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
}
</code></pre>
<p>这里的<code>externals</code>也可以是一个对象：下面配置的意思是如果在<code>commonJS</code>环境下，我们使用<code>library</code>库文件：</p>
<pre><code class="language-js">const library = require('library')
</code></pre>
<p>这样，我们引入<code>lodash</code>的时候，命名必须定义成<code>lodash</code>:如下：<code>const lodash = require('lodash')</code></p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    externals: {
        lodash: {
            commonjs: 'lodash',
        }
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
}
</code></pre>
<h5 id="12-发布一个包">1.2 发布一个包</h5>
<p>首先我们需要修改<code>pachage.json</code>中入口改成：<code>./dist/library.js</code>表示，我们的库文件最终给别人使用的时候，入口文件是<code>./dist/library.js</code>文件。然后在<code>npm</code>上注册一个账号；<br>
然后在命令行里面输入<code>npm adduser</code>，然后输入用户名与密邮箱等。然后输入命令<code>npm publish</code>进行发布我们的包文件，这里需要注意的是，包的名字，不能重复；需要修改<code>name</code>，值，然后我们使用我们发布的包，可以运行命令<code>npm install 包名</code>就可以了。</p>
<h4 id="2-pwaprogressive-web-application的打包配置">2. PWA（Progressive Web Application）的打包配置</h4>
<p>这个是一个新的前端技术。首先一个知识点就是在配置<code>js</code>文件打包输出的时候，配置<code>this</code>的指向：在<code>webpack.config.js</code>中的配置打包输出<code>js</code>的<code>loader</code>中，进行配置：<code>loader: &quot;imports-loader?this=&gt;window&quot;</code>这句话就是将<code>this</code>指向了<code>window</code>对象。</p>
<pre><code class="language-js">{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
</code></pre>
<p>我们可以通过一个<code>http-server</code>模块来模拟我们的服务器，当然也可以使用<code>live-server</code>两个都是一样的。输入命令<code>npm install http-server -D</code>进行安装。然后我们在<code>package.json</code>里面进行配置一个命令，来运行我们的服务器：<code>&quot;start&quot;: &quot;http-server dist&quot;</code>代码的意思就是在我们打包输出的<code>dist</code>的文件夹中启动一个服务器。</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;http-server dist&quot;
  },
</code></pre>
<p>输入运行命令之后，我们可以看到我们的网页正常显示了。如果这个时候，我们将服务器断开，浏览器会出现：无法访问此网站，也就是我们的网站挂了，而<code>pwa</code>技术是如果你第一次访问网站，访问成功之后，突然之间服务器挂了，你第二次再次访问这个网站的时候，他会利用你本地的缓存，可以利用缓存，把之前访问的页面展示出来。也就是说，即便服务器挂了，我在本地还是可以看到之前访问到的页面。<br>
我们可以在<code>webpack</code>中，通过一个插件来实现：<br>
输入命令：<code>npm install workbox-webpack-plugin --save-dev</code>进行安装，我们只需要在线上环境之后，进行使用<code>pwa</code>技术，让用户体验更好，所以，我们只需要修改<code>webapck.prod.js</code>的配置文件。</p>
<pre><code class="language-js">.....
const WorkboxPlugin = require('workbox-webpack-plugin')
const prodConfig = {
....
    plugins: [
    ....
      new WorkboxPlugin.GenerateSW({
        // 这些选项帮助快速启用 ServiceWorkers
        // 不允许遗留任何“旧的” ServiceWorkers
        clientsClaim: true,
        skipWaiting: true
      })
    ....
    ],
}
....
</code></pre>
<p>然后我们进行运行<code>npm run build</code>进行打包，现在你可以看到，生成了两个额外的文件：<code>service-worker.js</code>和名称冗长的 <code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>。<code>service-worker.js</code>是<code>Service Worker</code>文件，<code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>是 <code>service-worker.js</code>引用的文件，所以它也可以运行。可能你本地生成的文件可能会有所不同；但是应该会有一个<code>service-worker.js</code>文件。但是我们重复上面的操作之后，关闭服务器，再次访问的时候，还是不能查看我们上次访问的网页，因为我们还差一步，那就是注册<code>Service Worker</code>，在我们的<code>src</code>目录中的主入口<code>js</code>文件加上下面代码：</p>
<pre><code class="language-js">if ('serviceWorker' in navigator) {
  window.addEventListener('load', () =&gt; {
    navigator.serviceWorker.register('/service-worker.js').then(registration =&gt; {
      console.log('SW registered: ', registration);
    }).catch(registrationError =&gt; {
      console.log('SW registration failed: ', registrationError);
    });
  });
}
</code></pre>
<p>再次运行<code>npm build build</code>来构建包含注册代码版本的应用程序。然后用 <code>npm start</code>将构建结果<code>serve</code>到服务下。导航至 <code>http://localhost:8080</code>并查看 <code>console</code> 控制台。应该看到：<code>SW registered</code>,现在来进行测试。停止 <code>server</code>并刷新页面。如果浏览器能够支持 <code>Service Worker</code>，应该可以看到你的应用程序还在正常运行。</p>
<h4 id="3-typescript-的打包配置">3. TypeScript 的打包配置</h4>
<p><code>TypeScript</code>可以进行代码的规范，也可以很方便的进行报错提示；可以有效的提升<code>JavaSCript</code>的可维护性。首先我们进行配置打包<code>typescript</code>的规则，我们要使用一个<code>ts-loader</code>这个<code>loader</code>来进行打包<code>tsx</code>的文件，当然我们首先需要安装这个<code>loader</code>,使用这个<code>loader</code>的时候，你必须要安装<code>typescript</code>，所以运行下面的命令进行安装：<code>npm install ts-loader typescript --save-dev</code><br>
配置<code>webpack.config.json</code>如下：</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    entry: './src/index.tsx',
    module: {
        rules: [{
            test: /\.tsx?$/,
            use: 'ts-loader',
            exclude: /node_modules/
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>但是这样还是不能够进行打包，我们需要添加一个<code>tsconfig.json</code>，进行配置打包<code>TypeScript</code>的规则：</p>
<pre><code class="language-js">{
    &quot;compilerOptions&quot;: {
        &quot;outDir&quot;: &quot;./dist&quot;,//打包输出的地址
        &quot;module&quot;: &quot;es6&quot;,// 模块的引用方式是使用esmodule的语法
        &quot;target&quot;: &quot;es5&quot;,//打包成es5的代码
        &quot;allowJs&quot;: true//是否允许在TypeScript中引入js模块
    }
}
</code></pre>
<p>这样就可以打包成功了；我们之所以使用<code>TypeScript</code>是进行规范我们代码书写，以及类型引用的正确；比如我们使用<code>lodash</code>这样的库文件，我们在使用这个库的时候，我们有时候不知道这个函数的参数是什么 ，也没有提示我们书写的正确性，只有运行之后，才会知道；当然你也可以去查看文档。我们可以使用对应库文件的<code>TypeScript</code>类型文件，比如我们前面说<code>lodash</code>，我们进行输入命令<code>npm install @types/lodash --save-dev</code>进行安装对应的<code>TypeScript</code>类型文件，然后我们调用里面的函数，如果传入的参数不对，会直接进行提示；<br>
我们在<code>TypeScript</code>中引用<code>lodash</code>,需要使用下面的代码：</p>
<pre><code class="language-js">import * as _ from 'lodash'
</code></pre>
<p>如果需要使用其他库文件，就安装对应的<code>TypeScript</code>类型文件。如果你不知道有还是没有，可以在这个网站;<code>https://microsoft.github.io/TypeSearch/</code>进行搜索对应的库文件。</p>
<h4 id="4-使用-webpackdevserver-实现请求转发">4. 使用 WebpackDevServer 实现请求转发</h4>
<p>我们一般在前端发送<code>ajax</code>请求是使用<code>axios</code>这个库进行发送请求，首先我们需要进行安装；一个简单的请求如下：</p>
<pre><code class="language-js">import axios from 'axios'
axios.get('http://www.dell-lee.com/react/api/header.json')
.then((res) =&gt; {
  console.log(res)
})
</code></pre>
<p>我们一般在生产环境的时候，是使用其他服务器的<code>api</code>接口，并不是使用真正的后台接口，是一台测试的服务器，线上环境我们是使用真正的接口数据。所所以这个时候，我们就需要进行对接口的转发。配置<code>devServer</code>如下：<code>'/react/api': 'http://www.dell-lee.com'</code>代码的意思就是当我发送请求<code>/react/api</code>地址的时候，接口转发到<code>http://www.dell-lee.com</code>这个地址。进行获取对应的数据。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': 'http://www.dell-lee.com',
      },
      hot: true,
    },
</code></pre>
<p>然后在发送请求的地址如下代码：</p>
<pre><code class="language-js">import axios from 'axios'
axios.get('/react/api/header.json')
.then((res) =&gt; {
  console.log(res)
})
</code></pre>
<p>也可以对一个接口请求的地址进行转发，比如我们现在请求的是<code>http://www.dell-lee.com/react/api/header.json</code>实际我们需要请求的是<code>http://www.dell-lee.com/react/api/demo.json</code>,可以在<code>devserver</code>配置如下;</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>当然我们只有在开发环境的时候进行上面的配置是有用的，有时候我们请求的地址是<code>https</code>协议的网址，需要加一个配置项：<code>secure: false,</code></p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>我们在这里也可以进行拦截，比如下面的代码配置：<code>bypass</code>里面的配置项就是说当发送请求要接手的是<code>html</code>页面数据的时候，也就是说请求是一个<code>html</code>的地址的时候，直接跳转到<code>index.html</code>页面。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>如果我们代理多个路基，可以进行下面这样的配置：我们上面只有一个<code>'/react/api'</code>一个路径，下面代码表示遇到<code>'/auth', '/api'</code>这两个地址，都是转发到<code>https://www.dell-lee.com</code>这个服务器。</p>
<pre><code class="language-js">    devServer: {
      proxy: {
      context: ['/auth', '/api'],
      target: 'https://www.dell-lee.com',
      },
      hot: true,
    },
</code></pre>
<p>如果我们想做一个根目录的路径的转发，也就是<code>'/'</code>，我们需要将配置项的<code>index</code>设置为<code>false</code>或者为<code>''</code>空字符串，如下配置:</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        index: '',
        '/': {
          target: 'https://www.dell-lee.com',
          secure: false,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>我们可以设置<code>changeOrigin: true</code>来覆盖一些请求服务器对<code>origin</code>进行的配置，如下代码：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        index: '',
        '/': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<h4 id="5-webpackdevserver-解决单页面应用路由问题">5.  WebpackDevServer 解决单页面应用路由问题</h4>
<p>如果我们需要实现<code>react</code>的路由功能实现单页面应用，需要安装路由组件，输入命令：<code>npm intall react-router-dom --save</code>，然后我们写了两个组件<code>home</code> 跟 <code>list</code> 两个组件，代码如下：</p>
<pre><code class="language-js">import React, { Component } from 'react'
import {BrowserRouter, Router} from 'react-router-dom';
import ReactDom from 'react-dom'
import Home from './home.js';
import List from './list.js'


class App extends Component {
  return () {
    return (
      &lt;BrowserRouter&gt;
        &lt;div&gt;
         &lt;Router path='/' component={Home} /&gt;
         &lt;Router path='/list' component={List}/&gt;
         &lt;/div&gt;
      &lt;/BrowserRouter&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p><code>home.js</code>代码：</p>
<pre><code class="language-js">import React, { Component } from 'react';

class Home extends Component {
    render () {
        return &lt;div&gt;HomePages&lt;/div&gt;
    }
}
export default Home
</code></pre>
<p><code>list.js</code>代码：</p>
<pre><code class="language-js">import React, { Component } from 'react';

class Home extends Component {
    render () {
        return &lt;div&gt;HomePages&lt;/div&gt;
    }
}
export default Home
</code></pre>
<p>我们写完代码之后，运行；当我们地址中访问<code>list</code>页面的时候，会发现找不到对应的页面，这是因为，<code>webpack</code>将我们页面 的请求以为是发送到后台的<code>api</code>接口。解决这个问题，我们就需要在<code>devserver</code>中进行配置<code>historyApiFallback</code>的配置项，具体配置如下：<code>historyApiFallback: true,</code></p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      historyApiFallback: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>这个选项也可以是一个对象，进行配置规则，进行进一步配置：代码意思是，当访问<code>item.html</code>的时候，实际访问的是<code>list.html</code>页面。</p>
<pre><code class="language-js">      historyApiFallback: {
        rewrites: [
          { 
            from: '/item.html',
            to: '/list.html'
          }
        ]
      },
</code></pre>
<p>其实我们前面配置的<code>historyApiFallback: true,</code>实际等价于下面的配置：也就是不官方文哪一个都是指向<code>index.html</code>页面。</p>
<pre><code class="language-js">      historyApiFallback: {
        rewrites: [
          { 
            from: '/\.*/',
            to: '/index.html'
          }
        ]
      },
</code></pre>
<h4 id="6-eslint-在-webpack-中的配置">6.  EsLint 在 Webpack 中的配置</h4>
<p><code>EsLint</code>就是规范我们代码书写的插件，输入命令<code>npm install eslint --save-dev</code>,然后在我们的项目中，通过命令<code>npx eslint --init</code>快速生成我们代码约束的配置文件，按照提示的信息进行配置我们的代码约束规则。我们可以输入命令<code>npx eslint src</code>这样的命令。来检测<code>src</code>目录下文件的书写规范，或者直接可以检测一个文件<code>npx eslint index.js</code>这样进行检测。<br>
如果我们配置的代码检测的规范是使用<code>airbnb</code>这种规范，我们会发现，我们去检测我们写的<code>react</code>的代码的时候，会提示很多错误，这是因为这个规范只是检测常规的<code>js</code>代码的一些规范，不会进行解析<code>react</code>的代码，进行检测规范，这个时候，我们需要添加一个解析器，<code>.eslintrc.js</code>配置代码如下：需要安装<code>babel-eslint</code>这个解析器，输入命令<code>npm install babel-eslint --save-dev</code>进行安装。</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;
}
</code></pre>
<p>也可以直接在<code>vscode</code>这个编译器中进行安装<code>eslint</code>插件，进行检测我们的代码规范，进行提示。我们也可以自己进行配置一些规范是否启用，在<code>.eslintrc.js</code>中进行配置，比如我们不需要一个配置，直接在<code>rules</code>中将对应的规范配置为0：</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    &quot;react/prefer-stateless-function&quot;: 0
  }
}
</code></pre>
<p>还有一些<code>eslint</code>的配置可以查看另一篇文章：https://blog.csdn.net/cj9551/article/details/90740377#15_ESLint_457  里面有对应的<code>eslint</code>的配置。<br>
如果需要使用全局变量，可以在配置项中进行配置：<code>document: false</code>不会被重新覆盖。</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    &quot;react/prefer-stateless-function&quot;: 0
  },
  global: {
    document: false
  }
}
</code></pre>
<p>如果有的人的编译软件，是不能安装<code>eslint</code>查看，我们可以直接在<code>webpack</code>中进行配置这样一个检测环境，首先安装<code>eslint-loader</code>这样一个<code>loader</code>，输入命令<code>npm install eslint-loader --save-dev</code>，然后在<code>webpack.config.js</code>中进行配置：</p>
<pre><code class="language-js">module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: ['babel-loader', 'eslint-loader']
        }]
    },
</code></pre>
<p>然后运行命令，就可以在终端窗口看到一些代码规范的提示，我们也可以在<code>devserver</code>中进行添加一个<code>overlay: true</code>的配置，将代码规范的提示，直接显示在浏览器的页面中：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      // historyApiFallback: true,
      historyApiFallback: {
        rewrites: [
          { 
            from: '/item.html',
            to: '/list.html'
          }
        ]
      },
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          overlay: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<h4 id="7-webpack-性能优化">7.   webpack 性能优化</h4>
<ul>
<li>跟上技术的迭代（node，npm，yarn）：升级我们对应的工具；<code>webpack</code>运行在<code>node</code>之上。升级到新的版本，也会间接提升<code>webpack</code>打包速度。</li>
<li>在尽可能少的模块上应用<code>Loader</code>： 比如我们在打包<code>js</code>的文件的时候使用<code>babel-loader</code>进行转换，我们可以通过<code>includes</code>以及<code>excludes</code>等选项，进行配置不对其他库文件进行转换，降低使用<code>loader</code>的频率。</li>
<li><code>Plugin</code> 尽可能精简并确保可靠：比如我们在线上环境的配置中使用了<code>MiniCssExtractPlugin</code>插件进行将<code>css</code>代码进行压缩，但是我们在生产环境中，并不需要使用这个插件进行压缩我们的代码，要尽可能的精简。减少了代码压缩的时间。还有就是尽量使用<code>webpack</code>官网中推荐的插件。</li>
<li>一般我们在打包配置<code>js</code>的文件，与<code>jsx</code>的文件，打包规则是一样的，我们在<code>test</code>匹配的时候，可以使用<code>test: /\.jsx?$/,</code>进行匹配打包。</li>
<li>尽量减少下面的一些操作：我们有时候通过<code>import</code>的方式进行引入一个模块，我们在模块的结尾并没有明确是加载哪个类型的文件，<code>import List from './list'</code>默认是加载<code>js</code>结尾的文件，但是有时候我们的库文件是<code>jsx</code>结尾的文件，我们也想通过这种方式进行加载<code>jsx</code>文件，可以进行下面的配置：<code>extensions: ['.js', '.jsx']</code>代码意思就是引入包之后，他会按照是否有对应的<code>js</code>,如果有就进行加载，如果没有继续找是否有对应的<code>jsx</code>文件进行加载。</li>
</ul>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx']
    }
.....
}
</code></pre>
<p>这个选项还可以配置我们通过引入路径，然后对路径中的文件名进行对应的加载，比如：<code>import List from './list/'</code>这个<code>list</code>是<code>src</code>目录中的一个文件夹名，然后该文件夹中有很多<code>js</code>文件，如果按照这种引入方式，他会自动检查是否有文件名叫<code>index</code>的文件，然后进行引入，如果没有，就不会进行引入，我们可以通过配置<code>resolve</code>选项，配置加载的文件名：<code>mainFiles: ['index', 'list']</code>代码意思是如果通过路径的方式进行引入模块，首先检查进行加载<code>index</code>的文件名，如果没有，进行检查是否有<code>list</code>的文件名进行引入。</p>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx'],
       mainFiles: ['index', 'list']
    }
.....
}
</code></pre>
<p>同样上面的<code>extensions</code>,以及 <code>mainFiles</code>的配置，会影响打包的性能。在<code>resolve</code>中，我们也可以进行设置路径的别名：比如我们有时候想引入一个模块通过一个字符串，进行代表该库文件的地址，进行引入模块：<code>import list from 'listpath'</code>这样的方法进行引入模块。我们就可以设置别名，让<code>listpath</code>指向该模块的地址。</p>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx'],
       mainFiles: ['index', 'list'],
       alias: {
        listpath: path.resolve(__dirname, '../src/list')
      }
    }
.....
}
</code></pre>
<h4 id="8-使用dllplugin提高打包速度">8.  使用DllPlugin提高打包速度</h4>
<p>我们实现的思路：</p>
<ol>
<li>第三方模块打包一次</li>
<li>我们引入第三方模块的时候，要去使用打包输出的第三方模块的文件进行引入。<br>
我们在打包自己的项目的时候会发现，如果引入了过多的第三方库文件，会使打包的速度降低；我们可以想如果能够实现在第一次打包的时候就去分析第三方模块的代码，然后再次打包的时候，就根据前面分析的结果进行打包，不用再次分析，提高打包效率；<br>
添加一个<code>webpack.dll.js</code>的配置文件，代码如下：这里是将我们引入的第三方模块打包到<code>dll</code>文件夹中，<code>library: '[name]'</code>这句代码的意思就是，将我们打包后的第三方模块通过变量的形式暴露到全局中；变量的名字叫<code>vender</code>；</li>
</ol>
<pre><code class="language-js">const path = require('path')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['react', 'react-dom', 'lodash']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    }
}
</code></pre>
<p>然后我们需要安装一个插件，将我们的打包后的文件进行挂载到我们打包输出的页面中，输入命令<code>npm install add-asset-html-webpack-plugin --save</code>这个插件的作用就是往<code>html</code>页面中去增加静态资源。然后在<code>webpack.config.js</code>中进行配置：这样页面就会将我们打包输出的第三方模块的<code>vender.dll.js</code>进行挂载；</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }) 
    ]
.......
}
</code></pre>
<p>接下来我们就要实现引入第三方模块的时候，通过我们上一步打包输出的文件进行引入，首先我们需要进行分析前面打包输出的第三方库文件，将分析结果进行保存，使用<code>DllPlugin</code>进行分析，在<code>webpack.dll.js</code>的配置文件中进行如下配置：<code>name: '[name]',</code>是指要分析的库名，<code>path: path.resolve(__dirname, '../dll/[name].manifest.json')</code>代码意思就是将分析的结构放在<code>../dll/[name].manifest.json</code></p>
<pre><code class="language-js">const path = require('path')
const webpack = require('webpack')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['react', 'react-dom', 'lodash']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    },
    plugins: [
        new webpack.DllPlugin({
            name: '[name]',
            path: path.resolve(__dirname, '../dll/[name].manifest.json')
        })
    ]
}
</code></pre>
<p>然后我们做的就是根据我们前面生成的<code>library: '[name]'</code>全局变量的名字，以及分析的文件，在<code>webpack</code>进行配置打包：<br>
在<code>webpack.config.js</code>中使用一个插件：<code>manifest: path.resolve(__dirname, '../dll/vendors.manifest.js')</code>意思就是我们在代码中如果引入了第三方模块。他就会在<code>vendors.manifest.json</code>这个文件中去找对应的第三方模块的映射关系，如果可以找到，他就会知道这个第三方模块不用再次引入了，直接使用<code>vendors.dll.js</code>这个文件就可以了，他会在全局变量中进行使用我们的第三方模块。如果没有映射关系，就会进行将第三方库进行打包。</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/vendors.manifest.json')
        })
    ]
.......
}
</code></pre>
<p>然后我们在<code>package.json</code>里面配置一个命令：<code>&quot;build:dll&quot;: &quot;webpack --config ./build/webpack.dll.js&quot;</code>来执行我们的打包第三方模块的命令。然后进行打包，会发现比之前的打包速度要快很多。<br>
其实我们前面打包第三方库输出额时候可以进行拆分：</p>
<pre><code class="language-js">const path = require('path')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['lodash'],
        react: ['react', 'react-dom']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    }
}
</code></pre>
<p>对应的在<code>webpack.config.js</code>中也需要进行配置：</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }),
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/react.dll.js')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/vendors.manifest.json')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/react.manifest.json')
        })
    ]
.......
}
</code></pre>
<p>如果我们按照上面的，配置很多的话，就特别繁琐，我们可以通过下面的方法进行简单化：</p>
<pre><code class="language-js">const plugins = [
    new CleanWebpackPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new HtmlWebpakcPlugin({
        template: './src/index.html'
    })
]
const fs = require('fs')
const files = fs.readdirSync(path.resolve(__dirname, './dll'))
files.forEach(file =&gt; {
    if(/.*\.dll.js/.test(file)) {
        plugins.push(
          new AddAssetHtmlWebpackPlugin({
              filepath: path.resolve(__dirname, '../dll', file)
          }))
    }
    if(/.*\.manifest.json/.test(file)) {
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll', file)
        })
    }
})

const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: plugins
.......
}
</code></pre>
<h4 id="9-webpack其他打包优化方法">9. Webpack其他打包优化方法</h4>
<ul>
<li>控制包文件大小：在源代码中将用不到的包文件在打包的时候通过<code>Tree Shaking</code>进行去除，或者直接不进行引入；也可以通过<code>splitchunkplugins</code>插件进行包的拆分，提高打包速率。</li>
<li><code>tread-loader, parallel-webpack, happypack</code> 多进程打包。</li>
<li>合理使用<code>sourceMap</code>：不同环境打包，使用最佳的<code>sourceMap</code>方式。</li>
<li>结合<code>stats</code>分析打包结果：根据分析结果进行优化。</li>
<li>开发环境内存编译。</li>
<li>开发环境无用插件剔除：比如开发环境中不需要对代码进行压缩，将<code>mode</code>设置为<code>production</code>。</li>
</ul>
<h4 id="10-多页面打包配置">10. 多页面打包配置</h4>
<p>我们前面所说的都是单页面进行打包，也就是打包之后就生成一个<code>index.html</code>页面。比如说我们有两个页面一个<code>index.js</code>，一个<code>list.js</code>内容分别如下：<br>
<code>index.js</code>:</p>
<pre><code class="language-js">class App extends Component {
  return () {
    return (
        &lt;div&gt;
        index
         &lt;/div&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p><code>list.js</code>:</p>
<pre><code class="language-js">class App extends Component {
  return () {
    return (
        &lt;div&gt;
        list
         &lt;/div&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;list!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p>这是两个不同的页面，我们希望打包之后有两个<code>html</code>页面，一个引入<code>iindex.js</code>打包之后的文件，一个引入<code>list.js</code>打包之后的文件。首先我们需要修改打包的入口文件，将<code>list.js</code>文件进行添加：</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        list: './src/list.js'
    },
</code></pre>
<p>然后修改我们之前配置的打包输出设置的模板<code>html</code>：设置打包输出的<code>html</code>的文件名，并且设置页面引用的包文件。</p>
<pre><code class="language-js">plugins: [
    new CleanWebpackPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new HtmlWebpakcPlugin({
        template: './src/index.html',
        filename: 'index.html',
        chunks: ['runtime', 'vendors', 'main']
    }),
    new HtmlWebpakcPlugin({
        template: './src/index.html',
        filename: 'list.html',
        chunks: ['runtime', 'vendors', 'list']
    })
]
</code></pre>
<p>我们如果有很多页面进行打包，如果重复上面的操作就特别麻烦，所以我们可以进行处理上面的代码：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');
const fs = require('fs')
const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')

const makePlugins = (configs) =&gt; {
    const plugins = [new CleanWebpackPlugin()]
    const files = fs.readdirSync(path.resolve(__dirname, './dll'))
    Object.keys(configs.entry).forEach(item =&gt; [
        plugins.push(new HtmlWebpakcPlugin({
            template: './src/index.html',
            filename: `${item}.html`,
            chunks: ['runtime', 'vendors', item]
        }))
    ]);

    files.forEach(file =&gt; {
        if(/.*\.dll.js/.test(file)) {
            plugins.push(
              new AddAssetHtmlWebpackPlugin({
                  filepath: path.resolve(__dirname, '../dll', file)
              }))
        }
        if(/.*\.manifest.json/.test(file)) {
            new webpack.DllReferencePlugin({
                manifest: path.resolve(__dirname, '../dll', file)
            })
        }
    })
    return plugins;
}

const configs =  {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
        list: './src/list.js'
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    stats: { children: false },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
}
module.exports = configs
configs.plugins = makePlugins(configs)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/es6-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/es6-bi-ji">
        </link>
        <updated>2019-12-06T01:36:57.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-变量">1. 变量</h4>
<ul>
<li><code>var</code>声明的变量是<code>function scope</code>也就是在函数中可以访问到，并不是在大括号里面声明的，外层就访问不到。<code>let const</code>声明的变量都是<code>block scope</code>块级作用域，也就是在大括号里面可以访问到。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-变量">1. 变量</h4>
<ul>
<li><code>var</code>声明的变量是<code>function scope</code>也就是在函数中可以访问到，并不是在大括号里面声明的，外层就访问不到。<code>let const</code>声明的变量都是<code>block scope</code>块级作用域，也就是在大括号里面可以访问到。</li>
</ul>
<!-- more -->
<ul>
<li><code>let</code>和 <code>const</code> 都不允许重复声明。他们两个都不可以在同一个作用域中进行重复声明，比如，在函数中声明的变量跟在函数外声明的同名的变量是不同的。<code>let</code> 定义的变量可以重新赋值，<code>const</code>是不可以的。</li>
<li><code>const</code> 声明的对象，对象是一个引用类型的值，可以进行修改对象的属性。如果想要定义的对象的属性是不可以改变可以使用<code>es5</code>中的<code>Object.freeze()</code>这个方法：<code>const jelly = Object.freeze(person)</code></li>
<li><code>let</code> 跟<code>const</code>都是存在暂时性死区的，也就是说；我们在声明前使用调用变量，会报<code>RefrenceError</code>的错误；而<code>var</code>声明的变量是没有的；这样，我们也可以养成习惯，在使用变量之前，进行声明。</li>
</ul>
<h4 id="2-箭头函数">2. 箭头函数</h4>
<h5 id="21-优点">2.1 优点：</h5>
<ul>
<li>简明语法</li>
<li>可以隐式返回：也就是可以不使用<code>return</code>关键字进行返回；删除<code>{}</code>大括号。</li>
<li>不绑定<code>this</code>：箭头函数没有自己的<code>this</code>值，他的<code>this</code>值是继承他的父级作用域的，<code>this</code>值是定义的时候就绑定了。</li>
<li>箭头函数也是匿名函数，我们可以通过定义变量，等于箭头函数，当进行调用：</li>
</ul>
<pre><code class="language-js">const gree = name =&gt; { alert (`hello ${name}`)}
</code></pre>
<p>一个函数在他独立运行的时候，也就是说他没有作为对象的方法去调用，也没用<code>call</code>、<code>apply</code>等方法进行绑定；这里的数组里面<code>map</code>的回调函数就是一个独立运行的，所以他的<code>this</code>值是在运行的时候动态绑定的，绑定到了<code>window</code>对象上，所以不会获取到<code>name</code>值。</p>
<pre><code class="language-js">const jelly = {
  name: 'jiegiser',
  bobbies: ['sleeping', 'coding', 'reading'],
  print: function () {
    this.hobbies.map(function (hobby) {
      console.log(`${this.name} loves ${hobby}`)
    })
  }

}
</code></pre>
<h5 id="22-箭头函数的局限性">2.2 箭头函数的局限性：</h5>
<ul>
<li>作为构造函数，一个方法需要绑定到对象：下面的代码。<code>Person</code>对象中使用箭头函数，并没有将<code>this</code>绑定到它本身。所以，这里需要使用原始的函数。下面的给原型绑定方法，同样也是，<code>this</code>指向的是父级的<code>this</code>所以指向<code>window</code>对象；</li>
</ul>
<pre><code class="language-js">const Person = (name, points) =&gt; {
  this.name = name;
  this.points = points;
}
const jelly = new Person ('Jelly', 5);
Person.prototype.updatePoints = () =&gt; {
  this.points ++;
  console.count(this.points)
}
</code></pre>
<ul>
<li>当你真的需要this的时候：下面代码的<code>this</code>指向的是调用<code>addEventListener</code>方法的对象；箭头函数的<code>this</code>是不会绑定的，所以这里的也还是<code>window</code>对象。<code>setTimeout</code>里面应该是使用箭头函数，来邦定<code>this</code>值在该作用域。</li>
</ul>
<pre><code class="language-js">const button = document.querySelector('.zoom');
button.addEventListener('click', () =&gt; {
  this.classList.add('in');
  setTimeout(() =&gt; {
    this.classList.remove('in')
  }, 2000);
})
</code></pre>
<ul>
<li>需要使用arguments对象：箭头函数中是没有<code>arguments</code>对象的。</li>
</ul>
<pre><code class="language-js">const sum = () =&gt; {
  return Array.from(arguments).reduce((prevSum, value) =&gt; prevSum + value,0)
}
</code></pre>
<h4 id="3-es6-参数默认值">3. ES6 参数默认值</h4>
<p>我们在函数中可以通过下面的方法进行设置默认参数值：</p>
<pre><code class="language-js">function add (a = 1, b = 5) {
  return a + b;
}
</code></pre>
<p>当我们需要第一个参数使用默认值的时候，这样<code>add(undeffined, 2)</code>这样，如果<code>add(1)</code>这样调用的话，第二个参数使用默认值。</p>
<h4 id="4-模板字符串">4. 模板字符串</h4>
<p><code>es6</code>中的模板字符串是可以嵌套的，以及在<code>${}</code>中可以直接调用方法。<br>
还有一个标签模板字符串：</p>
<pre><code class="language-js">function highLight(string, user, topic) {
  return 'templa'
}
const user = 'jie';
const topic = 'learn es6';
const sentence = highLight`${user} has commented on your topic ${topic}`
</code></pre>
<p>然后我们查看<code>sentence</code>，他就会返回标签模板字符串中返回的东西；<br>
<img src="https://img-blog.csdnimg.cn/20190602110837804.png" alt="在这里插入图片描述"><br>
对应标签模板字符串是有是三个参数的，<code>string, user, topic</code>第一个参数是返回模板字符串中默认内容；返回值是一个数组，如果不是以模板字符串传入的变量开头的，那数组的第一个不死空字符串；如上面代码中，返回的是[&quot; &quot;,<code>has commented on your topic</code>,&quot; &quot;]，然后后面的参数就是模板字符串中传入的变量。我们这里传入的是<code>${user}</code>跟<code>${topic}</code>，但是如果我们传入了很多的参数，这个时候我们可以使用<code>es6</code>的剩余参数：<code>...values</code>他是参数的数组，这样我们就获取到所有的参数。我们可以使用标签模板字符串，来返回我们想要的值。</p>
<pre><code class="language-js">function highLight(string, ...values) {
  debugger;
  return 'templa'
}
</code></pre>
<p>我们可以使用标签模板字符串，去处理我们输入的参数，比如在留言板等功能中，为了防止<code>xss</code>攻击，我们可以通过模板字符串进行过滤用户输入的内容。可以使用第三方的包：<code>DOMPurify</code>进行过滤。</p>
<h4 id="5-对象解构">5. 对象解构</h4>
<p>我们有一个对象如下：</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}
</code></pre>
<p>我们每次访问的时候，需要进行<code>Tom.name</code>这样进行访问，如果属性有很多的话，就比较麻烦，我们可以这样写：这样去访问他的属性</p>
<pre><code class="language-js">
const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { name, age } =Tom
console.log(name)
console.log(age)
</code></pre>
<p>如果我们想要先声明变量，然后进行结构对象，可以如下面这样写：</p>
<pre><code class="language-js">let name = '';
({ name, age } = Tom);
</code></pre>
<p>对象解构也可以进行嵌套，如上面的代码，我们想要访问<code>family</code>属性，我们可以这样写：</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father, mother } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>我们在解构的时候也可以进行重新命名，类似<code>sql</code>中的<code>as</code>；可以这样写：<code>father: f</code>这样，将<code>father</code>属性赋值给<code>f</code>变量。</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father: f, mother } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>我们在对象解构的时候，也可以给解构后的变量赋予默认值，如果被解构的对象没有该属性为<code>undefined</code>，就使用我们的默认值，如下代码：<code>sister = 'haove no sister'</code>这样。</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father: f, mother, sister = 'haove no sister' } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>如下面代码，经常会在封装一些插件中，会使用默认值：<br>
<img src="https://img-blog.csdnimg.cn/20190602141028611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="6-数组解构">6. 数组解构</h4>
<p>数组的解构基本跟对象的解构类似：下面代码是解构了数组的第一项，跟第二项</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, two] = number;
console.log(one, two)
</code></pre>
<p>如果我们想回去第一个跟第三个：需要添加一个逗号进行分隔，流出第二个位置。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, , two] = number;
console.log(one, two)
</code></pre>
<p>如果想要获取到第一个值，跟后面所有的值，我们可以使用扩展运算符，将剩余项组成一个数组：</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, ...other] = number;
console.log(one, other)
</code></pre>
<p><code>rest</code>参数只能使最后一个，也就是说解析后面所有的，不能解析某一部分：<code>const [one, ...other, four] = number;</code>这样就会报错。</p>
<p>数组的结构也可以进行赋予默认值：同样相应的值为<code>undefined</code>的时候，才会使用默认的值。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three'];
const [one, two, three = 'three'] = number;
</code></pre>
<p>数组的解构的使用技巧可以用在交换两个变量的值：</p>
<pre><code class="language-js">let a = 10;
let b = 20;
[a,b] = [b,a];
</code></pre>
<h4 id="7-for-of-用法">7. for of 用法</h4>
<p><code>forEach</code>循环不能终止循环，<code>for in</code>循环，循环的是<code>index</code>值，遍历的是变量的可枚举属性。即使是原型的属性也会进行循环出来。使用<code>for of</code>是循环的属性值：在循环中，也可以使用<code>break</code>进行中断循环。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];

for (item of number) {
  console.log(item)
}
</code></pre>
<p><code>for of</code>循环还可以用于遍历数组的遍历器属性：</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];

for ( let [index, fruit] of number.entries()){
  console.log(index, number)
}
</code></pre>
<p><code>for of</code>不支持对象的循环。可以应用于字符串：</p>
<pre><code class="language-js">const number = 'sddsdsd;

for ( let code of number){
  console.log(code)
}
</code></pre>
<p><code>for of</code>循环还可以用于<code>nodeList</code>进行循环：</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
for ( let li of lis) {
  li.addEventListener('click', function () {
    //执行方法
  })
}
</code></pre>
<h4 id="8-arrayfrom-arrayof">8. Array.from()  Array.of()</h4>
<h5 id="81-arrayfrom">8.1 Array.from()</h5>
<p>这两个方法并不是数组原型的方法，我们需要通过<code>Array.from() Array.of()</code>这种去调用，而不是声明一个数组点上这个方法。<code>Array.from()</code>方法是将一个类素组对象转换为数组对象。类素组对象也就是拥有<code>length</code>属性的对象，<code>modeList</code>就是一个类数组对象。</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
const lisArr = Array.form(lis)
const names = lisArray.map(li =&gt; li.textContent)
</code></pre>
<p><code>Array.from()</code>方法有两个参数，第一个参数是需要准换的类数组，第二个参数类似数组的<code>map</code>方法，会给转化后的数组中的每一项执行该方法，于是，上面的代码可以简写为下面：</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
const names = Array.form(lis， li =&gt; li.textContent)
</code></pre>
<p>也可以利用<code>Array.from()</code>方法进行转换函数中的<code>arguments</code>属性进行转化。<br>
我们也可以利用<code>Array.from()</code>方法将字符串也能转换为一个数组。</p>
<pre><code class="language-js">const number = 'sddsdsd;
console.log(Array.from(number))
</code></pre>
<h5 id="82-arrayof">8.2 Array.of()</h5>
<p><code>Array.of()</code>方法就是根据传入的参数，返回一个由传入的参数组成的数组；</p>
<h4 id="9-数组的其他方法">9. 数组的其他方法</h4>
<h5 id="91-find">9.1 .find()</h5>
<p>查找是否有<code>bananas</code>这个选项；返回的是找到的该选项，以对象返回；</p>
<pre><code class="language-js">const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5},
]
const bananas = inventory.find(fruit =&gt; {
  if (fruit.name === 'bananas') {
    return true
  }
  return false
})
</code></pre>
<h5 id="92-findindex">9.2 .findIndex()</h5>
<p><code>findIndex()</code>返回的是要查找的选项的索引值：</p>
<pre><code class="language-js">const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5},
]
const bananas = inventory.findIndex(fruit =&gt; fruit.name === 'bananas');//返回的是索引值1
</code></pre>
<h5 id="93-some">9.3 .some()</h5>
<p>返回的布尔值；如果有一部分满足测试函数，就返回<code>true</code></p>
<pre><code class="language-js">const isEnough= inventory.some(fruit =&gt; fruit.quantity &gt; 0);//返回true
</code></pre>
<h5 id="94-every">9.4 .every()</h5>
<p>返回的布尔值；如果所有的都满足测试函数，就返回<code>true</code></p>
<pre><code class="language-js">const isAllenough= inventory.every(fruit =&gt; fruit.quantity &gt; 0);//返回false
</code></pre>
<h4 id="10-剩余参数">10. 剩余参数</h4>
<pre><code class="language-js">function sum (...numbers) {
  console.log(numbers)//一个数组[1, 2, 3, 4]
}
sum (1, 2, 3, 4)
</code></pre>
<h4 id="11-扩展运算符">11. 扩展运算符</h4>
<p>我们如果想要两个数组，合并为一个数组，并且，在中间插入一个值，如下我们以前写的代码：</p>
<pre><code class="language-js">const youngers = ['george' , 'john', 'Thomas'];
const olders = ['James', 'Adrew', 'Martin'];

let members = [];
members = members.concat(youngers);
members.push('Mary');
members = members.concat(olders);
</code></pre>
<p>使用<code>es6</code>可以这样写：</p>
<pre><code class="language-js">const youngers = ['george' , 'john', 'Thomas'];
const olders = ['James', 'Adrew', 'Martin'];

let members = [...youngers, 'Mary', ...olders];
</code></pre>
<p>可以通过扩展运算符将一个字符串变为以每一个字符变为数组中的一项：</p>
<pre><code class="language-js">[...'jiegiser']
//[&quot;j&quot;, &quot;i&quot;, &quot;e&quot;, &quot;g&quot;, &quot;i&quot;, &quot;s&quot;, &quot;e&quot;, &quot;r&quot;]
</code></pre>
<p>可以借助扩展运算符，放置我们将数组赋值给另一个数组，修改另一个数组中的数据，会将源数组的值进行改变：</p>
<pre><code class="language-js">const currentMembers = [...numbers];
</code></pre>
<p>我们可以使用扩展运算符将可遍历对象扩展到一个新的数组中：</p>
<pre><code class="language-js">const todos = [...document.querySelectorAll('li')]
</code></pre>
<p>比如我们需要删除一个数组中，对象属性<code>id</code>为2的一项；代码如下：</p>
<pre><code class="language-js">const todos = [
  {id: 1, name: 'Go to store', completed: false},
  {id: 2, name: 'Wacth TV', completed: true},
  {id: 3, name: 'Go Shopping', completed: false},
]
// 要删除的项的id为2
const id = 2;
const todoIndex = todos.findIndex(todo =&gt; todo.id === id)

const newTodos = [...todos.slice(0, todoIndex), ...todos.slice(todoIndex + 1)];
</code></pre>
<p>我们还可以将一个数组通过扩展运算符，追加到另一个数组后：</p>
<pre><code class="language-js">const fruit = ['apple', 'bananas', 'pear'];
const newFruit = ['orange', 'mongo'];
fruit.push(...newFruit)
</code></pre>
<p>还可以利用扩展运算符，将数组扩展为函数的参数：</p>
<pre><code class="language-js">const dateField = [2019, 6, 2];
const data = new Date(...dateField)
console.log(data);
</code></pre>
<h4 id="12-对象的计算属性">12. 对象的计算属性</h4>
<p>假如我们需要定义一个对象：我们希望我们的<code>'user -1': 1</code>这个数组是每次加一，然后进行定义变量。</p>
<pre><code class="language-js">const userIds = {
  'user -1': 1
  'user-2': 2
}
</code></pre>
<p>我们可以这样写：</p>
<pre><code class="language-js">let id = 0
const userIds = {
  [`user-${++id}`]: id,
  [`user-${++id}`]: id,
  [`user-${++id}`]: id,
}
</code></pre>
<p>如果我们想要定义一个对象，对象的键是一个数组，对应的每一个值是一个数组，我们可以这样写：</p>
<pre><code class="language-js">const keys = ['name', 'age', 'birthday'];
const values = ['jiegiser', 18, '0501'];
const jiegiser = {
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
}
</code></pre>
<h4 id="13-es6-的promise对象">13. ES6  的Promise对象</h4>
<p>如下代码，<code>then</code>里面是执行<code>ajax</code>执行成功之后的回调函数，<code>catch</code>是如果请求出现异常，执行的方法。这里是返回一个<code>promise</code>对象，所以可以继续在外层使用<code>.then()</code>方法。<code>return axios.get(</code>https://api.github.com/users/${username}/repos<code>);</code></p>
<pre><code class="language-js">let username;
const usersPromise = axios.get('https://api.github.com/users');

usersPromise
  .then(response =&gt; {
    username = response.data[0].login;
    return axios.get(`https://api.github.com/users/${username}/repos`);
  })
  .then(response =&gt; {
    console.log(response.data)
  })
  .catch(err =&gt; {
    console.log(err)
  })
</code></pre>
<p>一个<code>promise</code>对象的实例：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  //请求成功执行
  resolve('success');
  // 请求失败的执行
  reject(Error('error'))
})
//请求成功执行的回调
p.then(data =&gt; {
  console.log(data)
})
// 请求失败的执行的回调
  .catch(err =&gt; {console.log(err)})
</code></pre>
<p>如果我们的页面中有多个<code>Promise</code>对象，这些对象之间执行的顺序时不相关的，互不影响的，我们可以使用下面的方法，处理这些<code>Promise</code>对象返回的结果：这里需要注意的是，<code>.all()</code>方法返回的结果是对应的执行<code>Promise</code>对象的结果，返回的是一个数组，我们可以使用对象解构，去得到不同的请求返回的结果。只有当<code>.all()</code>方法里面的<code>Promise</code>对象全部返回的是<code>resolve</code>的时候，才会执行<code>.then()</code>方法。否则执行<code>.catch()</code></p>
<pre><code class="language-js">Promise
  .all([userPromise, movePromise])
  .then(response =&gt; {
    const [users, movice] = response;
    console.log(users);
    console.log(movice);
  })
  .catch(err =&gt; {
    console.log(err)
  })
</code></pre>
<p>与<code>.all()</code>方法相对的是一个·<code>Promise.race()</code>方法，他同样也是处理多个<code>Promise</code>实例，但是，他是处理的<code>Promise</code>实例中，只要第一个<code>Promise</code>实例是执行<code>resolve</code>也就是回调成功，就会去执行<code>.then()</code>方法。否则执行<code>.catch()</code></p>
<h4 id="14-symbol">14. Symbol</h4>
<p><code>symbol</code>是生成一个唯一的标识符，如下代码：</p>
<pre><code class="language-js">const one = Symbol('one')
const two = Symbol('two')

console.log(one === two)//false
</code></pre>
<p>我们可以使用<code>symbol</code>来给 对象定义一个相同属性名，但是值不同：</p>
<pre><code class="language-js">const classRoom = {
  [Symbol('lily')]: {grade: 60, gender: 'female'},
  [Symbol('nina')]: {grade: 80, gender: 'female'},
  [Symbol('nina')]: {grade: 90, gender: 'female'},
}
</code></pre>
<blockquote>
<p><code>symbol</code>类型的值是不能遍历的，如上面的属性，是不能通过<code>for in</code>等进行遍历的。可以使用<code>Object.getOwnPropertySymbols(classRoom)</code>进行遍历,获取到属性名。获取属性值：classrom[Symbol(lily)]这样进行获取，不能通过.的方法进行获取。前面定义<code>symbol</code>属性的时候，是需要使用计算属性的方式进行定义。</p>
</blockquote>
<pre><code class="language-js">const classRoom = {
  [Symbol('lily')]: {grade: 60, gender: 'female'},
  [Symbol('nina')]: {grade: 80, gender: 'female'},
  [Symbol('nina')]: {grade: 90, gender: 'female'},
}
Object.getOwnPropertySymbols(classRoom)
</code></pre>
<h4 id="15-eslint">15. ESLint</h4>
<p>输入命令：<code>npm install eslint -D</code>进行本地安装，然后输入命令进行初始化<code>eslint</code>的配置：<code>eslint --init</code>然后根据自己的需要进行配置，<br>
<img src="https://img-blog.csdnimg.cn/20190604202606357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
输入<code>eslint init.js</code>进行检测我们的文件的书写规范。<br>
<img src="https://img-blog.csdnimg.cn/20190604202851194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以输入后面的报错信息到<code>https://eslint.cn/docs/rules/</code>这里进行查看。<br>
我们可以查看前面生成的<code>eslint</code>的规则配置：可以看到我们的规则是继承了<code>&quot;extends&quot;: &quot;eslint:recommended&quot;,</code>也就是<code>https://eslint.cn/docs/rules/</code>这里面标绿色箭头的选项，我们可以在我们的<code>rules</code>里面进行配置我们自己的规则。</p>
<pre><code class="language-js">module.exports = {
    &quot;env&quot;: {
        &quot;browser&quot;: true,
        &quot;commonjs&quot;: true,
        &quot;es6&quot;: true
    },
    &quot;extends&quot;: &quot;eslint:recommended&quot;,
    &quot;parserOptions&quot;: {
        &quot;ecmaVersion&quot;: 2015,
        &quot;sourceType&quot;: &quot;module&quot;
    },
    &quot;rules&quot;: {
        &quot;indent&quot;: [
            &quot;error&quot;,
            4
        ],
        &quot;linebreak-style&quot;: [
            &quot;error&quot;,
            &quot;windows&quot;
        ],
        &quot;quotes&quot;: [
            &quot;error&quot;,
            &quot;single&quot;
        ],
        &quot;semi&quot;: [
            &quot;error&quot;,
            &quot;always&quot;
        ]
    }
};
</code></pre>
<p>禁用<code>eslint</code>，比如说我们写<code>vue</code>的时候，是引入了<code>vue</code>，这个时候<code>eslint</code>会提示，，没有定义<code>vue</code>，我们可以在代码顶部加一个:</p>
<pre><code class="language-js">/*global Vue*/   //把某一个变量当做全局对象使用
</code></pre>
<p>如果想要禁用一个规则，如下：</p>
<pre><code class="language-js"> /*eslint-disable no-new*/   //禁用 no-new 规则
</code></pre>
<p>我们也可以在某一行，重新打开我们禁用的规则：</p>
<pre><code class="language-js"> /*eslint-enable no-new*/   //打开 no-new 规则，关闭禁用no-new
</code></pre>
<p>还有检查<code>html</code>中的<code>js</code>书写，安装<code>eslint-plugin-html</code>插件</p>
<h4 id="16-import-export">16. import  export</h4>
<p>默认导出：一个模块只能有一个默认导出；</p>
<pre><code class="language-js"> const apikey = 'abc123';

 export default apikey;
</code></pre>
<p>默认导出的引入方式：</p>
<pre><code class="language-js">import api from './config.js'
console.log(api)
</code></pre>
<p>命名导出：这里的<code>apikey</code>就是导出的名字，</p>
<pre><code class="language-js">export const apikey = 'abc123';
</code></pre>
<p>引入的时候，必须使用同样的名字，而且，需要使用<code>{}</code>来包裹起来：</p>
<pre><code class="language-js">import { apikey } from './config'
</code></pre>
<p>可以引入多个：</p>
<pre><code class="language-js">import { apikey,a } from './config'
</code></pre>
<p>可以用下面的方式导出多个：</p>
<pre><code class="language-js">export { apikey, age, greet }
</code></pre>
<p>也可以在导出的时候，进行重命名：然后引入的时候，必须使用<code>as</code>命名后的名字；</p>
<pre><code class="language-js">export { apikey as apk, age, greet }
</code></pre>
<p>当然，也可以在引入的时候重新命名：在模块使用的时候，就必须使用重命名的名字；</p>
<pre><code class="language-js">import { apikey as apk, a } from './config'
</code></pre>
<blockquote>
<p>默认导出的，吗唉导入的时候，可以使用任意的命名，而命名导出，需要使用我们导出的名字，在导入的时候，进行导入。<br>
一个第三方包：<code>slug</code>,过滤用户名。还有<code>md5</code>包。</p>
</blockquote>
<p>引入命名导出以及默认导出的变量：<code>User</code>默认导出的内容。</p>
<pre><code class="language-js">import User, { apikey as apk, a } from './config'
</code></pre>
<h4 id="17-使用-systemjs-进行打包">17. 使用 SystemJS 进行打包</h4>
<p>一个非常简单的打包工具，不用进行类似<code>webpack</code>繁琐的配置。我们可以使用<code>jspm.io</code>进行加载<code>npm</code> 或者<code>github</code>上面的包。在标签中引入<code>systemJS</code>，然后进行配置：</p>
<pre><code class="language-js">&lt;script&gt;
System.config({transpiler: 'babel'})

System.import('./main.js')
&lt;/script&gt;
</code></pre>
<p>在<code>js</code>中引入第三方模块的方式也是不一样的，如下：意思就是在<code>npm</code>里面查找我们引入的包，进行引入。</p>
<pre><code class="language-js">import { sum } from 'npm:lodash';
</code></pre>
<p>引入本地模块跟前面是一样的。</p>
<h4 id="18-class">18. Class</h4>
<h5 id="181-class基本用法">18.1 Class基本用法</h5>
<p>是特殊的函数，定义方式：</p>
<pre><code class="language-js">//第一种
class User {

}
//第二种
const User = class {

}
</code></pre>
<p><code>typeof User</code>打印出的结果是<code>function</code>，函数是有函数提升的，而类是没有的。在声明之前使用，会报错。</p>
<blockquote>
<p>这里需要注意的是，类里面定义函数，之间是不需要使用逗号隔开的，加了逗号会报错；</p>
</blockquote>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`)
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<p>静态方法的定义：静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法</p>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`)
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`)
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<p>定义<code>get set</code>方法：</p>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`);
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`);
    }

    set github (value) {
        this.githubName = value;
    }
    get github () {
        return `http://github.com/${this.githubName}`;
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<h5 id="182-class的扩展">18.2 Class的扩展</h5>
<p>在类的定义中，定义方法的时候，也可以使用计算属性的方式进行定义：</p>
<pre><code class="language-js">let methodName = 'info';
class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    [methodName] () {
        console.log(`I'm ${this.name}`);
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`);
    }

    set github (value) {
        this.githubName = value;
    }
    get github () {
        return `http://github.com/${this.githubName}`;
    }
}
</code></pre>
<p>类必须要使用<code>new</code>关键字进行调用。下面是类的继承：注意<code>super(name);</code>进行调用父类构造函数。</p>
<pre><code class="language-js">class Animal {
    constructor (name) {
        this.name  = name;
        this.belly = [];
    }
    eat (food) {
        this.belly.push(food)
    } 
}
class Dog extends Animal {
    constructor (name, age) {
        //在子类中调用父类构造函数
        super(name);
        this.name = name;
        this.age = age;
    }
    bark () {
        console.log(`Barl bark!`);
        
    }
}
const lucky = new Dog('lucky', 2);
</code></pre>
<h5 id="183-class-进行扩展内建对象">18.3 Class 进行扩展内建对象</h5>
<p>我们可以通过<code>class</code>扩展<code>javascript</code>中的内建对象，比如扩展<code>Array</code>对象：</p>
<pre><code class="language-js">class MyArray extends Array {
    constructor () {
        super();
    }
}

const colors = new MyArray();
colors[0] = 'red';
console.log(colors.length);
colors.length = 0;
console.log(colors[0])
</code></pre>
<p>在子类中其实可以通过<code>this</code>来访问父级<code>Array</code>的一些属性跟方法的。这里就是调用了<code>Array</code>的<code>push</code>方法。</p>
<pre><code class="language-js">class movieCollaction {
    constructor (name, ...items) {
        super(...items)
        this.name = name;
    }
    add (item) {
        this.push(item)
    }
    toRated (limit = 10) {
        return this.sort((a, b) =&gt; (a.scores &gt; b.scores) ? -1 : 1).slice(0, limit);
    }
}
const movies = new movieCollaction('favorite movies',
  { name: 'the croods', scored: 8.7},
  { name: 'the days', scored: 9.6},
  { name: 'the shawshank', scored: 9.4},
  { name: 'the summer', scored: 8.0},
);
</code></pre>
<h4 id="19-proxy">19. Proxy</h4>
<p>帮助我们重写对象上的默认方法。比如下面的的方法：</p>
<pre><code class="language-js">const personn = { name: 'jiegiser', age: 200};
// 第一个参数为要代理的对象，第二个参数就是一个对象，包含重写的方法。也就类似vue计算属性
const personProxy = new Proxy(personn, {
    get(target, key) {
        return target[key].toUpperCase();
    },
    set (target, key, value) {
        if(typeof value === 'string'){
            target[key] = value.trim();
        }
    }
})
personProxy.name = 'jie';
</code></pre>
<p><code>Proxy</code>的一个例子：对电话号码进行格式化输出</p>
<pre><code class="language-js">const phonerHandle = {
    set(target, key, value) {
        target[key] = value.match(/[0-9]/g).join('');
    }
    get(target, key) {
        return target[key].replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
    }
}
const pgoneNumber = new Proxy({}, phonerHandle)
</code></pre>
<h4 id="20-set">20. Set</h4>
<p>一种唯一的数组，也就是数组中的数据是唯一的，不会重复，不能通过索引进行获取。使用<code>add</code>添加值，<code>delete</code>删除某个值。检验某个值是否存在<code>has</code>，移除所有的元素<code>.clear()</code>。<code>.values</code>是一个<code>set</code>的一个遍历器。可以使用<code>for of</code>进行循环遍历。</p>
<pre><code class="language-js">const colors = new Set();
colors.add('red')
colors.add('green')
colors.add('blue')
</code></pre>
<p>可以使用下面的的方法，进行遍历：</p>
<pre><code class="language-js">const colors = new Set();
colors.add('red')
colors.add('green')
colors.add('blue')
const iterator = colors.values();
iterator.next();
</code></pre>
<p>使用<code>for of</code></p>
<pre><code class="language-js">for (let color of colors) {
    console.log(color)
}
</code></pre>
<p>使用<code>forEach</code>进行遍历;</p>
<pre><code class="language-js">colors.forEach((item, key, ownSet) =&gt; {
    console.log(item,key,ownSet)
})
</code></pre>
<p><code>set</code>接收的是一个可遍历对象，我们也可以传入一个数组，进行初始化：</p>
<pre><code class="language-js">const fruits = new Set(['apple', 'banana', 'mongo'])
</code></pre>
<p><code>weakSet</code>跟<code>set</code>非常相似，只不过，他存储的项只能是对象，不能存储字符串，而且不能通过<code>for of</code>进行循环，他没有迭代器，也不能使用<code>forEach</code>进行循环。他没有<code>clear()</code>清除全部，他可以自己进行检测进行注销对应的数据。</p>
<h4 id="21-map">21. Map</h4>
<p><code>map</code>跟<code>set</code>非常相似，不同的是，<code>map</code>通过<code>.set('key',value)</code>这种方法进行添加元素，他也相当于一个数组，数组中是一个个对象。对象的键可以是任意数据类型;</p>
<pre><code class="language-js">const people = new Map();
people.set('jelly', 23);
people.set('{}',3)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190608133541629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
获取对应的值：</p>
<pre><code class="language-js">people.get('jellu')//传入键
</code></pre>
<p>获取里面j键值对的数量：</p>
<pre><code class="language-js">people.size()
</code></pre>
<p>删除某个项：</p>
<pre><code class="language-js">people.delete('jelly')
</code></pre>
<p>删除所有元素：</p>
<pre><code class="language-js">people.clear()
</code></pre>
<p>循环遍历元素：<br>
<code>forEach</code>进行循环；</p>
<pre><code class="language-js">people.forEach(function(value, key, map) =&gt; {
  console.log(value, key, map)
})
</code></pre>
<p>使用<code>for of</code>进行循环：</p>
<pre><code class="language-js">for ( let [key,value] of people) {
  console.log(key, value)
}
</code></pre>
<p>初始化参数：</p>
<pre><code class="language-js">const fruits= new Map([['apple',6], ['banans', 5]])
</code></pre>
<p><code>wekMap</code>没有<code>size</code>属性，不能循环；他的<code>key</code>必须是对象；垃圾回收机制，会自动回收。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack底层原理及脚手架工具分析]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-di-ceng-yuan-li-ji-jiao-shou-jia-gong-ju-fen-xi</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-di-ceng-yuan-li-ji-jiao-shou-jia-gong-ju-fen-xi">
        </link>
        <updated>2019-12-06T01:33:10.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-如何编写一个loader">1. 如何编写一个Loader</h4>
<h5 id="11-实现一个简单的loader">1.1 实现一个简单的Loader</h5>
<p>我们开始写一个打包之后的文件，将<code>js</code>代码中<code>jie</code>这个字符串替换为<code>world</code>的一个<code>loader</code>，首先我们新建一个功能，使用<code>npm init</code>，然后进行安装<code>webpack</code>：<code>npm install webpack webpack-cli --save-dev</code>，安装完之后，新建一个文件及<code>src</code>以及<code>loaders</code>，然后分别在对应的文件夹中新建<code>index.js</code>以及<code>replace.loaders.js</code>文件。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-如何编写一个loader">1. 如何编写一个Loader</h4>
<h5 id="11-实现一个简单的loader">1.1 实现一个简单的Loader</h5>
<p>我们开始写一个打包之后的文件，将<code>js</code>代码中<code>jie</code>这个字符串替换为<code>world</code>的一个<code>loader</code>，首先我们新建一个功能，使用<code>npm init</code>，然后进行安装<code>webpack</code>：<code>npm install webpack webpack-cli --save-dev</code>，安装完之后，新建一个文件及<code>src</code>以及<code>loaders</code>，然后分别在对应的文件夹中新建<code>index.js</code>以及<code>replace.loaders.js</code>文件。</p>
<!-- more -->
<p>然后新建<code>webpack</code>的配置文件<code>webpack.config.js</code>，内容如下：在<code>module</code>使用我们的<code>loader</code></p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [path.resolve(__dirname, './loaders/replace.Loader.js')]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>然后<code>replace.loaders.js</code>文件内容：</p>
<pre><code class="language-js">module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    return source.replace('jie', 'world');
}
</code></pre>
<blockquote>
<ul>
<li>这里不能使用箭头函数，是因为在该函数中，要使用this的指向，<code>webpack</code>在调用<code>loader</code>的时候会进行this指向的变更。如果在定义的时候绑定<code>this</code>，会出现问题</li>
</ul>
</blockquote>
<p><code>index.js</code>中的内容很简单：</p>
<pre><code class="language-js">console.log('hello jie');
</code></pre>
<p>就这样，一个简单的<code>loader</code>就制作好了。在<code>package.json</code>里面配置一个命令<code>&quot;build&quot;: &quot;webpack&quot;</code>进行打包；</p>
<h5 id="12-loader-中的参数传递">1.2  Loader 中的参数传递</h5>
<p>有时候我们需要给我们的<code>loader</code>进行传递参数，可以修改 配置文件<code>webpack.config.js</code>：这里配置<code>loader</code>的<code>use</code>属性也是一个对象，<code>loader</code>就是我们配置的地址，<code>opotion</code>就是我们需要传递的参数。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [{
                loader: path.resolve(__dirname, './loaders/replace.Loader.js'),
                options: {
                    name: 'giser'
                }
            }]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>然后在<code>loader</code>中，接收传进来的参数：</p>
<pre><code class="language-js">module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    console.log(this.query);
    return source.replace('jie', 'world');
}
</code></pre>
<p>可以在官网查看很多<code>API</code>的用法：https://webpack.js.org/api/loaders/ ，在获取传进来的参数的时候，我们可以使用官方推荐的一个<code>loader-utils</code>的模块进行获取参数，输入命令<code>npm install loader-utils --save-dev</code>，然后在我们的<code>loader</code>中进行获取参数：使用<code>getOptions(this)</code>进行获取所有的参数。</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    return source.replace('jie', this.query.name);
}
</code></pre>
<h5 id="13-loader-中多个参数的返回">1.3 Loader 中多个参数的返回</h5>
<p>有时候我们想在我们的<code>loader</code>中，返回很多参数，而现在的只是返回了我们处理后的源代码，<code>this.callback</code>这个函数，可以帮助我们返回更多参数：</p>
<pre><code class="language-js">this.callback(
  err: Error | null,
  content: string | Buffer,
  sourceMap?: SourceMap,
  meta?: any
);
</code></pre>
<p>我们在我们的<code>loader</code>中修改如下：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    // return source.replace('jie', this.query.name);
    const result = source.replace('jie', this.query.name);
    // 第一个参数为错误信息，第二个参数为要返回的内容，第三个参数为sourceMap，第四个参数为返回的其他信息
    this.callback(null, result, source, meta)
}
</code></pre>
<p>而我们现在的代码中没有<code>sourcemap</code>我们可以修改为：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    // return source.replace('jie', this.query.name);
    const result = source.replace('jie', this.query.name);
    // 第一个参数为错误信息，第二个参数为要返回的内容，第三个参数为sourceMap，第四个参数为返回的其他信息
    this.callback(null, result)
}
</code></pre>
<h5 id="14-loader-中处理异步请求">1.4 Loader 中处理异步请求</h5>
<p>有时候我们需要在<code>loader</code>中处理一些异步请求数据，下面我们用<code>setTimeout</code>来模拟异步数据会获取：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

module.exports = function(source) {
    console.log(source)
    const options = loaderUtils.getOptions(this)
    const callback = this.async();
    setTimeout(() =&gt; {
        const result = source.replace('jie', this.query.name);
        callback(null, result)
    }, 1000);
}
</code></pre>
<p>首先我们声明一个异步操作的函数<code>const callback = this.async();</code>，然后在里面使用该函数，这里需要注意的是<code>this.async</code>异步函数返回的结果也是调用了<code>this.callback</code>这个函数，所以我们第一个参数如果没有错误信息就传递一个<code>null</code>，该参数是必须要传递的。这样就实现了在<code>loader</code>中处理异步请求。</p>
<blockquote>
<ul>
<li>this.async<br>
Tells the loader-runner that the loader intends to call back asynchronously. Returns this.callback.</li>
</ul>
</blockquote>
<h5 id="15-多个-loader-的使用">1.5 多个 Loader 的使用</h5>
<p>如果我们有多个<code>loader</code>进行使用，跟之前的一样，直接在<code>use</code>选项里加上我们需要使用的<code>loader</code>：</p>
<pre><code class="language-js">    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: path.resolve(__dirname, './loaders/replace.Loader.js'),
                options: {
                    name: 'giser'
                }
            }, {
                loader: path.resolve(__dirname, './loaders/replaceLoaderAsync.js'),
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
</code></pre>
<p>我们会发现，如果每次都要加一个<code>loader</code>进行使用的话，都需要写一次<code>path.resolve(__dirname, './loaders/replaceLoaderAsync.js'),</code>这种东西，我们希望的是我们加载自己的<code>loader</code>是跟安装其他第三方包一样，只写<code>loader</code>名称就可以，如下：</p>
<pre><code class="language-js">    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: 'replace.Loader',
                options: {
                    name: 'giser'
                }
            }, {
                loader: 'replaceLoaderAsync',
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
</code></pre>
<p>如果这样，我们可以使用一个<code>reaolveLoader</code>：<code>resolveLoader</code>代码意思是，如果我们引用一个<code>loader</code>，他会先去<code>node_modules</code>中去找如果没有，就去<code>loaders</code>的文件夹中去找。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    resolveLoader: {
        modules: ['node_modules', './loaders']
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: 'replace.Loader',
                options: {
                    name: 'giser'
                }
            }, {
                loader: 'replaceLoaderAsync',
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>我们可以使用<code>loader</code>做很多，比如我们一般在代码中加上<code>try{}c atch{}</code>进行捕获异常，但是直接在业务代码中加上这些，会显得代码很乱，而且自己也要加很多这样的语句，很是麻烦，我们可以通过写一个<code>loader</code>，进行帮我们做这些事，在这个<code>loader</code>中，我们进行检测源码，如果有<code>function</code>字符串，就对这个函数添加<code>try{}c atch{}</code>进行捕获异常：</p>
<pre><code class="language-js">try {function () {
}catch(e)}
</code></pre>
<p>还有比如我们有一个网站，会打包输出一个中文版跟英文版本的，我们如果每一个都去修改代码里面标题这些，会很繁琐，我们前面说了，可以在<code>loader</code>中进行传递参数，这样就会获取到全局变量，然后根据这个全局变量进行打包我们的代码，是中文还是英文版本的，我们在元源码中使用一个占位符，进行根据全局变量，来替换这个占位符，从而达到打包输出中文以及英文版本的：<br>
我们的源码：<code>{{title}}</code><br>
然后在<code>loader</code>中：</p>
<pre><code class="language-js">if(Node全局变量 === '中文') {
  source.replace('{{title}}', '中文标题')
} else {
  source.replace('{{title}}', '英文标题')
}
</code></pre>
<p>使用<code>loader</code>可以进行对我们的源代码进行包装。方便我们进行处理一些多而繁琐的操作。</p>
<h4 id="2-如何编写一个-plugin">2. 如何编写一个 Plugin</h4>
<p>首先要知道<code>loader</code>与<code>plugin</code>之间的关系：<code>loader</code>是当我们进行打包我们的文件时，处理不同类型的文件，处理模块。<code>plugiin</code>是在打包的时候具体时刻，进行处理事件，比如我们在每次打包之前清除<code>dist</code>目录下的文件，就会使用<code>clean-webpack-plugin</code>插件进行处理。对于<code>webpack</code>的插件的核心机制或者说设计模式就是事件驱动以及发布模式；他是通过事件来驱动的。首先我们新建一个工程，类似上面的搭建<code>loader</code>的工程，然后新建一个文件夹<code>plugins</code>，里面新建一个<code>copyright-webpack-plugins.js</code>我们的插件，一般来说，插件的命名都是<code>*-webpack-plugin.js</code>这样子的，我们这个插件实现的一个功能就是，给我们每一个页面或者是脚本中添加一个版权的标识，<code>copyright-webpack-plugins.js</code>内容如下：注意这里的插件声明方式，是通过<code>class</code>声明的；</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    constructor () {

    }
    apply (compiler) {

    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>然后在<code>webpack.config.js</code>中使用我们的插件：也正是因为我们前面插件声明是通过<code>class</code>,所以这里需要使用<code>new</code>关键字来进行实例化我们的插件。</p>
<pre><code class="language-js">const path = require('path');

//引入我们的插件
const CopyRightWebpackPlugin = require('./plugins/copyright-webpack-plugin');
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的插件
    plugins: [
        new CopyRightWebpackPlugin()
    ],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
    }
}
</code></pre>
<h5 id="21-插件中接收参数">2.1 插件中接收参数</h5>
<p>我们在实例化插件的时候，可以传入参数：</p>
<pre><code class="language-js">    // 使用我们的插件
    plugins: [
        new CopyRightWebpackPlugin({
            name: 'jie'
        })
    ],
</code></pre>
<p>插件的构造函数中会接收我们的插件：这里的<code>options</code>就是我们传递的参数；</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    constructor (options) {
        console.log(options)
    }
    apply (compiler) {

    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190620080557680.png" alt="在这里插入图片描述"><br>
我们现在想做一个就是在打包完成之后要放到<code>dist</code>文件夹的时候，往<code>dist</code>文件夹中增加一个<code>copyright.txt</code>的文件：这里就需要使用<code>apply</code>方法，这里的参数<code>compiler</code>是一个<code>webpack</code>实例，包含<code>webapck</code>打包过程以及配置文件等等，这里有一个<code>compiler.hooks</code>类似于<code>vue</code>中的一些钩子函数，里面有很多时刻，可以查看官方文档：<code>https://webpack.js.org/api/compiler-hooks/#afteremit</code>里面有很多,我们要实现的方法就是在<code>emit</code>时刻执行，<code>emit</code>时刻也就是在打包完成之后要放到<code>dist</code>文件夹的时候。具体实现代码：</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    // constructor (options) {
    //     console.log(options)
    // }
    apply (compiler) {
        compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (complication, cb) =&gt; {  
            //complication存放这次打包的所有的配置内容，compiler是存放所有的配置内容，
            // 打包内容中有哪些文件是放在complication.assets中的，所以我们只需要在complication.assets中
            // 添加一个对象，塞入我们需要添加的文件。
            complication.assets['copyright.txt'] = {
                // 里面的内容
                source: function() {
                    return 'copyright by jie'
                },
                // 文件大小，字符长度
                size: function() {
                    return 16;
                }
            }
            console.log('1111')
            cb();
        })
    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>前面的时刻都是一步的时刻，也就是他返回的是一个<code>AsyncSeriesHook</code>，同步的时刻跟异步时刻实现的方法是不一样的，比如<code>compole</code>时候，代码如下：</p>
<pre><code class="language-js">        compiler.hooks.compile.tap('CopyrightWebpackPlugin', (complication) =&gt; {
            console.log('111')
        })
</code></pre>
<p>我们有时候想知道<code>complication</code>这个对象里面包含的一些属性，直接通过<code>console.log()</code>的方式在控制台中输出时不太直观的，我们可以配置一个命令<code>&quot;debug&quot;: &quot;node node_modules/webpack/bin/webpack.js&quot;</code>通过<code>node</code>的调试工具来进行查看。其实这个命令跟上面我们配置的直接执行<code>webpack</code>效果是一样的，不过这个通过这种我们可以传递一些<code>node</code>的参数，第一个参数<code>inspect</code>是开启<code>node</code>的调试工具，第二个参数<code>inspect-brk</code> 在运行<code>webpack</code>做调试的时候，在第一行代码就打一个断点，运行命令之后，我们就在网页<code>f12</code>会看到下面的东西：随便一个网页，<br>
<img src="https://img-blog.csdnimg.cn/20190620084549211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
点击这个<code>node</code>的图标按钮之后，会跳转到代码的调试，可以看到有断点:<br>
<img src="https://img-blog.csdnimg.cn/20190620085454571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
或者是我们在代码中在需要调试的位置添加<code>debugger</code>然后进行调试：</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    // constructor (options) {
    //     console.log(options)
    // }
    apply (compiler) {
        compiler.hooks.compile.tap('CopyrightWebpackPlugin', (complication) =&gt; {
            console.log('111')
        })
        compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (complication, cb) =&gt; {  
            //complication存放这次打包的所有的配置内容，compiler是存放所有的配置内容，
            // 打包内容中有哪些文件是放在complication.assets中的，所以我们只需要在complication.assets中
            // 添加一个对象，塞入我们需要添加的文件。
            debugger;
            complication.assets['copyright.txt'] = {
                // 里面的内容
                source: function() {
                    return 'copyright by jie'
                },
                // 文件大小，字符长度
                size: function() {
                    return 16;
                }
            }
            console.log('1111')
            cb();
        })
    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>以及我们可以在调试工具的<code>Watch</code>里监听我们需要的监听的对象：<br>
<img src="https://img-blog.csdnimg.cn/2019062008594825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-bundler-源码编写-模块分析">3.  Bundler 源码编写 （模块分析）</h4>
<p>我们实现一个类似于<code>webpack</code>这样的打包工具，来逐渐分析<code>webpack</code>实现打包的原理。首先新建一个<code>bundle</code>文件夹，里面跟上面一样先初始化项目，然后新建<code>dist</code>目录，目录结构如下：<br>
<img src="https://img-blog.csdnimg.cn/20190621075825727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
对应的几个<code>js</code>文件内容也特别简单：<br>
<code>index.js</code>:</p>
<pre><code class="language-js">import message from './message.js';
console.log(message);
</code></pre>
<p><code>message.js</code>:</p>
<pre><code class="language-js">// 后缀.js要写，我们的工具不支持后缀的缩写
import { word } from './word.js';
const message = `say ${word}`;

export default message;
</code></pre>
<p><code>word.js</code>:</p>
<pre><code class="language-js">export const word = 'hello';
</code></pre>
<p>就这样，可以看到我们的项目中，有<code>es6</code>中的<code>import</code>这些语法，直接运行在浏览器，肯定是不可以的，所以我们现在做的就是，写一个类似一些打包工具，进行将我们的代码处理成可以被浏览器识别的代码。在根目录新建一个<code>bundler.js</code>：我们要做的是首先读取入口文件，然后分析入口文件的代码，</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs')

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser')

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    console.log(parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    }));
    console.log(content)
}

moduleAnalyser('./src/index.js')

</code></pre>
<blockquote>
<p>可以安装一个工具<code>npm install cli-highlight -g</code> 用于控制台输出代码高亮。运行时输入命令<code>node bundler.js | highlight</code></p>
</blockquote>
<p>安装一个插件<code>npm install @babel/parser --save</code>用来帮助我们分析读取到的源代码。可以打开官网，查看具体的例子：<code>https://babeljs.io/docs/en/babel-parser</code>,我们查看上面代码打印的内容，输入<code>node bundler.js | highlight</code>，打印结果如下：<br>
<img src="https://img-blog.csdnimg.cn/20190621082531621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
其实这是一个抽象语法树的表述方式，我们可以打印一下该对象的<code>program.body</code>，如下：</p>
<pre><code class="language-js">[ Node {
//第一个节点是import语法声明
    type: 'ImportDeclaration',
    start: 0,
    end: 35,
    loc: SourceLocation { start: [Position], end: [Position] },
    specifiers: [ [Node] ],
    source:
     Node {
       type: 'StringLiteral',
       start: 20,
       end: 34,
       loc: [SourceLocation],
       extra: [Object],
       value: './message.js' } },
  Node {
  //一个表达式的语句，
    type: 'ExpressionStatement',
    start: 37,
    end: 58,
    loc: SourceLocation { start: [Position], end: [Position] },
    expression:
     Node {
       type: 'CallExpression',
       start: 37,
       end: 57,
       loc: [SourceLocation],
       callee: [Node],
       arguments: [Array] } } ]
</code></pre>
<p>可以看到分析的抽象语法树，很好的将我们的<code>js</code>代码转换成了<code>js</code>对象。我们现在需要的是拿到我们代码中所有的依赖关系，也就是读取到<code>import</code>的节点，然后去分析里面的内容，可以去循环这个对象的<code>program.body</code>然后找到<code>type = 'ImportDeclaration'</code>,但是是有点麻烦，我们可以借助一个工具，输入命令安装：<code>npm install --save @babel/traverse</code>，然后我们使用，代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容，因为默认导出是export module
const traverse =  require('@babel/traverse').default; 


//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件
    const dependencies = []

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            console.log(node)
        }
    })
}

moduleAnalyser('./src/index.js')
</code></pre>
<p>存放依赖的文件,查看打印的内容，我们可以看到<code>source</code>中的<code>value</code>存放着依赖的文件的地址<br>
<img src="https://img-blog.csdnimg.cn/20190621085109520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
然后我们将节点中的<code>node.source.value</code>值存放到依赖的文件，也就是<code>dependencies</code>变量中：我们可以看到我们获取的地址是一个相对路径，相对于<code>src</code>目录的，真正做打包的时候，我们希望我们获取的地址是一个相对路径，或者是相对于根目录的路径，我们可以利用<code>nodeJS</code>中的<code>path</code>模块，来解决这个问题，</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+path.join(dirname, node.source.value);
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    })
    return {
        filename,
        dependencies
    }
}

moduleAnalyser('./src/index.js')

</code></pre>
<p>我们这个时候只是分析了代码中的<code>import</code>的引入方式，我们要做的是把原始的代码打包编译之后能在浏览器上运行，所以我们需要借助一个工具：<code>npm install @babel/core --save</code>对代码进行转换，他是<code>babel</code>的一个核心模块，可以利用<code>babel.transformFromAst</code>函数将抽象语法树转换为可以运行的代码，我们还利用<code>babel/preset-env</code>来将<code>es6</code>语法转换为<code>es5</code>的语法：<code>npm install @babel/preset-env --save</code>进行安装，实现代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+path.join(dirname, node.source.value);
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}

const moduleInfo = moduleAnalyser('./src/index.js');
console.log(moduleInfo)

</code></pre>
<p>上面的代码是将我们的入口文件进行了分析，并转换成了可以在浏览器上运行的代码，接下来我们要实现将入口文件依赖的文件也进行分析，并转换为在浏览器上可以运行的代码，代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+ path.join(dirname, node.source.value).replace('\\', '/');
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}
// 依赖图谱，存储所有模块的依赖信息,entry是入口文件，我们要分析整个项目所有的文件；
const makeDependenciesGraph = (entry) =&gt; {
    const entryModule = moduleAnalyser(entry);
    // 利用队列的方法，循环递归获取模块中的依赖文件进行分析
    const graphArry = [entryModule];
    for(let i = 0; i &lt; graphArry.length; i++) {
        const item = graphArry[i];
        const { dependencies } = item;
        if (dependencies) {
            // for in 循环对象
            for(let j in dependencies) {
                graphArry.push(
                    moduleAnalyser(dependencies[j])
                );
            }
        }
    }
    // 将数组进行转换为对象
    const graph = {};
    graphArry.forEach(item =&gt; {
        graph[item.filename] = {
            dependencies: item.dependencies,
            code: item.code
        }
    })
    return graph;
}
const graphInfo = makeDependenciesGraph('./src/index.js');
console.log(graphInfo);
</code></pre>
<p>上面的代码是获取到了整个项目中代码的依赖以及依赖的分析结果，接下来，我们要实现的是将这些分析结果变成真正能够在浏览器上运行的代码：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+ path.join(dirname, node.source.value).replace('\\', '/');
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}
// 依赖图谱，存储所有模块的依赖信息,entry是入口文件，我们要分析整个项目所有的文件；
const makeDependenciesGraph = (entry) =&gt; {
    const entryModule = moduleAnalyser(entry);
    // 利用队列的方法，循环递归获取模块中的依赖文件进行分析
    const graphArry = [entryModule];
    for(let i = 0; i &lt; graphArry.length; i++) {
        const item = graphArry[i];
        const { dependencies } = item;
        if (dependencies) {
            // for in 循环对象
            for(let j in dependencies) {
                graphArry.push(
                    moduleAnalyser(dependencies[j])
                );
            }
        }
    }
    // 将数组进行转换为对象
    const graph = {};
    graphArry.forEach(item =&gt; {
        graph[item.filename] = {
            dependencies: item.dependencies,
            code: item.code
        }
    })
    return graph;
}

const generateCode = (entry) =&gt; {
    //const graph = makeDependenciesGraph(entry);
    const graph = JSON.stringify(makeDependenciesGraph(entry));
    // 这里使用闭包的形式，是为了防止执我们的代码污染到全局。
    return `
      (function(graph){
          //构造require以及exports函数
          function require(module) {
              function localRequire(relativePath) {
                  return require(graph[module].dependencies[relativePath])
              }
              var exports = {};
              (function(require, exports, code){
                //执行代码  
                eval(code)
              })(localRequire, exports, graph[module].code)
              return exports;
          };
          require('${entry}')
      })(${graph});
    `;
}
const code = generateCode('./src/index.js');
console.log(code)

</code></pre>
<h4 id="4-通过-createreactapp-深入学习-webpack-配置">4. 通过 CreateReactApp 深入学习 Webpack 配置</h4>
<p>使用命令<code>npx create-react-app my-app</code> 创建一个<code>react</code>项目，我们可以运行命令<code>npm run eject</code>暴露项目配置，就可以看到有关<code>webpack</code>的配置信息，有可能你会出现下面的错误：</p>
<pre><code class="language-js">Remove untracked files, stash or commit any changes, and try again.
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! my-app@0.1.0 eject: `react-scripts eject`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the my-app@0.1.0 eject script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\Dell\AppData\Roaming\npm-cache\_logs\2019-06-22T06_24_24_879Z-debug.log
</code></pre>
<p>这个是<code>git</code>配置的问题，是因为我们使用脚手架创建一个项目的时候，自动给我们增加了一个<code>.gitignore</code>文件，而我们本地却没有文件仓库，我们只需要将我们的项目添加到我们本地的仓库，输入下面命令：</p>
<pre><code class="language-js">git add .
git commit -m &quot;create app&quot;
npm run eject
</code></pre>
<p>就可以了。我们可以看到项目中会多出现几个文件夹，查看<code>Script</code> 中的<code>build.js</code>文件，里面就是打包流程的逻辑代码，主要的配置文件是在<code>config</code>文件夹中的<code>webpack.config.js</code>中。<code>path.js</code>中主要是存储整个项目的一些路径信息，<code>env.js</code>初始化项目运行环境的文件。<code>webpackDevServer.config.js</code>文件。具体查看配置源码，进行深入。</p>
<h4 id="5-vue-cli-30">5. Vue cli 3.0</h4>
<p><code>vue</code>的脚手架工具，并没有像<code>react</code>的一样可以通过命令暴露项目配置，他也是有一套默认的配置，如果想要修改默认配置，需要添加一个<code>vue.config.js</code>的配置文件，然后安装官网给出的配置参数进行配置，那些配置参数都是<code>vue-cli</code>通过封装了的参数。查看一些配置参数：https://cli.vuejs.org/zh/config/#css-loaderoptions，我们可能会想，<code>vue</code>是如何将自己的配置转换成了<code>webpack</code>的配置文件，可以在<code>node_module</code>中找到<code>@vue</code>中的<code>vli-service</code>中<code>lib</code>的<code>service.js</code>文件，这个文件就是打包的时候进行转换的。</p>
<p>对于<code>webpack</code>配置的学习可以查看官网，一般基础的配置可以查看<code>guides</code>中的内容，如果要查看深入的配置可以看看<code>configuration</code>里面的内容，如果想要写一些<code>loader</code>或者是<code>plugin</code>可以查看<code>api</code>相关的内容。</p>
<p>在<code>vue-cli</code>中，访问项目中的静态资源文件，必须要通过<code>require()</code>函数进行加载，我们可以修改<code>webpack</code>配置，增加如下配置：这样<code>static</code>目录中的文件在外部也可以进行访问了，告诉服务器从哪里提供内容。只有在您想要提供静态文件时才需要这样做。</p>
<pre><code class="language-js">const path = require('path');

module.exports = {
	devServer: {
		contentBase: [path.resolve(__dirname, 'static')],
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法]]></title>
        <id>https://jiegiser.github.io/newBlog/post/suan-fa</id>
        <link href="https://jiegiser.github.io/newBlog/post/suan-fa">
        </link>
        <updated>2019-12-06T00:54:38.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-动态规划算法">1. 动态规划算法：</h4>
<p>题目：<br>
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-动态规划算法">1. 动态规划算法：</h4>
<p>题目：<br>
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。</p>
<!-- more -->
<p>'?' 可以匹配任何单个字符。<br>
'*' 可以匹配任意字符串（包括空字符串）。<br>
两个字符串完全匹配才算匹配成功。<br>
说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/wildcard-matching</p>
<pre><code class="language-js">var isMatch = function(s, p) {
  let cur = new Array(s.length + 1).fill(false)
  cur[0] = true
  
  for (const c of p) {
    if (c == '*'){
      let begin = cur.indexOf(true)
      if (begin == -1) {
        return false
      }
      cur.fill(true, begin)
    } else {
      for(let j = s.length;j &gt; 0; --j){
        cur[j] = (c == '?' || c == s[j-1]) &amp;&amp; cur[j-1]
      }
      cur[0] = false
    }

  }
  return cur[s.length]

};
</code></pre>
<h4 id="2-两数相加">2. 两数相加</h4>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<pre><code class="language-js">给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p>解答：</p>
<pre><code class="language-js">// 第一种
var twoSum = function(nums, target) {
    let re = []
    for (let i = 0;i&lt;nums.length;i++){
        let item = nums[i]
        let j = nums.indexOf(target-item)
        if (j &gt; -1) {
            if (j !==i){
              return [i, j]
            }

        }
    }
};

// 第二种
var twoSum = function (nums, target) {
    let map = {};
    for (let i = 0, len = nums.length; i &lt; len; i++) {
        let num = target - nums[i];
        if (typeof map[nums[i]] === 'number') return [map[nums[i]], i];
        map[num] = i;
    }
};

// 第三种 （超出输出范围？）
var twoSum = function(nums, target) {
    for(let j =0;j&lt;nums.length;j ++) {
        console.log(j,nums[j])
      for(i=nums.length-1 ;i &gt;j; i--) {
          console.log(nums[j],nums[i])
          if(nums[j] + nums[i] === target) {
              return [i, j]
          }
      }  
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/qian-duan-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/qian-duan-bi-ji">
        </link>
        <updated>2019-12-06T00:50:02.000Z</updated>
        <summary type="html"><![CDATA[<h5 id="1-js-的对象">1. JS 的对象</h5>
<ul>
<li><code>JS</code>对象中独有的特性：对象具有高度的动态性，因为<code>JavaScript</code> 赋予了使用在运行时为对象添加状态和行为的能力。<code>JavaSCrpipt</code>允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h5 id="1-js-的对象">1. JS 的对象</h5>
<ul>
<li><code>JS</code>对象中独有的特性：对象具有高度的动态性，因为<code>JavaScript</code> 赋予了使用在运行时为对象添加状态和行为的能力。<code>JavaSCrpipt</code>允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。</li>
</ul>
<!-- more -->
<p>使用内置函数 <code>Object.getOwnPropertyDescripter</code>来查看设置的属性的描述属性。我们可以使用<code>Object.defineProperty</code>来修改属性的特征。实际上<code>JavaSCript</code>对象的运行时是一个&quot;属性的集合&quot;，属性以字符串或者<code>Symbol</code>为<code>key</code>，以数据属性特征值或者访问器属性特征值为<code>value</code>。</p>
<ul>
<li><code>typeOf</code>:<code>typeof</code>返回数据类型的字符串表达，</li>
<li><code>unddefined</code>是声明了未赋值，如果直接使用没有定义的变量会直接提示<code>is not defined</code>，值<code>null</code>是一个字面量，它不像<code>undefined</code>是全局对象的一个属性。<code>null</code>是表示缺少的标识，指示变量未指向任何对象。把<code>null</code>作为尚未创建的对象，也许更好理解。在 <code>APIs</code>中，<code>null</code>常在返回类型是对象，但没关联值的地方使用。</li>
</ul>
<pre><code class="language-js">// foo不存在，它从来没有被定义过或者是初始化过：
foo;
&quot;ReferenceError: foo is not defined&quot;

// foo现在已经是知存在的，但是它没有类型或者是值：
var foo = null; 
foo;
null
</code></pre>
<ul>
<li><code>null</code> 与 <code>undefined</code> 的不同点：<br>
当检测 <code>null</code> 或 <code>undefined</code>时，注意相等<code>（==）</code>与全等<code>（===）</code>两个操作符的区别 ，前者会执行类型转换：</li>
</ul>
<pre><code class="language-js">typeof null        // &quot;object&quot; (因为一些以前的原因而不是'null')
typeof undefined   // &quot;undefined&quot;
null === undefined // false
null  == undefined // true
null === null // true
null == null // true
!null //true
isNaN(1 + null) // false
isNaN(1 + undefined) // true
</code></pre>
<ul>
<li><code>instanceof</code>是判断对象的具体类型，<code>a instanceof b</code>是<code>a</code>是否<code>b</code>的一个实例，也就是说<code>b</code>是不是<code>a</code>的一个构造函数。<br>
<code>typeof</code>不能判断的是：<code>null</code>与<code>object</code>，与<code>array</code>，<code>instanceof</code>返回值为布尔类型。</li>
<li><code>===</code>只能判断<code>undefined</code>以及<code>null</code>，</li>
<li>什么时候赋值为<code>null</code>：1. 定义对象的时候，进行初始赋值，表名将要赋值为对象。编程严谨。2. 销毁对象。垃圾回收机制回收。</li>
<li>严格区别变量类型与数据类型：1. 数据的类型：分为基本类型以及对象类型。2. 变量的类型：基本类型（保存的基本类型的数据）以及引用类型（保存的地址）。</li>
</ul>
<h5 id="2-await-与-async">2. await 与 async</h5>
<ul>
<li><code>async</code>与<code>await</code>可以不同时出现，但是如果函数里面是包含了<code>await</code>那么这个函数必须要是<code>async</code>，<code>await</code>就是说他会等待这个<code>promise</code>对象返回结果，一旦返回结果才会去执行下面的代码，在函数前面加上一个<code>async</code>他会自动将这个函数转换为<code>promise</code>对象，返回的结果就是<code>resolve()</code>返回的内容。</li>
</ul>
<pre><code class="language-js">async function getSyncData() {
  let time = await getSyncTime()
  let data = `endTime - startTime = ${time}`
  return data
}
</code></pre>
<h5 id="3-js-数据">3. JS 数据</h5>
<ul>
<li>
<p>什么是数据：存储在内存中代表特定信息的东西。本是二进制数据。</p>
</li>
<li>
<p>什么是内存：内存条通电以后产生的可以存储数据的空间（临时的数据）。内存产生和死亡：内存条 == 》通电== 》存储数据== 》处理数据== 》断电== 》内存空间和数据都消失。</p>
</li>
<li>
<p>内存的两个数据：内存存储的数据以及地址值。内存分类：栈（全局变量、局部变量），堆（对象）</p>
</li>
<li>
<p>两个引用变量指向同一个对象：变量存储的是对象的内存地址。通过一个变量修改对象内部数据，其他变量看到的是修改之后的数据。两个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象。要想改变一个引用对象，一个是改变地址，一个是改变对象的值。需要注意的是在函数中调用对象的时候，是将变量存储的对象的地址复制给了参数。注意这里的复制了一份地址。</p>
</li>
<li>
<p>改变一个引用变量的值，就是变量需要存储这个引用变量的地址值。</p>
</li>
<li>
<p><code>js</code>在调用函数时传递变量参数时，是值传递还是引用传递：理解1：都是（基本/地址值）传递。理解2：可能是值传递，也可能是引用传递（地址值）。</p>
</li>
<li>
<p><strong>简单数据类型和复杂数据类型在内存中的存储</strong><br>
基本数据类型:<br>
指的是 简单的数据类型，也叫值类型，有数字<code>Number</code>、字符串<code>String</code>、布尔<code>Boolean</code>、未定义<code>Undefined</code>、空<code>Null</code><br>
引用数据类型<br>
指的是 复杂的数据类型， 也叫引用类型，有数组<code>Array</code>、函数<code>Function</code>、对象等<br>
存可以分为栈区 和 堆区<br>
栈区：用来存储用 基本类型的数据 和 引用类型数据的地址。<br>
堆区：用来存储 引用类型数据的数据。<br>
基本类型数据传递给函数的参数时:<br>
基本类型数据在复制时（一个变量名赋值给另一个新的变量名），会在栈区申请一块的空间存放一个新的数据，并且新的变量名会指向新的数据。<br>
引用类型数据传:递给函数的参数时<br>
引用类型数据在复制时（一个变量名赋值给另一个新的变量名），会在栈区申请一块的空间存放堆区中的引用类型数据的地址，并且新的变量名会指向栈区中存放地址的空间。</p>
</li>
<li>
<p>什么时候必须使用['属性名']的方式：1. 属性名包含特殊字符（-或者空格），2. 变量名不确定（动态定义变量）。</p>
</li>
<li>
<p><code>test.call/apply(obj)</code>：临时让<code>test</code>称为<code>obj</code>的方法进行调用。</p>
</li>
<li>
<p>什么函数是回调函数：1. 你定义的 2. 你没有调用 3. 但最终他执行了（在某个时刻，或者在某个条件下）。</p>
</li>
<li>
<p><code>IIFE</code>：匿名函数自调用。作用：隐藏实现、不会污染外部（全局）命名空间。，用它来编写<code>js</code>模块。</p>
</li>
</ul>
<pre><code class="language-js">(function () {

 console.log('---')
})()
</code></pre>
<ul>
<li><code>this</code>的指向：是指向调用他的对象。如果使用<code>call /apply</code>就是指向传入的对象比如：<code>setColor.call(obj,'black')</code>，这里的<code>setColor</code>函数中如果打印	<code>this</code>就是指向<code>obj</code>。<br>
比如<code>var test = p.setColor test()</code>;这里的<code>this</code>是指向的<code>window</code>，因为在赋值给<code>test</code>的时候，并没有执行那个函数。后面调用<code>test</code>就是想当于<code>window.test()</code>，所以这里的<code>this</code>是指向的<code>window</code>。</li>
<li><code>this</code>是什么：所有函数内部都有一个变量<code>this</code>，他的值是调用当前函数的当前对象。任何函数本质上都是通过某个对象来调用的。函数必须通过对象来调用。如果没有指定就是<code>window</code>。</li>
<li>如何确定<code>this</code>的值：<code>test()</code>：<code>window</code>，<code>p.test()</code>：<code>p</code>，<code>new test()</code>：新创建的对象，<code>p.call(obj)</code>：<code>obj</code></li>
<li>关于分号的问题：<code>js</code>一条语句的后面可以不加分号。<br>
在下面两种情况下不急分号会出问题：</li>
</ul>
<ol>
<li>小括号开头的前一句语句：匿名函数：在小括号前加也行，在第一条语句后面加也行。</li>
</ol>
<pre><code class="language-js">var a = 'a'
;(function () {
  console.log('a')
})()
</code></pre>
<ol start="2">
<li>中方括号开头的前一条语句：</li>
</ol>
<pre><code class="language-js">var a = 4
;[1, 3].forEach((item) =&gt; {
  console.log(item)
})
</code></pre>
<p>如果不加分号会理解为：<code>4[1, 3].forEach()</code>。<br>
<img src="https://img-blog.csdnimg.cn/20190721140033231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>
<p>函数的<code>prototype</code>：<br>
1 . 函数的<code>prototype</code>属性：<br>
每个函数都有一个<code>prototype</code>属性，他默认指向一个<code>Object</code>空对象（即称为：原型对象），原型对象中有一个属性<code>constructor</code>，他指向函数对象。<br>
2 .给原型对象添加属性（一般都是方法）：作用：函数的所有实例对象自动拥有原型中的属性（方法）</p>
</li>
<li>
<p>显示原型与隐式原型：<br>
1  每一个函数都有一个<code>prototype</code>,也就是显示原型（属性）<br>
2  每一个实例对象都有一个<code>__proro__</code>可以称为隐式原型（属性）<br>
3  对象的隐式原型的值为其对应构造函数的显示原型的值<br>
4  内存结构<br>
5  总结：<br>
函数的<code>prototype</code>属性：在定义函数时自动添加的，默认值为一个空<code>Object</code>对象。<br>
对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的<code>prototype</code>属性值。<br>
程序员能直接操作显示原型，但不能直接操作隐式原型（ES6之前）<br>
<img src="https://img-blog.csdnimg.cn/20190721161031898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190721170937773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
上图是一个原型链的图解：</p>
<ul>
<li>
<p>访问一个对象的属性时，</p>
<ul>
<li>现在自身属性中查找，找到返回，如果没有，再沿着<code>__proto__</code>这条链向上查找，找到返回，日过最终没找到，返回<code>undefined</code>.</li>
<li>别名：隐式原型链。</li>
<li>作用：查找对象的属性（方法）。</li>
</ul>
</li>
<li>
<p>构造函数/原型/实体对象的关系---作用域链是找属性，变量，原型链找方法。<img src="https://img-blog.csdnimg.cn/20190721172502859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
实例的<code>__proto__</code>指向的是他的构造函数的原型对象（构造函数的显示原型（<code>prototype</code>））</p>
</li>
<li>
<p>函数的显示原型指向的对象默认是空<code>Object</code>实例对象（但<code>Ovject</code>不满足）。</p>
</li>
<li>
<p>所有函数都是<code>Function</code>的实例。包含他本身（<code>Function</code>）。<code>Function.__proto__ === FUnction.prototype</code>。</p>
</li>
<li>
<p><code>Object</code>的原型对象是原型链尽头：<code>Object.prototype.__proto__=null</code>。</p>
</li>
<li>
<p>读取对象的属性值时：会自动到原型链中查找。</p>
</li>
<li>
<p>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。</p>
</li>
<li>
<p>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。</p>
</li>
</ul>
<h5 id="4-js-知识">4. JS 知识</h5>
<h6 id="41-基本类型">4.1 基本类型：</h6>
<p>基本类型有6种：<code>undefined</code>、<code>nul</code>l、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>；注意没有<code>object</code>。<br>
虽然<code>typeof null</code>返回的是<code>object</code>，但是<code>null</code>不是对象，而是基本数据类型的一种。基本数据存储在栈内存，存储的值。复杂数据类型的值存储在堆内存中，地址（指向堆中的值）存储在栈内存。当我们吧对象赋值给另外一个变量的时候，赋值的是地址指向同一块内存空间，当其中一个对象改变时，另一个对象也会发生变化。</p>
<h6 id="42-typeof-与-instanceof">4.2 typeof 与 instanceof</h6>
<p>首先 <code>typeof</code>能够正确的判断基本数据类型，但是除了 <code>null</code>, <code>typeof null</code>输出的是对象。<code>instanceof</code>是通过原型链判断的，<code>A instanceof B,</code> 在<code>A</code>的原型链中层层查找，是否有原型等于<code>B.prototype</code>，如果一直找到A的原型链的顶端(<code>null;即Object.__proto__.__proto__</code>),仍然不等于<code>B.prototype</code>，那么返回<code>false</code>，否则返回<code>true</code>。</p>
<pre><code class="language-js">function instance_of(L, R) {
//L 表示左表达式，R 表示右表达式 
var O = R.prototype;
// 取 R 的显式原型 
L = L.__proto__; 
// 取 L 的隐式原型 
while (true) { 
  if (L === null) 
  //已经找到顶层 
  return false; 
  if (O === L) 
  //当 O 严格等于 L 时，返回 true 
  return true; 
  L = L.__proto__; 
  //继续向上一层原型链查找 
 } 
}
</code></pre>
<h6 id="43-for-offor-in-和-foreachmap-的区别">4.3  for of，for in 和 forEach，map 的区别</h6>
<p><code>for...of</code>循环：具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员(属性值)。<code>for...of</code>循环可以使用的范围包括数组、<code>Set</code> 和 <code>Map</code>结构、某些类似数组的对象、<code>Generator</code>对象，以及字符串。<code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了<code>Iterator</code>接口后才能使用。可以中断循环。<br>
<code>for...in</code>循环：遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。<br>
<code>forEach</code>: 只能遍历数组，不能中断，没有返回值(或认为返回值是<code>undefined</code>)。<br>
<code>map</code>: 只能遍历数组，不能中断，返回值是修改后的数组。</p>
<h6 id="44-箭头函数">4.4  箭头函数</h6>
<p>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定，回顾前面的例子，由于<code>JavaScript</code>函数对<code>this</code>绑定的错误处理，下面的例子无法得到预期结果：</p>
<pre><code class="language-js">var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = function () {
            return new Date().getFullYear() - this.birth; // this指向window或undefined
        };
        return fn();
    }
};
</code></pre>
<p>现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
<pre><code class="language-js">var obj = {
    birth: 1990,
    getAge: function () {
        var b = this.birth; // 1990
        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象
        return fn();
    }
};
obj.getAge(); // 25
</code></pre>
<p>由于this在箭头函数中已经按照词法作用域绑定了，所以，用<code>call()</code>或者<code>apply()</code>调用箭头函数时，无法对<code>this</code>进行绑定，即传入的第一个参数被忽略.</p>
<h6 id="45-词法作用域">4.5 词法作用域</h6>
<p>要明白js中有预定义以及作用域链的特性。词法作用域，也叫静态作用域，它的作用域是指在词法分析阶段就确定了，不会改变。动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。<code>Javascript</code>函数的作用域是词法作用域，比如下面的代码；我们说过，词法作用域是写代码的时候就静态确定下来的。<code>Javascript</code>中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）</p>
<pre><code class="language-js">var a = 2;

function foo() {
  console.log(a); // 会输出2
}

function bar() {
  var a = 3;
  foo();
}

bar();
</code></pre>
<p>但是如果<code>foo</code>函数是<code>bar</code>的一个属性的话，会获取到3，这里结果是2；是因为在函数定义的时候已经确定了定义域。<br>
词法作用域，也叫静态作用域，它的作用域是指在词法分析阶段就确定了，不会改变。动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。</p>
<h6 id="46-call与apply-bind-函数">4.6 call与apply、bind 函数</h6>
<blockquote>
<p>https://blog.csdn.net/u010176097/article/details/80348447</p>
</blockquote>
<h6 id="47-this的指向">4.7 this的指向</h6>
<h6 id="48-promise">4.8 Promise</h6>
<p>主要用于异步计算:</p>
<ul>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</li>
<li>可以在对象之间传递和操作<code>promise</code>，帮助我们处理队列</li>
</ul>
<p>异步回调的问题：</p>
<ul>
<li>之前处理异步是通过纯粹的回调函数的形式进行处理</li>
<li>很容易进入到回调地狱中，剥夺了函数<code>return</code>的能力</li>
<li>问题可以解决，但是难以读懂，维护困难</li>
<li>稍有不慎就会踏入回调地狱 - 嵌套层次深，不好维护</li>
</ul>
<p>Promise</p>
<ul>
<li><code>promise</code>是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）</li>
<li>并未剥夺函数<code>return</code>的能力，因此无需层层传递<code>callback</code>，进行回调获取数据</li>
<li>代码风格，容易理解，便于维护</li>
<li>多个异步等待合并便于解决</li>
</ul>
<pre><code class="language-js">new Promise(
  function (resolve, reject) {
    // 一段耗时的异步操作
    resolve('成功') // 数据处理完成
    // reject('失败') // 数据处理出错
  }
).then(
  (res) =&gt; {console.log(res)},  // 成功
  (err) =&gt; {console.log(err)} // 失败
)
</code></pre>
<p>Promise可以并行处理若干个异步任务：</p>
<pre><code class="language-js">var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
// 同时执行p1和p2，并在它们都完成后执行then:
Promise.all([p1, p2]).then(function (results) {
    console.log(results); // 获得一个Array: ['P1', 'P2']
});
</code></pre>
<p>有些时候，多个异步任务是为了容错。比如，同时向两个<code>URL</code>读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用<code>Promise.race()</code>实现：</p>
<pre><code class="language-js">var p1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, 'P1');
});
var p2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 600, 'P2');
});
Promise.race([p1, p2]).then(function (result) {
    console.log(result); // 'P1'
});
</code></pre>
<p>下面的代码是<code>promise</code>实现一个发送<code>Ajax</code>请求：</p>
<pre><code class="language-js">const getJSON = function(url) {
  const promise = new Promise(function(resolve, reject){
    const handler = function() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    const client = new XMLHttpRequest();
    client.open(&quot;GET&quot;, url);
    client.onreadystatechange = handler;
    client.responseType = &quot;json&quot;;
    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);
    client.send();

  });

  return promise;
};

getJSON(&quot;/posts.json&quot;).then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
</code></pre>
<h6 id="49-asyncawait">4.9 async/await</h6>
<p>在<code>async/await</code>之前，我们有三种方式写异步代码：嵌套回调、以<code>Promise</code>为主的链式回调、使用<code>Generators</code>。<br>
但是，这三种写起来都不够优雅，ES7做了优化改进，<code>async/await</code>应运而生，<code>async/await</code>相比较<code>Promise</code> 对象<code>then</code> 函数的嵌套，与 <code>Generator</code> 执行的繁琐（需要借助<code>co</code>才能自动执行，否则得手动调用<code>next()</code> ）， <code>Async/Await</code>可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。<br>
<code>async/await</code>特点<br>
<code>async/await</code>更加语义化，<code>async</code> 是“异步”的简写，<code>async function</code>用于申明一个<code>function</code>是异步的；<code>await</code>，可以认为是<code>async wait</code>的简写， 用于等待一个异步方法执行完成；<br>
<code>async/await</code>是一个用同步思维解决异步问题的方案（等结果出来之后，代码才会继续往下执行）<br>
可以通过多层 <code>async function</code>的同步写法代替传统的<code>callback</code>嵌套<br>
<code>async function</code>语法<br>
自动将常规函数转换成<code>Promise</code>，返回值也是一个<code>Promise</code>对象<br>
只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数<br>
异步函数内部可以使用<code>await</code>。</p>
<pre><code class="language-js">async function name([param[, param[, ... param]]]) { statements }
name: 函数名称。
param:  要传递给函数的参数的名称
statements: 函数体语句。
返回值: 返回的Promise对象会以async function的返回值进行解析，或者以该函数抛出的异常进行回绝。

async function dd(){console.log('ddd')}
dd().then(err =&gt; {console.log(err)})
</code></pre>
<p><code>await</code>语法<br>
<code>await</code>放置在<code>Promise</code>调用之前，await 强制后面的代码等待，直到<code>Promise</code>对象<code>resolve</code>，得到<code>resolve</code>的值作为<code>await</code>表达式的运算结果<br>
<code>await</code>只能在<code>async</code>函数内部使用,用在普通函数里就会报错。<br>
错误处理<br>
在<code>async</code>函数里，无论是<code>Promise reject</code>的数据还是逻辑报错，都会被默默吞掉,所以最好把<code>await</code>放入<code>try{}catch{}</code>中，<code>catch</code>能够捕捉到<code>Promise</code>对象<code>rejected</code>的数据或者抛出的异常：</p>
<pre><code class="language-js">function timeout(ms) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {reject('error')}, ms);  //reject模拟出错，返回error
  });
}
async function asyncPrint(ms) {
  try {
     console.log('start');
     await timeout(ms);  //这里返回了错误
     console.log('end');  //所以这句代码不会被执行了
  } catch(err) {
     console.log(err); //这里捕捉到错误error
  }
}
asyncPrint(1000);
</code></pre>
<p><code>async</code>函数返回一个<code>Promise</code> 对象。<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数,如下面代码：</p>
<pre><code class="language-js">async function f() {
  return 'hello world';
}

f().then(v =&gt; console.log(v))
// &quot;hello world&quot;
</code></pre>
<p>上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。<code>async</code>函数内部抛出错误，会导致返回的 <code>Promise</code>对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到：</p>
<pre><code class="language-js">async function f() {
  throw new Error('出错了');
}

f().then(
  v =&gt; console.log(v),
  e =&gt; console.log(e)
)
// Error: 出错了
</code></pre>
<p><code>async</code>函数返回的 <code>Promise</code>对象，必须等到内部所有<code>await</code>命令后面的<code>Promise</code>对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<pre><code class="language-js">async function f() {
  await Promise.reject('出错了');
}

f()
.then(v =&gt; console.log(v))
.catch(e =&gt; console.log(e))
// 出错了
</code></pre>
<p>注意，上面代码中，await语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。任何一个<code>await</code>语句后面的 <code>Promise</code>对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p>
<pre><code class="language-js">async function f() {
  await Promise.reject('出错了');
  await Promise.resolve('hello world'); // 不会执行
}
</code></pre>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构里面.</p>
<pre><code class="language-js">async function f() {
  try {
    await Promise.reject('出错了');
  } catch(e) {
  }
  return await Promise.resolve('hello world');
}

f()
.then(v =&gt; console.log(v))
// hello world
</code></pre>
<p>另一种方法是<code>await</code>后面的 <code>Promise</code>对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p>
<pre><code class="language-js">async function f() {
  await Promise.reject('出错了')
    .catch(e =&gt; console.log(e));
  return await Promise.resolve('hello world');
}

f()
.then(v =&gt; console.log(v))
// 出错了
// hello world
</code></pre>
<p>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发:</p>
<pre><code class="language-js">let foo = await getFoo();
let bar = await getBar();
</code></pre>
<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<pre><code class="language-js">// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
</code></pre>
<p><code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错:</p>
<pre><code class="language-js">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  // 报错
  docs.forEach(function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题:</p>
<pre><code class="language-js">function dbFuc(db) { //这里不需要 async
  let docs = [{}, {}, {}];

  // 可能得到错误结果
  docs.forEach(async function (doc) {
    await db.post(doc);
  });
}
</code></pre>
<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环(注意<code>map</code>也是并发的):</p>
<pre><code class="language-js">async function dbFuc(db) {
  let docs = [{}, {}, {}];

  for (let doc of docs) {
    await db.post(doc);
  }
}
</code></pre>
<p><mark>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同</mark>:</p>
<pre><code class="language-js">async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = await Promise.all(promises);
  console.log(results);
}

// 或者使用下面的写法

async function dbFuc(db) {
  let docs = [{}, {}, {}];
  let promises = docs.map((doc) =&gt; db.post(doc));

  let results = [];
  for (let promise of promises) {
    results.push(await promise);
  }
  console.log(results);
}
</code></pre>
<p>实例：按照顺序完成异步操作：<br>
实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p>
<pre><code class="language-js">async function logInOrder(urls) {
  // 并发读取远程URL
  const textPromises = urls.map(async url =&gt; {
    const response = await fetch(url);
    return response.text();
  });

  // 按次序输出
  for (const textPromise of textPromises) {
    console.log(await textPromise);
  }
}
</code></pre>
<p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p>
<blockquote>
<p>其他文章 https://juejin.im/post/5b727f546fb9a009c72caf79</p>
</blockquote>
<h6 id="410-作用域">4.10 作用域</h6>
<p>作用域也可以看做是一套依据名称查找变量的规则。那我们再细看一下这个规则，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。对应到实际问题来说，就是我们熟悉的函数或者变量可以在什么地方调用。</p>
<p><strong>JS中的作用域类型</strong></p>
<ul>
<li>函数作用域</li>
</ul>
<p>函数作用域是js中最常见的作用域了，函数作用域给我们最直观的体会就是，内部函数可以调用外部函数中的变量。一层层的函数，很直观的就形成了嵌套的作用域。我们常常听到的“如果在函数内部我们给一个未定义的变量赋值，这个变量会转变为一个全局变量”，我们从对标识符的操作的角度来理解这句话。</p>
<pre><code class="language-js">var a = 1;

function foo(){
// b第一次出现在函数foo中
    b = a ;
}

foo();

// 全局可以访问到b
console.log(b); //1
</code></pre>
<ul>
<li>块作用域</li>
</ul>
<p>除了函数作用域，JS也提供块作用域。我们应该明确，作用域是针对标识符来说的，块作用域把标识符限制在<code>{}</code>中。<br>
<code>ES6</code>提供的<code>let</code>,<code>const</code>方法声明的标识符都会固定于块中。常被大家忽略的<code>try/catch</code>的<code>catch</code>语句也会创建一个块作用域。</p>
<ul>
<li>改变函数作用域的方法</li>
</ul>
<p>一般说来词法作用域在代码编译阶段就已经确定，这种确定性其实是很有好处的，代码在执行过程中，能够预测在执行过程中如何对它们进行查找。能够提高代码运行阶段的执行效率。不过<code>JS</code>也提供动态改变作用域的方法。<code>eval()</code>函数和<code>with</code>关键字。</p>
<ol>
<li><code>eval()</code>方法：</li>
</ol>
<p>这个方法接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。</p>
<pre><code class="language-js"> function foo(str,a){
     eval(str);//欺骗作用域,词法阶段阶段foo()函数中并没有定义标识符，但是在函数运行阶段却临时定义了一个b；
     console.log(a,b);
 }
 
 var b = 2;
 
 foo(&quot;var b =3;&quot;,1);//1,3

 // 严格模式下，`eval()`会产生自己的作用域，无法修改所在的作用域
 function foo(str){
     'use strict';
     eval(str);
     console.log(a);//ReferenceError: a is not de ned
 }
 
 foo('var a =2');
</code></pre>
<p><code>eval()</code>有时候挺有用，但是性能消耗很大，可能也会带来安全隐患，因此不推荐使用。</p>
<ul>
<li><code>with</code>关键字：</li>
</ul>
<p><code>with</code>通常被当作重复引用同一个对象中的多个属性的快捷方式。</p>
<pre><code class="language-js">    var obj = { 
        a: 1,
      b: 2,
      c: 3 
      };
    // 单调乏味的重复 &quot;obj&quot; obj.a = 2;
    obj.b = 3;
    obj.c = 4;
    // 简单的快捷方式 
   with (obj) {
        a = 3;
        b = 4;
        c = 5;
    }
    function foo(obj) { 
        with (obj) {
            a = 2; 
        }
    }
    var o1 = { 
        a: 3
    };
    var o2 = { 
        b: 3
    };
    foo( o1 );
    console.log( o1.a ); // 2
    
    foo( o2 );
    console.log( o2.a ); // undefined
    
    console.log( a ); // 2——不好，a被泄漏到全局作用域上了!
    
    // 执行了LHS查询，不存在就在全局创建了一个。
    // with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。 
</code></pre>
<p><code>with</code>也会带来性能的损耗。</p>
<ul>
<li>声明提升</li>
</ul>
<p>作用域关系到的是标识符的作用范围，而标识符的作用范围和它的声明位置是密切相关的。在js中有一些关键字是专门用来声明标识符的（比如<code>va</code>r,<code>let</code>,<code>const</code>），非匿名函数的定义也会声明标识符。<br>
关于声明也许大家都听说过声明提升一词。我们来分析一下造成声明提升的原因。<br>
我们已经知道引擎会在解释<code>JavaScript</code>代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来（词法作用域的核心）。<br>
这样的话，声明好像被提到了前面。<br>
值得注意的是每个作用域都会进行提升操作。声明会被提升到所在作用域的顶部。<br>
不过并非所有的声明都会被提升，不同声明提升的权重也不同，具体来说函数声明会被提升，函数表达式不会被提升（就算是有名称的函数表达式也不会提升）。<br>
通过<code>var</code>定义的变量会提升，而<code>let</code>和<code>const</code>进行的声明不会提升。<br>
函数声明和变量声明都会被提升。但是一个值得注意的细节也就是函数会首先被提升，然后才是变量，也就是说如果一个变量声明和一个函数声明同名，那么就算在语句顺序上变量声明在前，该标识符还是会指向相关函数。<br>
如果变量或函数有重复声明以会第一次声明为主。<br>
最后一点需要注意的是：<br>
声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</p>
<h6 id="411-this指向">4.11 this指向</h6>
<ul>
<li>函数调用</li>
</ul>
<p><code>JS</code>（<code>ES5</code>）里面有三种函数调用形式：</p>
<pre><code class="language-js">func(p1, p2) 
obj.child.method(p1, p2)
func.call(context, p1, p2) // 先不讲 apply
</code></pre>
<p>一定要记住，第三种调用形式，才是正常调用形式，其他两种都是语法糖，可以等价地变为<code>call</code>形式：</p>
<pre><code class="language-js">func(p1, p2)等价于 func.call(undefined, p1, p2);

obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);
</code></pre>
<p>这样，<code>this</code> 就好解释了 <code>this</code>就是上面 <code>context</code>。<code>this</code>是你 <code>call</code>一个函数时传的 <code>context</code>，由于你从来不用 <code>call</code>形式的函数调用，所以你一直不知道。<br>
先看<code>func(p1, p2)</code>中的 <code>this</code>如何确定：</p>
<pre><code class="language-js">当你写下面代码时

function func(){
  console.log(this)
}

func()

等价于

function func(){
  console.log(this)
}

func.call(undefined) // 可以简写为 func.call()
</code></pre>
<p>按理说打印出来的<code>this</code>应该就是 <code>undefined</code>了吧，但是浏览器里有一条规则：</p>
<blockquote>
<p>如果你传的<code>context</code>就 <code>null</code> 或者 <code>undefined</code>，那么<code>window</code>对象就是默认的<code>context</code>（严格模式下默认 <code>context</code>是 <code>undefined</code>）</p>
</blockquote>
<p>因此上面的打印结果是<code>window</code>。如果你希望这里的<code>this</code>不是<code>window</code>，很简单：</p>
<pre><code class="language-js">func.call(obj) // 那么里面的 this 就是 obj 对象了     
</code></pre>
<p>所以经常看到的面试题这样解答：</p>
<pre><code class="language-js">var obj = {
  foo: function(){
    console.log(this)
  }
}

var bar = obj.foo
obj.foo() // 转换为 obj.foo.call(obj)，this 就是 obj
bar() 
// 转换为 bar.call()
// 由于没有传 context
// 所以 this 就是 undefined
// 最后浏览器给你一个默认的 this —— window 对象    
</code></pre>
<ul>
<li>[] 语法</li>
</ul>
<p>如下代码：</p>
<pre><code class="language-js">function fn (){ console.log(this) }
var arr = [fn, fn2]
arr[0]() // 这里面的 this 又是什么呢？ 
</code></pre>
<p>我们可以把 <code>arr[0]( )</code> 想象为<code>arr.0( )</code>，虽然后者的语法错了，但是形式与转换代码里的 <code>obj.child.method(p1, p2)</code>对应上了，于是就可以愉快的转换了：</p>
<pre><code class="language-js">        arr[0]() 
假想为    arr.0()
然后转换为 arr.0.call(arr)
那么里面的 this 就是 arr 了
</code></pre>
<ul>
<li>小结</li>
</ul>
<blockquote>
<p>this 就是你 call 一个函数时，传入的第一个参数。<br>
如果你的函数调用不是 call 形式， 请将其转换为 call 形式</p>
</blockquote>
<h6 id="412-闭包closure">4.12 闭包(closure)</h6>
<p>闭包在<code>JavaScript</code>中常用来实现对象数据的私有，在事件处理和回调函数中也常常会用到它，此外还有偏函数应用（<code>partial applications</code>）和柯里化（<code>currying</code>），以及其他函数式编程模式。<br>
在函数外访问了函数内的标识符，如下面代码：</p>
<pre><code class="language-js">    function foo() {
        var a = 2;
    
        function bar() {
            console.log(a);
        }
        return bar;
    }
    var baz = foo();
    baz(); // 2 —— 这就是闭包的效果。在函数外访问了函数内的标识符
    
    // bar()函数持有对其父作用域的引用，而使得父作用域没有被销毁，这就是闭包
</code></pre>
<p>如定义一个模块，采用闭包：</p>
<pre><code class="language-js">    function CoolModule() {
        var something = &quot;cool&quot;;
        var another = [1, 2, 3];
    
        function doSomething() {
            console.log(something);
        }
    
        function doAnother() {
            console.log(another.join(&quot; ! &quot;));
        }
    
    // 返回的是一个对象，对象中可能包含各种函数
        return {
            doSomething: doSomething,
            doAnother: doAnother
        };
    }

    var foo = CoolModule();
// 在外面调用返回对象中的方法就形成了闭包
    foo.doSomething(); // cool
    foo.doAnother(); // 1 ! 2 ! 3
</code></pre>
<ul>
<li><code>setTimeout</code>函数之循环和闭包</li>
</ul>
<p>https://www.jianshu.com/p/e5225ba4a025</p>
<ul>
<li>闭包的缺陷</li>
</ul>
<p>闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。<br>
如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p>
<h6 id="413-原型链">4.13 原型链</h6>
<p>所有的函数都有一个特殊的属性: <code>prototype</code>(原型)，<code>prototype</code>属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以被函数的实例所共享。所谓的函数实例是指以函数作为构造函数创建的对象，这些对象实例都可以共享构造函数的原型的方法</p>
<p>要知道属性<code>__proto__</code>是指向的他的构造函数的原型对象，而它的构造函数的原型对象有一个<code>constructor</code>属性指向的是构造函数本身。<br>
<img src="https://img-blog.csdnimg.cn/20190922143626644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="https://user-gold-cdn.xitu.io/2017/6/28/5999753fd5f1cc8e86e030c1555e0b51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"><br>
执行上面代码时，首先会在对象实例<code>person</code>中查找属性<code>toString</code>方法，我们发现实例中不存在<code>toString</code>属性。然后我们转到<code>person</code>内部指针<code>[[Prototype]]</code>指向的<code>Person</code>原型对象去寻找<code>toString</code>属性，结果是仍然不存在。这找不到我们就放弃了？开玩笑，我们这么有毅力。我们会再接着到<code>Person</code>原型对象的内部指针<code>[[Prototype]]</code>指向的<code>Object</code>原型对象中查找，这次我们发现其中确实存在<code>toString</code>属性，然后我们执行<code>toString方法</code>。发现了没有，这一连串的原型形成了一条链，这就是原型链。</p>
<h6 id="414-几种继承方式">4.14 几种继承方式</h6>
<ol>
<li>原型链实现继承</li>
</ol>
<pre><code class="language-js">function Parent () {
   this.name = '张三';

Parent.prototype.getName = function () {
   console.log(this.name);
}
function Child () {

}
Child.prototype = new Parent();
var child1 = new Child();
console.log(child1.getName()) // 张三
</code></pre>
<p>存在的问题：</p>
<ul>
<li>引用类型的属性被所有实例共享，举个例子：</li>
</ul>
<pre><code class="language-js">function Parent () {
    this.names = ['张三', '李四'];
}
function Child () {

}
Child.prototype = new Parent();
var child1 = new Child();
child1.names.push('王五');
console.log(child1.names); // [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]
var child2 = new Child();
console.log(child2.names); // [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]
</code></pre>
<ul>
<li>在创建<code>Child</code>的实例时，不能向<code>Parent</code>传参</li>
</ul>
<ol start="2">
<li>构造函数实现继承</li>
</ol>
<pre><code class="language-js">function Parent () {
    this.names = ['张三', '李四'];
}

function Child () {
    Parent.call(this);
}

var child1 = new Child();

child1.names.push('王五');

console.log(child1.names); // [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]

var child2 = new Child();

console.log(child2.names); // [&quot;张三&quot;, &quot;李四&quot;]
</code></pre>
<blockquote>
<p>https://juejin.im/post/5d259684e51d454d56535874</p>
</blockquote>
<h6 id="415-js-的暂时性死区">4.15 js 的暂时性死区</h6>
<p>在代码块内，使用<code>let</code>、<code>const</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（<code>temporal dead zone</code>，简称 <code>TDZ</code>）。<br>
所以说“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</p>
<pre><code class="language-js">typeof x; // ReferenceError
let x;
</code></pre>
<h6 id="416-es6-中的-map-对象跟原生的对象之间的区别">4.16 ES6 中的 map 对象跟原生的对象之间的区别</h6>
<p><code>object</code>和<code>Map</code>存储的都是键值对组合。但是：<br>
<code>object</code>的键的类型是 字符串；<br>
<code>map</code>的键的类型是 可以是任意类型；<br>
另外注意，<code>object</code>获取键值使用<code>Object.keys</code>（返回数组）；<br>
<code>Map</code>获取键值使用 <code>map变量.keys()</code> (返回迭代器)。</p>
<pre><code class="language-js">            let a = {
                o: 1
            };
            // string
            console.log(typeof Object.keys(a)[0]);
            let map = new Map();
            map.set(a, 'content');
            // 输出是object 也可以是任何类型
            console.log(map.keys().next());
</code></pre>
<p>优点：</p>
<ul>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以在 Child 中向 Parent 传参</li>
</ul>
<blockquote>
<p>https://juejin.im/post/5d2d51cb51882563453244b6</p>
</blockquote>
<h6 id="417-es6-中的-set-对象">4.17 ES6 中的 Set 对象</h6>
<p>在<code>Set</code>对象内部，两个<code>NaN</code>是相等的：</p>
<pre><code class="language-js">let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
</code></pre>
<p>另外，两个对象总是不相等的。</p>
<pre><code class="language-js">let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
</code></pre>
<p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与<code>Set</code>有两个区别。<code>WeakSet</code>的成员只能是对象，而不能是其他类型的值。<br>
<code>Set</code>相关的操作有：<code>add、delete、has、size属性</code> 对应<code>map</code>的操作：<code>set、get、has、delete、size属性</code></p>
<h6 id="418-事件的捕获与冒泡">4.18 事件的捕获与冒泡</h6>
<blockquote>
<p>https://juejin.im/post/5acf3130f265da23a1424a99</p>
</blockquote>
<h6 id="419-数组与对象的深拷贝">4.19 数组与对象的深拷贝</h6>
<p>实现代码如下：</p>
<pre><code class="language-js">        // 数组的深拷贝
        // slice
        let arr = [1, 2, 30]
        let arrTo = arr.slice(0)

        // concat
        let arr1 = [1,2, 3]
        let arrTo1 = arr1.concat()

        // for of 直接遍历
        let arr2 = [1, 2, 30]
        function copyArr(arr2) {
            let newArray = []
            for (let item of arr2) {
                newArray.push(item)
            }
        }

        // 对象的深拷贝
        // 1. 直接遍历
        let obj = {name: 'ddd', job: 'dalao'}
        function copyObj(obj) {
            let newObj = {}
            for (let item in obj) {
                newObj[item] = obj[item]
            }
            return newObj
        }
        // 2. es6的 Object.assign（注意这里其实不是深拷贝，如果拷贝的源对象中有一个属性为对象，那么它也只指向那个引用。）
        let obj1 = { name: 'ddd', job: 'dalao' }
        let copyObj = Object.assign({}, obj)
        // 下面拷贝将会污染变量
		let obj1 = { a: 0 , b: { c: 0}}; 
		let obj2 = Object.assign({}, obj1); 
		console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 
		obj2.b.c = 3; 
		console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} 
		console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 
 
        // 3. 使用JSON.parse以及JSON.stringify方法--但是这种简单粗暴的方法有其局限性。当值为undefined、function、symbol 会在转换过程中被忽略;所以，对象值有这三种的话用这种方法会导致属性丢失。
		obj1 = { a: 0 , b: { c: 0}}; 
		let obj3 = JSON.parse(JSON.stringify(obj1)); 
		obj1.a = 4; 
		obj1.b.c = 4; 
		console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
		
		// 4. 通过函数实现深拷贝
		function deepCopy(obj) {
		      var result = Array.isArray(obj) ? [] : {};
		      for (var key in obj) {
		        if (obj.hasOwnProperty(key)) {
		          if (typeof obj[key] === 'object' &amp;&amp; obj[key]!==null) {
		            result[key] = deepCopy(obj[key]);   //递归复制
		          } else {
		            result[key] = obj[key];
		          }
		        }
		      }
		      return result;
		    }
</code></pre>
<h6 id="412-实现队列与堆栈">4.12 实现队列与堆栈</h6>
<p>队列:是一种支持先进先出(<code>FIFO</code>)的集合,即先被插入的数据,先被取出!<br>
堆栈:是一种支持后进先出(<code>LIFO</code>)的集合,即后被插入的数据,先被取出!</p>
<p>在<code>JavaScript</code>中实现队列和数组主要是通过数组，<code>js</code>数组中提供了以下几个方法可以让我们很方便实现队列和堆栈：</p>
<p><code>shift</code>:从数组中把第一个元素删除，并返回这个元素的值。</p>
<p><code>unshift</code>: 在数组的开头添加一个或更多元素，并返回新的长度</p>
<p><code>push</code>:在数组的中末尾添加元素，并返回新的长度</p>
<p><code>pop</code>:从数组中把最后一个元素删除，并返回这个元素的值。</p>
<ul>
<li>实现队列</li>
</ul>
<pre><code class="language-js">var queue = new Array();
// unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。
queue.unshift(1);
queue.unshift(2);
queue.unshift(3);
queue.unshift(4);
// pop() 方法用于删除并返回数组的最后一个元素。
var first = queue.pop();
console.log(first); // 结果为1，先进先出
</code></pre>
<ul>
<li>实现堆栈</li>
</ul>
<pre><code class="language-js">var stack = new Array();
stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);
var first = stack.pop();
console.log(first);// 结果为4，先进后出
</code></pre>
<p>需要知道的是：堆是动态分配内存，内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。<br>
<code>javascript</code>的基本类型就<code>5</code>种:<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>和<code>String</code>，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。</p>
<p><code>javascript</code>中其他类型的数据被称为引用类型的数据 : 如对象(<code>Object</code>)、数组(<code>Array</code>)、函数(<code>Function</code>) …，它们是通过拷贝和<code>new</code>出来的，这样的数据存储于堆中。其实，说存储于堆中，也不太准确，因为，引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据。</p>
<h5 id="5-vue相关">5. vue相关</h5>
<h6 id="51-vue-cli">5.1 vue-cli</h6>
<ul>
<li>初始化后的<code>package.js</code>文件</li>
</ul>
<p>项目初始化之后，<code>package.js</code>内容如下：</p>
<pre><code class="language-js">{
  &quot;name&quot;: &quot;my-project&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,
    &quot;build&quot;: &quot;vue-cli-service build&quot;,
    &quot;lint&quot;: &quot;vue-cli-service lint&quot;
  },
  &quot;dependencies&quot;: {
    &quot;core-js&quot;: &quot;^2.6.5&quot;,
    &quot;vue&quot;: &quot;^2.6.10&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@vue/cli-plugin-babel&quot;: &quot;^3.11.0&quot;,
    &quot;@vue/cli-plugin-eslint&quot;: &quot;^3.11.0&quot;,
    &quot;@vue/cli-service&quot;: &quot;^3.11.0&quot;,
    &quot;babel-eslint&quot;: &quot;^10.0.1&quot;,
    &quot;eslint&quot;: &quot;^5.16.0&quot;,
    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;
  },
  &quot;eslintConfig&quot;: {
    &quot;root&quot;: true,
    &quot;env&quot;: {
      &quot;node&quot;: true
    },
    &quot;extends&quot;: [
      &quot;plugin:vue/essential&quot;,
      &quot;eslint:recommended&quot;
    ],
    &quot;rules&quot;: {},
    &quot;parserOptions&quot;: {
      &quot;parser&quot;: &quot;babel-eslint&quot;
    }
  },
  &quot;postcss&quot;: {
    &quot;plugins&quot;: {
      &quot;autoprefixer&quot;: {}
    }
  },
  &quot;browserslist&quot;: [
    &quot;&gt; 1%&quot;,
    &quot;last 2 versions&quot;
  ]
}
</code></pre>
<h6 id="52-vue-router-中-hash-模式与-history-模式的对比">5.2 vue-router 中 hash 模式与 history 模式的对比</h6>
<p>在<code>vue</code>的路由配置中有<code>mode</code>选项 最直观的区别就是在<code>url</code>中<code>hash</code>带了一个很丑的<code>#</code> 而<code>history</code>是没有<code>#</code>的。<br>
<code>vue-router</code> 默认 <code>hash</code>模式 —— 使用<code>URL</code> 的 <code>hash</code>来模拟一个完整的 <code>URL</code>，于是当 <code>URL</code> 改变时，页面不会重新加载。<br>
如果不想要很丑的 <code>hash</code>，我们可以用路由的 <code>history</code> 模式，这种模式充分利用<code>history.pushState API</code>来完成 <code>URL</code> 跳转而无须重新加载页面。</p>
<pre><code class="language-js">const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
</code></pre>
<p>当使用 <code>history</code>模式时，<code>URL</code> 就像正常的<code>url</code>，例如 http://yoursite.com/user/id，也好看！</p>
<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。</p>
<p>所以呢，要在服务端增加一个覆盖所有情况的候选资源：如果<code>URL</code> 匹配不到任何静态资源，则应该返回同一个<code>index.html</code>页面，这个页面就是你 <code>app</code>依赖的页面。</p>
<ul>
<li>两者的区别：</li>
</ul>
<ol>
<li><code>hash</code>特点：比如这个 <code>URL</code>：<code>http://www.abc.com/#/hello</code>，<code>hash</code>的值为<code>#/hello</code>，<code>hash</code>虽然出现在 <code>URL</code>中，但不会被包括在<code>HTTP</code> 请求中，对后端完全没有影响，因此改变 <code>hash</code> 不会重新加载页面。</li>
<li><code>history</code>特点： 利用了<code>HTML5 History Interface</code> 中新增的 <code>pushState()</code> 和 <code>replaceState()</code>方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 <code>back</code>、<code>forward</code>、<code>go</code> 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 <code>URL</code>，但浏览器不会立即向后端发送请求。</li>
</ol>
<ul>
<li><code>hash</code>模式</li>
</ul>
<p><code>hash</code>模式背后的原理是<code>onhashchange</code>事件,可以在<code>window</code>对象上监听这个事件:</p>
<pre><code class="language-js">window.onhashchange = function(event){
     console.log(event.oldURL, event.newURL);
     let hash = location.hash.slice(1); 
     document.body.style.color = hash;
}
</code></pre>
<ul>
<li><code>history</code> 模式</li>
</ul>
<p>修改历史状态包括了<code>pushState</code>,<code>replaceState</code>,两个方法,这两个方法接收三个参数:<code>stateObj</code>,<code>title</code>,<code>url</code>：</p>
<pre><code class="language-js">history.pushState({color:'red'}, 'red', 'red')
history.back();
setTimeout(function(){
    history.forward();
 },0)
window.onpopstate = function(event){
     console.log(event.state)
     if(event.state &amp;&amp; event.state.color === 'red'){
           document.body.style.color = 'red';
      }
}
</code></pre>
<p>通过<code>pushstate</code>把页面的状态保存在<code>state</code>对象中，当页面的<code>url</code>再变回这个<code>url</code>时，可以通过<code>event.state</code>取到这个<code>state</code>对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到<code>state</code>的里面。</p>
<p>通过<code>history api</code>，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，就怕刷新，<code>f5</code>，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。<br>
在<code>hash</code>模式下，前端路由修改的是<code>#</code>中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在<code>history</code>下，你可以自由的修改<code>path</code>，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个<code>404</code>来。</p>
<ul>
<li>总结</li>
</ul>
<ol>
<li><code>hash</code> 模式下，仅<code>hash</code> 符号之前的内容会被包含在请求中，如<code>http://www.abc.com</code>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回<code>404</code>错误。<br>
2.<code>history</code> 模式下，前端的 <code>URL</code> 必须和实际向后端发起请求的<code>URL</code> 一致，如<code>http://www.abc.com/book/id</code>。如果后端缺少对<code>/book/id</code> 的路由处理，将返回 <code>404</code> 错误。<code>Vue-Router</code> 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 <code>URL</code> 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 <code>app</code>依赖的页面。”</li>
<li>结合自身例子，对于一般的<code>Vue</code> + <code>Vue-Router</code>+<code>Webpack</code> + <code>XXX</code> 形式的 <code>Web</code> 开发场景，用<code>history</code> 模式即可，只需在后端（<code>Apache</code>或 <code>Nginx</code>）进行简单的路由配置，同时搭配前端路由的 <code>404</code> 页面支持。</li>
</ol>
<h6 id="53-组件之间的调用">5.3 组件之间的调用</h6>
<p>父组件调用子组件的方法：<code>this.$refs.子组件ref的值.方法名</code>,或者可以通过调用<code>this.$children</code>或者到所有子组件的数组，按照调用关系的先后顺序的数组，然后调用子组件的方法。</p>
<h6 id="54-对mvvm的理解">5.4 对MVVM的理解</h6>
<p><code>MVVM</code>是<code>Model-View-ViewModel</code>的缩写，<code>Model</code>代表数据模型负责业务逻辑和数据封装，<code>View</code>代表<code>UI</code>组件负责界面和显示，<code>ViewModel</code>监听模型数据的改变和控制视图行为，处理用户交互，简单来说就是通过双向数据绑定把<code>View</code>层和<code>Model</code>层连接起来。在<code>MVVM</code>架构下，<code>View</code>和<code>Model</code>没有直接联系，而是通过<code>ViewModel</code>进行交互，我们只关注业务逻辑，不需要手动操作<code>DOM</code>，不需要关注<code>View</code>和<code>Model</code>的同步工作。</p>
<h6 id="55-vue等单页面应用及优缺点">5.5 vue等单页面应用及优缺点</h6>
<p><code>vue</code>核心是一个响应的数据绑定系统，<code>mvvm</code>，数据驱动，组件化，轻量，简洁，高效，快速，模块友好。</p>
<p>缺点：不支持低版本浏览器，最低到IE9，不利于SEO的优化，首页加载时间较长，不可以使用浏览器的导航按钮需要自行实现前进后退。</p>
<h6 id="56-route和router的区别">5.6 route和router的区别</h6>
<p><code>route</code>是路由信息对象，包括<code>path</code>,<code>params</code>,<code>hash</code>,<code>query</code>,<code>fullPath</code>,<code>matched</code>,<code>name</code>等路由信息参数。<br>
router是路由实例对象，包括了路由的跳转方法，钩子函数。</p>
<h6 id="57-vue-router的routes中name属性作用详解">5.7 vue-router的routes中name属性作用详解</h6>
<p>我们一般配置路由如下：</p>
<pre><code class="language-js">export default new Router({
  mode: 'history',
  routes: [
    {
      path: '/',
      name: 'Hello',
      component: Hello
    }, {
      path: '/text',
      name: 'text',
      component: text
    }, {
      path: '/text/:id',
      component: param
    }
  ]
})
</code></pre>
<p>第一种用法：<br>
通过<code>name</code>属性，为一个页面中不同的<code>router-view</code>渲染不同的组件,如：将上面代码的<code>Hello</code>渲染在 <code>name</code>为<code>Hello</code>的<code>router-view</code>中，将<code>text</code>渲染在<code>name</code>为<code>text</code>的<code>router-view</code>中。不设置<code>name</code>的将为默认的渲染组件。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
     &lt;router-view&gt;&lt;/router-view&gt;
     &lt;router-view  name=&quot;Hello&quot;&gt;&lt;/router-view&gt; //将渲染Hello组件
     &lt;router-view  name=&quot;text&quot;&gt;&lt;/router-view&gt;   //将渲染text组件
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>第二种用法：<br>
可以用<code>name</code>传参 使用<code>$router.name</code>获取组件<code>name</code>值</p>
<pre><code class="language-html"> &lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ $route.name }}&lt;/p&gt; //可以获取到渲染进来的组件的name值
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>第三种用法：<br>
用于<code>pramas</code>传参的引入 <code>pramas</code>必须用<code>name</code>来引入 <code>query</code>可以用<code>name</code>或者<code>path</code>来引入</p>
<blockquote>
<p>链接：https://blog.csdn.net/alokka/article/details/84318734</p>
</blockquote>
<h6 id="58-vue的声明周期">5.8 vue的声明周期</h6>
<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA">声明周期</a><br>
生命周期共分为<code>8</code>个阶段创建前/后，载入前/后，更新前/后，销毁前/后<br>
创建前/后：在<code>beforeCreated</code>阶段，<code>vue</code>实例的挂载元素<code>el</code>和数据对象<code>data</code>都为<code>undefined</code>，还未初始化。<code>created</code>阶段，<code>vue</code>实例的数据对象<code>data</code>有了，<code>el</code>还没有。<br>
载入前后：在<code>beforeMount</code>阶段，<code>vue</code>实例的<code>el</code>和<code>data</code>都初始化了，但还是挂载之前为虚拟的<code>dom</code>节点，<code>data.message</code>还未替换。在<code>mounted</code>阶段，<code>vue</code>实例挂载完成，<code>data.message</code>成功渲染<br>
更新前/后：当<code>data</code>变化时，会触发<code>beforeUpdated</code>和<code>updated</code>方法<br>
销毁前/后：<code>beforeDestroy</code>在实例销毁前调用，实例仍然完全可用。<code>destroy</code>在实例销毁之后调用，调用后所有事件监听器会被移除，所有子实例也会被销毁。<br>
生命周期的作用？<br>
生命周期中有多个事件钩子，让我们在控制整个<code>Vue</code>实例的过程中更容易形成好的逻辑。</p>
<h6 id="59-vue如何自定义一个过滤器">5.9 vue如何自定义一个过滤器</h6>
<pre><code class="language-js">&lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt;
{{msg | capitalize}}

data(){
    return{
        msg: ''
    }
},
filters: {
    capitalize: function(value){
        if(!value) return &quot;&quot;;
        value = value.toString();
        return value.charAt(0).toUpperCase()+value.slice(1)
    }
}
</code></pre>
<h6 id="510-computed和watch区别">5.10 computed和watch区别</h6>
<p><code>computed</code>是计算属性，依赖其他属性计算值，并且<code>computed</code>的值有缓存，只有当计算值变化才会返回内容。<br>
<code>watch</code>监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br>
一般来说需要依赖别的属性来动态获得值的时候可以使用<code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用<code>watch</code><br>
另外<code>computed</code>和<code>watch</code>还支持对象的写法</p>
<pre><code class="language-js">data: {
    firstName: 'Chen',
    lastName: 'Miao',
    fullName: 'Chen Miao'
},
watch: {
    firstName: function(val){
        this.fullName = val+ ' '+this.lastName
    },
    lastName: function(val){
        this.fullName = this.firstName+ ' '+val
    }
},
computed: {
    anoFullName: function(){
        return this.firstName+' '+this.lastName
    }
}

</code></pre>
<h6 id="511-extend能做什么">5.11 extend能做什么</h6>
<p>作用是扩展组件生成一个构造器，通常与<code>$mount</code>一起使用。</p>
<pre><code class="language-js">// 创建组件构造器
let Component = Vue.extend({
    template: '&lt;div&gt;test&lt;/div&gt;'
})
// 挂载到#app上
new Component().$mount('#app')

// 扩展已有组件
let SuperComponent = Vue.extend(Component)
new SuperComponent({
    created(){
        console.log(1)
    }
})
new SuperComponent().$mount('#app')

</code></pre>
<h6 id="512-mixin和mixins区别">5.12 mixin和mixins区别</h6>
<p><code>mixin</code>用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<pre><code class="language-js">Vue.mixin({
    beforeCreate(){
        // 会影响到每个组件的beforeCreate钩子函数
    }
})
</code></pre>
<p><code>mixins</code>最常用的扩展组件的方式。如果多个组件有相同的业务逻辑，就可将这些逻辑剥离出来，通过<code>mixins</code>混入代码。需要注意：<code>mixins</code>混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。<br>
在组件中进行混入如下：</p>
<pre><code class="language-js">import { isShowFooter } from '../../../mixins/isShowFooter.js'
import { navbar } from '../../../mixins/navbar.js'
import api from '@/api/index'
export default {
  mixins: [isShowFooter, navbar],
</code></pre>
<p><code>isShowFooter.js</code>中的内容：</p>
<pre><code class="language-js">import { mapMutations } from 'vuex'
export const isShowFooter = {
  data() {
    return {}
  },
  created() {
    this.initState()
  },
  methods: {
    ...mapMutations(['footerIsShow']),
    initState() {
      this.footerIsShow(false)
    }
  }
}

</code></pre>
<p>这里是通过控制一个<code>state</code>来判断是否显示组件；比如上面的代码，要显示底部的工具条，在布局的组件里面直接调用底部工具组件：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
    &lt;Footer v-show=&quot;show&quot;&gt;&lt;/Footer&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Footer from '../../components/footer/Footer'
import { mapState, mapMutations } from 'vuex'
export default {
  components: {
    Footer
  },
  computed: {
    ...mapState({
      show: state =&gt; state.index.show
    })
  },
  watch: {
    '$route': function (to, from) {
      const navListPath = ['/work', '/info', '/my', '/address'];
      const isIncludePath = navListPath.some((nav) =&gt; {
        return nav === to.path
      })
      // 共用组件时   刷新问题
      if (isIncludePath) {
        this.footerIsShow('true')
      }
    }
  },
  mounted () {
  },
  methods: {
    ...mapMutations(['footerIsShow'])
  }
}
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped&gt;
&lt;/style&gt;
</code></pre>
<p><a href="https://cn.vuejs.org/v2/guide/mixins.html">官网</a></p>
<h6 id="513-如何使用vuenexttick">5.13 如何使用vue.nextTick()</h6>
<p><code>nextTick</code>可以使我们在下次<code>DOM</code>更新循环结束之后执行延迟回调，用于获得更新后的<code>DOM</code>。</p>
<pre><code class="language-js">data:function(){
    return {
        message: '没有更新'
    }
},
methods: {
    updateMessage: function(){
        this.message='更新完成'
        console.log(this.$el.textContent) // '没有更新'
        this.$nextTick(function(){
          console.log(this.$el.textContent)// '更新完成'  
        })
    }
}

</code></pre>
<h6 id="514-transition-过渡的实现原理">5.14 transition 过渡的实现原理</h6>
<pre><code class="language-html">&lt;transition name=&quot;fade1&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;
</code></pre>
<p>类名介绍：<br>
v-enter:定义进入过渡的开始状态<br>
v-enter-active:定义进入过渡生效时的状态<br>
v-enter:定义进入过渡的结束状态<br>
v-leave:定义离开过渡的开始状态<br>
v-leave-active:定义离开过渡生效时的状态<br>
v-leave-to:定义离开过渡的结束状态</p>
<h6 id="515-非父子组件通讯">5.15 非父子组件通讯</h6>
<ol>
<li>新建一个<code>bus.js</code>文件:</li>
</ol>
<pre><code class="language-js">import Vue from 'vue';
export default new Vue();
</code></pre>
<ol start="2">
<li>使用它</li>
</ol>
<pre><code class="language-js">&lt;div @click=&quot;addCart&quot;&gt;添加&lt;/div&gt;
import Bus from 'bus.js';
export default{
    methods: {
        addCart(event){
            Bus.$emit('getTarget', event.target)
        }
    }
}
// 另一组件
export default{
    created(){
        Bus.$on('getTarget', target =&gt;{
            console.log(target)
        })
    }
}

</code></pre>
<h6 id="516-vue-router">5.16 vue-Router</h6>
<p>普通路由</p>
<pre><code class="language-js">router.push('home')
router.push({path: 'home')
</code></pre>
<p>命名路由</p>
<pre><code class="language-js">const router=new VueRouter({
    routes: [{
        path: '/user',
        name: 'user',
        component: User
    }]
})

&lt;router-link :to=&quot;{name: 'user'}&quot;&gt;&lt;/router-link&gt;
router.push({
    name: 'user'
})
</code></pre>
<h6 id="517-vuex中的mapstate-mapmutation-mapactions">5.17 vuex中的mapState、mapMutation、mapActions</h6>
<p><img src="https://img-blog.csdnimg.cn/20191012141859888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
在子组件中使用<code>mapState</code>辅助函数，使用最想扩展运算符，如下代码：</p>
<pre><code class="language-js">  computed: {
    ...mapState({
      show: state =&gt; state.index.show
    })
  },
</code></pre>
<p>其中<code>show</code>是<code>index</code>模块中的<code>state</code>中存储的值。<br>
如果不使用对象扩展运算符：</p>
<pre><code class="language-js">// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state =&gt; state.count,

    // 传字符串参数 'count' 等同于 `state =&gt; state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
</code></pre>
<p>如果是<code>mapMutation</code>：</p>
<pre><code class="language-js">  methods: {
    ...mapMutations(['footerIsShow'])
  }
</code></pre>
<p><code>mapActions</code>的如下代码：</p>
<pre><code class="language-js">  methods: {
    ...mapMutations(['isFooterShow']),
    ...mapActions(['login']),
  }
</code></pre>
<h6 id="518-vue的双向数据绑定原理的理解">5.18 vue的双向数据绑定原理的理解</h6>
<p><code>vue.js</code>是采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.definePorperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>
<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>数据变化，通过<code>Compile</code>来解析编译模板指定（解析{{}}），最终利用<code>Watcher</code>搭起<code>Observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化-&gt;视图更新；视图交互变化<code>input</code>-&gt;数据<code>model</code>变更的双向绑定效果<br>
实现简单的双向绑定</p>
<pre><code class="language-js">&lt;input type=&quot;text&quot; id=&quot;inp&quot; /&gt;
&lt;div id=&quot;show&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var inp = document.getElementById('inp');
var show = document.getElementById('show');
var obj = {};
function watch(obj, key, callback){
    var val = obj[key];
    Object.defineProperty(obj, key, {
        get: function(){
            return val;
        },
        set: function(newVal){
            callback(newVal, this)
        }
    })
}
watch(obj, &quot;input&quot;, function(val){
    show.innerHTML = val
})
inp.addEventListener('keyup', function(e){
    obj.input = e.target.value
})
&lt;/script&gt;
</code></pre>
<h5 id="6-数据结构">6. 数据结构</h5>
<h6 id="61-数组与链表的区别">6.1 数组与链表的区别</h6>
<ul>
<li>什么是链表</li>
</ul>
<p>链表是一种上一个元素的引用指向下一个元素的存储结构，链表通过指针来连接元素与元素；<br>
链表是线性表的一种，所谓的线性表包含顺序线性表和链表，顺序线性表是用数组实现的，在内存中有顺序排列，通过改变数组大小实现。而链表不是用顺序实现的，用指针实现，<code>在内存中不连续</code>。意思就是说，链表就是将一系列不连续的内存联系起来，将那种碎片内存进行合理的利用，解决空间的问题。所以，链表允许插入和删除表上任意位置上的节点，但是不允许随即存取。链表有很多种不同的类型：单向链表、双向链表及循环链表</p>
<ul>
<li>单向链表</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2019092508112968.png" alt="在这里插入图片描述"><br>
单向链表包含两个域，一个是信息域，一个是指针域。也就是单向链表的节点被分成两部分，一部分是保存或显示关于节点的信息，第二部分存储下一个节点的地址，而最后一个节点则指向一个空值。</p>
<ul>
<li>双向链表</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190925081342576.png" alt="在这里插入图片描述"><br>
从上图可以很清晰的看出，每个节点有2个链接，一个是指向前一个节点（当此链接为第一个链接时，指向的是空值或空列表），另一个则指向后一个节点（当此链接为最后一个链接时，指向的是空值或空列表）。意思就是说双向链表有2个指针，一个是指向前一个节点的指针，另一个则指向后一个节点的指针。</p>
<ul>
<li>循环链表</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190925081447237.png" alt="在这里插入图片描述"><br>
循环链表就是首节点和末节点被连接在一起。循环链表中第一个节点之前就是最后一个节点，反之亦然。</p>
<ul>
<li>数组和链表的区别</li>
</ul>
<p>不同：链表是链式的存储结构；数组是顺序的存储结构。<br>
链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。<br>
<code>链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难</code>；<br>
<code>数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便</code>。</p>
<p>相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。</p>
<ul>
<li>链表的应用、代码实践</li>
</ul>
<p><strong>约瑟夫问题</strong><br>
传说在公园1世纪的犹太战争中，犹太约瑟夫是公元一世纪著名的历史学家。在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人俘虏，于是决定了一个流传千古的自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报到第3人该人就必须自杀，然后再由下一个人重新报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从这个约定，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第_个和第_个位置，于是逃过了这场死亡游戏,你知道安排在了第几个嘛？</p>
<pre><code class="language-js">                        //节点类
			function Node(elemnt) {
				this.item = elemnt;
				this.next = null;
			}
			//循环列表需要修改一下构造函数，和遍历时候的判断条件
			//构造函数如下；希望从后向前遍历，又不想要建立双向链表，就使用循环链表。
			function Llist() {
				this.head = new Node(&quot;1&quot;);
				this.head.next = this.head;
				this.remove = remove;
				this.insert = insert;
				this.find = find;
				this.display = display;
				//..........
			}
			function find(number) {
				var curr = this.head;
				while (curr.item != number) {
					curr = curr.next;
				}
				return curr;
			}
			function insert(element, newElement) {
				var preNode = this.find(element);
				var current = new Node(newElement);
				current.next = preNode.next;
				preNode.next = current;
			}
			function remove() {
				var current = this.head;
				console.log(&quot;remove&quot;);		
                       //跳过两个，杀死一个
			while(current.next.next != null &amp;&amp; current.item!=current.next.next.item){
					var temp = current.next.next;
					current.next.next = temp.next;
					current = temp.next;
					temp.next = null;
				}
				return current;
			}
			function display(flag,current) {
				var crr = this.head;				
				if(flag){
					while(crr.next.item!=&quot;1&quot;){
						console.log(crr.item);
						crr=crr.next;
					}
				   }else{   //最后只剩两个直接输出
					console.log(current.item);
					console.log(current.next.item);
				}
			}
			var Clist = new Llist();
                        //输入排序
			for (var i = 1; i &lt; 41; i++){
				Clist.insert(i.toString(),(i + 1).toString());
			}
                        //先输出所有
			Clist.display(1,null);
                        //通过remove返回最后杀死后的结果其中一个节点
			Clist.display(0,Clist.remove());  //16,31

</code></pre>
<blockquote>
<p>摘自原文链接：https://blog.csdn.net/m0_37631322/article/details/81777855<br>
其他文章：https://zhuanlan.zhihu.com/p/71625297</p>
</blockquote>
<h6 id="62-堆与栈">6.2 堆与栈</h6>
<ul>
<li>栈的定义</li>
</ul>
<ol>
<li>后进者先出，先进者后出，简称 后进先出（<code>LIFO</code>），这就是典型的栈结构。</li>
<li>新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。</li>
<li>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li>
<li>从栈的操作特性来看，是一种 操作受限的线性表，只允许在一端插入和删除数据。</li>
<li>不包含任何元素的栈称为空栈。<br>
栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。</li>
</ol>
<ul>
<li>栈的实现（方法）</li>
</ul>
<ol>
<li><code>push</code>(<code>element</code>)：添加一个（或几个）新元素到栈顶。</li>
<li><code>pop()</code>：移除栈顶的元素，同时返回被移除的元素。</li>
<li><code>peek()</code>：返回栈顶的元素，不对栈做任何修改。</li>
<li><code>isEmpty()</code>：如果栈里没有任何元素就返回 true，否则返回 false。</li>
<li><code>clear()</code>：移除栈里的所有元素。</li>
<li><code>size()</code>：返回栈里的元素个数。</li>
</ol>
<pre><code class="language-js">// Stack类
function Stack() {
  this.items = [];

  // 添加新元素到栈顶
  this.push = function(element) {
    this.items.push(element);
  };
  // 移除栈顶元素，同时返回被移除的元素
  this.pop = function() {
    return this.items.pop();
  };
  // 查看栈顶元素
  this.peek = function() {
    return this.items[this.items.length - 1];
  };
  // 判断是否为空栈
  this.isEmpty = function() {
    return this.items.length === 0;
  };
  // 清空栈
  this.clear = function() {
    this.items = [];
  };
  // 查询栈的长度
  this.size = function() {
    return this.items.length;
  };
  // 打印栈里的元素
  this.print = function() {
    console.log(this.items.toString());
  };
}
</code></pre>
<ul>
<li>测试</li>
</ul>
<pre><code class="language-js">// 创建Stack实例
var stack = new Stack();
console.log(stack.isEmpty()); // true
stack.push(5); // undefined
stack.push(8); // undefined
console.log(stack.peek()); // 8
stack.push(11); // undefined
console.log(stack.size()); // 3
console.log(stack.isEmpty()); // false
stack.push(15); // undefined
stack.pop(); // 15
console.log(stack.size()); // 3
stack.print(); // 5,8,11
stack.clear(); // undefined
console.log(stack.size()); // 0
</code></pre>
<ul>
<li>栈的应用实例：实现一个前端路由以及函数调用栈（在其他模块）</li>
</ul>
<h5 id="7-其他">7. 其他</h5>
<h6 id="71-es5-实现定义常量">7.1 es5 实现定义常量</h6>
<p>这里涉及到了一个方法，<code>Object.defineProperty()</code>，该方法是<code>ES5</code>规范中的，该方法的作用是在对象上定义一个新属性，或者修改对象的一个现有属性，并对该属性加以描述，返回这个对象，我们来看一下浏览器兼容性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Firefox (Gecko)</th>
<th>Chrome</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本支持</td>
<td>4.0 (2)</td>
<td>5</td>
<td>9 [1]</td>
<td>11.60</td>
<td>5.1 [2]</td>
</tr>
</tbody>
</table>
<p><code>IE8</code>是不支持的，不过<code>IE8</code>也对该方法进行了实现，只能在DOM对象上适用，而且有一些独特的地方。<br>
<code>Object.defineProperty()</code>方法可以定义对象属性的数据描述和存储描述，这里我们只讲数据描述符，不对存储描述符讲解，数据描述符有以下选项：</p>
<blockquote>
<p><code>configurable</code><br>
当且仅当该属性的 <code>configurable</code> 为 <code>true</code>时，该属性的描述符（<code>enumerable</code>、<code>value</code>、<code>writable</code>）才能够被改变，也能够被删除。默认为 <code>false</code>。<br>
<code>enumerable</code><br>
当且仅当该属性的 <code>enumerable</code>为 <code>true</code>时，该属性才能够出现在对象的枚举属性中。默认为 <code>false</code>。<br>
<code>value</code><br>
该属性对应的值。可以是任何有效的 <code>JavaScript</code> 值（数值，对象，函数等）。默认为<code>undefined</code>。<br>
<code>writable</code><br>
当且仅当该属性的 <code>writable</code>为<code>true</code>时，该属性才能被赋值运算符改变。默认为<code>false</code>。</p>
</blockquote>
<p>注意，当我们用常规方法定义属性的时候，其除 <code>value</code>以外的数据描述符默认均为<code>true</code>，当我们用 <code>Object.defineProperty()</code> 定义属性的时候，默认为 <code>false</code>。<br>
也就是说，当我们把<code>writable</code> 设置为 false 的时候，该属性是只读的，也就满足了常量了性质，我们把常量封装在<code>CONST</code>命名空间里面：</p>
<pre><code class="language-js">var CONST = {};
Object.defineProperty(CONST, &quot;A&quot;, {
    value: 1,
    writable: false, //设置属性只读
    configurable: true,
    enumerable: true
});
console.log(CONST.A);  //1
CONST.A = 2; //在严格模式下会抛错，在非严格模式下静默失败，修改无效。
</code></pre>
<p>可以对一个变量定义常量：</p>
<pre><code class="language-js">//const cconst=1; 这可以用下面的这行模仿
Object.defineProperty(window, &quot;cconst&quot;, {writable: false, value: 1});
//然后我们尝试修改看看
cconst= 3;
console.log(cconst);    //发现输出是1，发现并改不了
</code></pre>
<p>或者可以通过<code>Object.defineProperty</code>来设置<code>setter</code>和<code>getter</code>函数来实现,封装成一个<code>setConst</code>函数：</p>
<pre><code class="language-js">function setConst(name, value) {
  Object.defineProperty(window, name, {
    set(x) {
      throw new Error(`Assignment to constant variable ${name}`);
    },
    get() {
      return value;
    }
  })
}

setConst('name','jack');
name = 'rose';
//Uncaught Error: Assignment to constant variable name
</code></pre>
<blockquote>
<p>https://www.cnblogs.com/dong-xu/p/6239199.html<br>
https://segmentfault.com/a/1190000016344599<br>
https://www.zhihu.com/question/277800597<br>
https://www.cnblogs.com/chen-cong/p/7862832.html</p>
</blockquote>
<h6 id="73-javascript实现前端路由">7.3 JavaScript实现前端路由</h6>
<p>实现是有两种方法：一种是 在数组后面进行增加与删除，另外一种是 利用栈的后进先出原理。</p>
<ul>
<li>在数组最后进行 增加与删除</li>
</ul>
<p>通过监听路由的变化事件 <code>hashchange</code>，与路由的第一次加载事件<code>load</code>，判断如下情况：</p>
<ol>
<li><code>url</code> 存在于浏览记录中即为后退，后退时，把当前路由后面的浏览记录删除。</li>
<li><code>url</code>不存在于浏览记录中即为前进，前进时，往数组里面<code>push</code> 当前的路由。</li>
<li><code>url</code>在浏览记录的末端即为刷新，刷新时，不对路由数组做任何操作。</li>
</ol>
<p>另外，应用的路由路径中可能允许相同的路由出现多次（例如 <code>A -&gt; B -&gt; A</code>），所以给每个路由添加一个<code>key</code>值来区分相同路由的不同实例。</p>
<blockquote>
<p>注意：这个浏览记录需要存储在 sessionStorage 中，这样用户刷新后浏览记录也可以恢复。</p>
</blockquote>
<p>实现代码：</p>
<pre><code class="language-js">// 路由构造函数
function Router() {
        this.routes = {}; //保存注册的所有路由
        this.routerViewId = &quot;#routerView&quot;; // 路由挂载点 
        this.stackPages = true; // 多级页面缓存
        this.history = []; // 路由历史
}

Router.prototype = {
        init: function(config) {
            var self = this;
            //页面首次加载 匹配路由
            window.addEventListener('load', function(event) {
                // console.log('load', event);
                self.historyChange(event)
            }, false)

            //路由切换
            window.addEventListener('hashchange', function(event) {
                // console.log('hashchange', event);
                self.historyChange(event)
            }, false)

        },
        // 路由历史纪录变化
        historyChange: function(event) {
            var currentHash = util.getParamsUrl();
            var nameStr = &quot;router-history&quot;
            this.history = window.sessionStorage[nameStr] ? JSON.parse(window.sessionStorage[nameStr]) : []

            var back = false, // 后退
                refresh = false, // 刷新
                forward = false, // 前进
                index = 0,
                len = this.history.length;

            // 比较当前路由的状态，得出是后退、前进、刷新的状态。
            for (var i = 0; i &lt; len; i++) {
                var h = this.history[i];
                if (h.hash === currentHash.path &amp;&amp; h.key === currentHash.query.key) {
                    index = i
                    if (i === len - 1) {
                        refresh = true
                    } else {
                        back = true
                    }
                    break;
                } else {
                    forward = true
                }
            }
            if (back) {
                 // 后退，把历史纪录的最后一项删除
                this.historyFlag = 'back'
                this.history.length = index + 1
            } else if (refresh) {
                 // 刷新，不做其他操作
                this.historyFlag = 'refresh'
            } else {
                // 前进，添加一条历史纪录
                this.historyFlag = 'forward'
                var item = {
                    key: currentHash.query.key,
                    hash: currentHash.path,
                    query: currentHash.query
                }
                this.history.push(item)
            }
            // 如果不需要页面缓存功能，每次都是刷新操作
            if (!this.stackPages) {
                this.historyFlag = 'forward'
            }
            window.sessionStorage[nameStr] = JSON.stringify(this.history)
        },
    }
</code></pre>
<ul>
<li>利用栈的 后进者先出，先进者后出 原理</li>
</ul>
<p>首先<code>javascript</code>实现一个顺序栈：</p>
<pre><code class="language-js">// 基于数组实现的顺序栈
class ArrayStack {
  constructor(n) {
      this.items = [];  // 数组
      this.count = 0;   // 栈中元素个数
      this.n = n;       // 栈的大小
  }

  // 入栈操作
  push(item) {
    // 数组空间不够了，直接返回 false，入栈失败。
    if (this.count === this.n) return false;
    // 将 item 放到下标为 count 的位置，并且 count 加一
    this.items[this.count] = item;
    ++this.count;
    return true;
  }
  
  // 出栈操作
  pop() {
    // 栈为空，则直接返回 null
    if (this.count == 0) return null;
    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
    let tmp = items[this.count-1];
    --this.count;
    return tmp;
  }
}
</code></pre>
<ul>
<li>栈的经典应用: 函数调用栈</li>
</ul>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。</p>
<pre><code class="language-js">function add(x, y) {
   let sum = 0;
   sum = x + y;
   return sum;
}

function main() {
   let a = 1; 
   let ret = 0;
   let res = 0;
   ret = add(3, 5);
   res = a + ret;
   console.log(&quot;res: &quot;, res);
   reuturn 0;
}

main();
</code></pre>
<p>上面代码也很简单，就是执行<code>main</code>函数求和，<code>main</code> 函数里面又调用了<code>add</code> 函数，先调用的先进入栈。<br>
执行过程如下：<br>
<img src="https://img-blog.csdnimg.cn/20190926083856500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>用两个栈实现浏览器的前进、后退功能。</li>
</ul>
<p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。<br>
比如你顺序查看了<code>a</code>，<code>b</code>，<code>c</code> 三个页面，我们就依次把 <code>a</code>，<code>b</code>，<code>c</code> 压入栈，这个时候，两个栈的数据如下：<br>
<img src="https://img-blog.csdnimg.cn/20190926084110353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：<br>
<img src="https://img-blog.csdnimg.cn/20190926084155679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：<br>
<img src="https://img-blog.csdnimg.cn/20190926084221164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：<br>
<img src="https://img-blog.csdnimg.cn/20190926084251523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
其实就是在第一个方法的代码里面， 添加多一份路由历史纪录的数组即可，对这两份历史纪录的操作如上面示例图所示即可，也就是对数组的增加和删除操作而已。</p>
<h6 id="72-const-声明的变量不可以改变声明的对象属性为何可以改变">7.2 const 声明的变量不可以改变，声明的对象属性为何可以改变</h6>
<p>因为对象是引用类型的，使用<code>const</code>定义的变量中保存的仅是对象的指针，这就意味着，<code>const</code>仅保证指针不发生改变，修改对象的属性不会改变对象的指针，所以是被允许的。也就是说<code>const</code>定义的引用类型只要指针不发生改变，其他的不论如何改变都是允许的。<br>
<code>const</code>声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p>
<h6 id="73-jquery-与-vue之间的对比">7.3 jQuery 与 vue之间的对比</h6>
<p><code>jquery</code> 是以操作<code>dom</code>为主，做了数据处理之后还需要对<code>dom</code>进行操作。<code>vue.js</code>是以操作数据为主，不操作<code>dom</code>，也就是传说中的双向数据绑定，你只需要操作数据就好，<code>dom</code>自动更新。这只是对初学者来说最大的不同。<code>jquery</code>只是一个类库，只是提供了很多的方法，不能算框架，而<code>vue.js</code>是一个框架，有一套完整的体系。</p>
<h6 id="74-从输入url到看到页面发生的全过程">7.4 从输入URL到看到页面发生的全过程</h6>
<p>总体来看主要是下面的流程：<br>
①、浏览器构建HTTP Request请求<br>
②、网络传输<br>
③、务器构建HTTP Response 响应<br>
④、网络传输<br>
⑤浏览器渲染页面<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMueGlhb2h1b2NoYWkuc2l0ZS9ibG9nL2h0dHBVcmwxLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>
1、首先浏览器主进程接管，开了一个下载线程。</p>
<p>2、然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</p>
<p>3、将下载完的内容转交给Renderer进程管理。</p>
<p>4、Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</p>
<p>5、解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</p>
<p>6、css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</p>
<p>绘制结束后，关闭TCP连接，过程有四次挥手。</p>
<h6 id="75-三次握手四次挥手">7.5 三次握手，四次挥手</h6>
<h6 id="76-数组去重">7.6 数组去重</h6>
<ol>
<li>可以使用<code>set</code>对象的特性进行去重：</li>
</ol>
<pre><code class="language-js">// 去除数组的重复成员
[...new Set(array)]
</code></pre>
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<pre><code class="language-js">[...new Set('ababbc')].join('')
// &quot;abc&quot;
</code></pre>
<h6 id="78-原生js无缝滚动效果的简单实现">7.8 原生Js无缝滚动效果的简单实现</h6>
<p>无缝滚动，前提条件是子box的高度要大于父box的高度，这样才有必要去滚动，否则直接展示就可以了。增添了鼠标移入停止和移出继续滚动的效果。增加了间歇性无缝滚动效果。</p>
<pre><code class="language-html">&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;&lt;/span&gt;&lt;pre name=&quot;code&quot; class=&quot;html&quot;&gt;&lt;!-- 
Time:2016.8.5
Author:Joel
1.html标签&lt;marquee&gt;，可以考察一下在html5标准下使用什么来实现
可以设置滚动区域的宽高
behavior ＝ “alternate”  两端之间来回滚动
behavior ＝ “scroll”  由一端到另一端，重复滚动
behavior ＝ “slide”  由一端到另一端，不重复
direction  滚动的方向（down，up，left，right）
loop  （滚动的次数，loop ＝ －1 表示无限滚动，默认为－1）
scrollamount  设置活动字幕的滚动速度
scrolldelay  设置活动字幕两次滚动之间的延迟时间
2.onmouseover = &quot;this.stop()&quot;
3.onmouseout = &quot;this.start()&quot;
4.父元素设置高度 滚动元素也需要设置高度 而且滚动元素的高度必须大于父元素 这样才能滚动
5.setTimeout(表达式，延迟时间) 仅执行1次
--&gt;
&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;&gt;
	&lt;title&gt;InfoRoll&lt;/title&gt;
	&lt;style&gt;
		.box{
			width:300px;
			border: 1px solid #8f8f8f;
		}
		dl dt{
			text-align: center;
			margin-bottom: 20px;
		}
 
		.box1{
			height:150px;
			width:200px;
			border:1px solid #8f8f8f;
 
			margin: 0 auto;
			overflow: hidden;
		}
		ul{
            height: 200px; 
		}
		ul li{
			height: 24px;
		}
		p{
			text-align: center;
		}
	&lt;/style&gt;
 
	&lt;script type=&quot;text/javascript&quot;&gt;
	
 
	window.onload = function(){
		//无缝滚动效果
		// var box1 = document.getElementsByClassName(&quot;box1&quot;);
		// var com1 = document.getElementsByClassName(&quot;com1&quot;);
		// var com2 = document.getElementsByClassName(&quot;com2&quot;);
 
		// com2[0].innerHTML = com1[0].innerHTML;
		// var myscr = function(){
  //       	if(box1[0].scrollTop &gt;= com1[0].offsetHeight){
		// 		box1[0].scrollTop = 0;
		// 	}
		// 	else{
		// 		box1[0].scrollTop++;
		// 	}        	
  //       }
 
  //       //这里出现了很诡异的问题。如果使用function myscr(){}，传入&quot;myscr()&quot;会一直报错，不知道是什么问题。
 
  //       var timer = setInterval(myscr,50);
 
  //       box1[0].onmouseover = function(){
  //       	clearInterval(timer);
  //       }
  //       box1[0].onmouseout = function(){  
  //           timer = setInterval(myscr,50); 	
  //       }	
     	//间歇性滚动效果
		var box1 = document.getElementsByClassName(&quot;box1&quot;);
		box1[0].scrollTop = 0;
		var liHeight = 24;
		var timer;
		function startMove(){
		   box1[0].scrollTop++;
		    timer = setInterval(myscr,50);
		}
	    function myscr(){
	       if(box1[0].scrollTop % liHeight == 0){
	       	  clearInterval(timer);
	       	  setTimeout(startMove,2000);
	       	  }
	       	else{
	       		box1[0].scrollTop++;
	       		if(box1[0].scrollTop &gt;= box1[0].scrollHeight / 2){
	       			box1[0].scrollTop = 0;
	       		}
	       	}
	    }
	    setTimeout(startMove,2000);
	}
 
	&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;!--几种滚动实例--&gt;
	&lt;!-- &lt;section class = &quot;box&quot;&gt;
	  &lt;dl&gt;
	  	&lt;dt&gt;默认滚动&lt;/dt&gt;
	  	&lt;dd&gt;&lt;marquee&gt;默认滚动&lt;/marquee&gt;&lt;/dd&gt;
	  &lt;/dl&gt;
	  &lt;dl&gt;
	  	&lt;dt&gt;文字滚动(向右)&lt;/dt&gt;
	  	&lt;dd&gt;&lt;marquee direction=&quot;right&quot;&gt;向右走...&lt;/marquee&gt;&lt;/dd&gt;
	  &lt;/dl&gt;
	  &lt;dl&gt;
	  	&lt;dt&gt;文字滚动(来回滚动)&lt;/dt&gt;
	  	&lt;dd&gt;&lt;marquee behavior = &quot;alternate&quot; loop = &quot;－1&quot; scrollamount = &quot;20&quot;&gt;来回滚动...&lt;/marquee&gt;&lt;/dd&gt;
	  &lt;/dl&gt;
	  &lt;dl&gt;
	  	&lt;dt&gt;向上滚....&lt;/dt&gt;
	  	&lt;dd&gt;&lt;marquee direction=&quot;up&quot; width = &quot;300px&quot; height = &quot;100px&quot;&gt;向上走起...&lt;/marquee&gt;&lt;/dd&gt;
	  &lt;/dl&gt;
	&lt;/section&gt; --&gt;
 
	&lt;!--实现无缝滚动效果--&gt;
	&lt;div class = &quot;box1&quot;&gt;
		&lt;ul class = &quot;com1&quot;&gt;
          &lt;li&gt;1&lt;/li&gt;
          &lt;li&gt;2&lt;/li&gt;
          &lt;li&gt;3&lt;/li&gt;
          &lt;li&gt;4&lt;/li&gt;
          &lt;li&gt;5&lt;/li&gt;
          &lt;li&gt;6&lt;/li&gt;
          &lt;li&gt;7&lt;/li&gt;
          &lt;li&gt;8&lt;/li&gt;
          &lt;li&gt;9&lt;/li&gt;
		&lt;/ul&gt;
		&lt;ul class = &quot;com2&quot;&gt;
		&lt;/ul&gt;
 	&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-html">&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;
&lt;/span&gt;
</code></pre>
<pre><code class="language-html">&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);&quot;&gt;小结：&lt;/span&gt;
</code></pre>
<blockquote>
<p>https://blog.csdn.net/my_coding2015/article/details/52133364</p>
</blockquote>
<h6 id="79-如何实现一个弹幕">7.9 如何实现一个弹幕</h6>
<h6 id="710-js数组的堆与栈实现">7.10 js数组的堆与栈实现</h6>
<h6 id="711-4-如果有成千上万个菜单如何绑定点击事件">7.11 4. 如果有成千上万个菜单，如何绑定点击事件</h6>
<p>第一种：<code>for</code>循环,会大大消耗性能：</p>
<pre><code class="language-js">            //获取所有li的节点
            var list =  document.getElementsByTagName(&quot;li&quot;);
            //给每个li绑定事件
            for(var i = 0;i&lt;list.length;i++){
                list[i].ondblclick = function(){
                    //弹出对应的li节点里面的内容
                    alert(this.innerHTML);
                    this.style.color = &quot;red&quot;;
             }
</code></pre>
<p>或者循环中使用立即执行函数来实现。</p>
<pre><code class="language-js">  var ulInLis = document.getElementById(&quot;ul&quot;).getElementsByTagName(&quot;li&quot;);
        for ( var i = 0; i &lt; ulInLis.length; i++) {
            (function() {
                var l = i;
                ulInLis[l].onclick = function() {
                    console.log(l);
                    console.log(ulInLis[l]);
                }
            })();
        }
</code></pre>
<p>第二种：在父级通过<code>addEventListener</code>绑定点击事件，并阻止事件冒泡：</p>
<pre><code class="language-js">        let ulDom = document.getElementsByTagName('ul')
        ulDom[0].addEventListener('click', (dom) =&gt; {
            // dom.preventDefault()
            dom.target.onclick = (de) =&gt; {
                alert(de.target.innerText)
            }
        }, true)
</code></pre>
<h5 id="8-css-相关">8 css 相关</h5>
<h6 id="81-实现元素的水平垂直居中">8.1 实现元素的水平垂直居中</h6>
<p>第一种：定位+负边距</p>
<pre><code class="language-css">.box{
    position:absolute;
    left:50%;
    top:50%;
    margin-left:-150px;
    margin-top:-100px;
    padding:20px;
    width:300px;
    height:200px;
    background:#41D7FB;
}
</code></pre>
<p>第二种：定位+自适应边距</p>
<pre><code class="language-css">.box{
    position:absolute;
    left:0;
    right:0;
    top:0;
    bottom:0;
    margin:auto;
    padding:20px;
    width:300px;
    height:200px;
    background:#41D7FB;
}
</code></pre>
<p>第三种： 定位+<code>CSS3</code>位移</p>
<pre><code class="language-css">.box{
    position:absolute;
    left:50%;
    top:50%;
    transform: translate(-50%, -50%);
    padding:20px;
    width:300px;
    height:200px;
    background:#41D7FB;
}
</code></pre>
<p>第四种：<code>Flex</code>布局实现</p>
<pre><code class="language-css">html{
    display: flex;
    height: 100%;
    justify-content: center;
    align-items:center;
}
.box{
    padding:20px;
    width:300px;
    height:200px;
    background:#41D7FB;
}
</code></pre>
<p>第五种：<code>table-cell</code>配合<code>inline-block</code></p>
<pre><code class="language-css">.table{
    display:table;
    width:100%;
    height:600px;
}
.table-row{
    display: table-row;
}
.table-cell{
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

.box{
    display: inline-block;
    padding:20px;
    width:300px;
    height:200px;
    background:#41D7FB;
}
</code></pre>
<h6 id="82-用伪类清除浮动">8.2 用伪类清除浮动</h6>
<p>之前我们一般使用</p>
<pre><code class="language-html">&lt;div sytle=&quot;clear:both&quot;&gt;&lt;/div&gt;
</code></pre>
<p>来解决，但这样会增加无语义的标签，下面是用after伪类实现，兼容多种浏览器:</p>
<pre><code class="language-css">.clearfix:after{
     content:&quot;.&quot;;  
     display:block;
     height:0;
     clear:both;
     visibility:hidden;
}
</code></pre>
<p>为兼容<code>IE6</code>,<code>IE7</code>，因为<code>ie6</code>,<code>ie7</code>不能用<code>after</code>伪类。加上下面代码:</p>
<pre><code class="language-css">.clearfix{zoom:1}
</code></pre>
<h5 id="9-git">9 git</h5>
<p>创建分支：<code>git branch b1</code><br>
切换分支：<code>git checkout b1</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebGIS实战系列 三 项目的重新开始]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webgis-shi-zhan-xi-lie-san-xiang-mu-de-chong-xin-kai-shi</id>
        <link href="https://jiegiser.github.io/newBlog/post/webgis-shi-zhan-xi-lie-san-xiang-mu-de-chong-xin-kai-shi">
        </link>
        <updated>2019-12-04T12:05:35.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="说明">说明</h4>
<p>离上次更新该系列文章已经快四个多月。这段时间工作上比较忙以及自己也换了份工作就没有更新过相关内容，最近在做一个管网系统，自己也写了一些小的<code>demo</code>，<code>github</code> <a href="https://github.com/jiegiser/ol5_example">地址</a>（欢迎star），里面有一些用到的天地图的<code>key</code>跟<code>bing</code>地图的<code>key</code>需要大家自己去获取。最近我打算会陆陆续续的更新完这个系列的文章。将自己在项目上的经验进行分享。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="说明">说明</h4>
<p>离上次更新该系列文章已经快四个多月。这段时间工作上比较忙以及自己也换了份工作就没有更新过相关内容，最近在做一个管网系统，自己也写了一些小的<code>demo</code>，<code>github</code> <a href="https://github.com/jiegiser/ol5_example">地址</a>（欢迎star），里面有一些用到的天地图的<code>key</code>跟<code>bing</code>地图的<code>key</code>需要大家自己去获取。最近我打算会陆陆续续的更新完这个系列的文章。将自己在项目上的经验进行分享。</p>
<h2 id="-more-"><!-- more --></h2>
<p>上面的项目截图：</p>
<p>界面搭建使用模板   <a href="https://panjiachen.github.io/vue-element-admin">vue-element-admin</a></p>
<p>该项目是Geoserver+openlayers5的一些例子，<br>
完成的功能如下：</p>
<h4 id="1-地图控件">1. 地图控件</h4>
<pre><code>1.1  导航控件
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191119080035550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
1.2  zoomslider<br>
<img src="https://img-blog.csdnimg.cn/20191119080116925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
1.3 鼠标位置</p>
<h4 id="2-属性查询">2. 属性查询</h4>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191119080228618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="3-空间查询">3. 空间查询</h4>
<p><img src="https://img-blog.csdnimg.cn/20191119080405552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20191119080441815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-在线编辑">4. 在线编辑</h4>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191119080323688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="5-测量">5. 测量</h4>
<pre><code>5.1 长度测量

5.2 面积测量
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191119080341942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
5.3 面积测量填充</p>
<h4 id="6-加载天地图">6. 加载天地图</h4>
<h4 id="7-加载天地图投影转换">7. 加载天地图投影转换</h4>
<h4 id="8-缓冲区绘制turf">8. 缓冲区绘制（turf）</h4>
<h4 id="9-拉框放大缩小">9. 拉框放大缩小</h4>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191119080523328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="10-点生成缓冲范围查询">10. 点生成缓冲范围查询（√）</h4>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191125171230587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="11-轨迹回放">11. 轨迹回放（√）</h4>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191126124814612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="12-位置监控">12. 位置监控（√）</h4>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191127140600667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="13-面添加标注">13. 面添加标注（√）</h4>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191127140454748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<hr>
<p>设置高亮显示关键代码：</p>
<pre><code class="language-js">if (this.resultVterSource.clear) {
  this.resultVterSource.clear();
}
const feature = this.vectorSource.getFeatureById(item.id);
this.resultVterSource.addFeature(feature);
// 设置显示区域偏移
this.getMap.getView().fit(this.resultVterSource.getExtent(), {
  padding: [0, 0, 0, document.body.clientWidth * 0.5]
});
</code></pre>
]]></content>
    </entry>
</feed>