<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jiegiser.github.io/newBlog</id>
    <title>jiegiser的博客</title>
    <updated>2020-06-16T07:51:53.323Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jiegiser.github.io/newBlog"/>
    <link rel="self" href="https://jiegiser.github.io/newBlog/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jiegiser.github.io/newBlog/images/avatar.png</logo>
    <icon>https://jiegiser.github.io/newBlog/favicon.ico</icon>
    <rights>All rights reserved 2020, jiegiser的博客</rights>
    <entry>
        <title type="html"><![CDATA[echarts加载离线百度地图]]></title>
        <id>https://jiegiser.github.io/newBlog/post/echarts-jia-zai-chi-xian-bai-du-di-tu</id>
        <link href="https://jiegiser.github.io/newBlog/post/echarts-jia-zai-chi-xian-bai-du-di-tu">
        </link>
        <updated>2020-06-15T23:50:05.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做一个国网的一个项目，需要实现一些热力图以及冒泡式的标注等；而且需要在内网使用，感觉使用 echarts 就可以简单的实现无需加载类似 openlayers ，leaflet 等 webgis 框架然后再发布地图服务实现。下面就写一下实现的过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做一个国网的一个项目，需要实现一些热力图以及冒泡式的标注等；而且需要在内网使用，感觉使用 echarts 就可以简单的实现无需加载类似 openlayers ，leaflet 等 webgis 框架然后再发布地图服务实现。下面就写一下实现的过程。</p>
<!-- more -->
<h3 id="实现思路">实现思路</h3>
<ul>
<li>百度地图API文件</li>
<li>创建本地工具资源文件getModules.js</li>
<li>地图瓦片</li>
</ul>
<h3 id="百度地图api文件">百度地图API文件</h3>
<h4 id="下载-api-文件">下载 API 文件</h4>
<p>首先需要准备离线的百度地图 API 文件，浏览器打开地址：http://api.map.baidu.com/api?v=2.0，不需要申请 key，当然申请也是可以的；打开之后如下：</p>
<pre><code class="language-js">(function(){ 
   window.BMap_loadScriptTime = (new Date).getTime(); 
   document.write('&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/getscript?v=2.0&amp;ak=&amp;services=&amp;t=20200327103013&quot;&gt;&lt;/script&gt;');
})();
</code></pre>
<p>复制 script 加载的 src 地址，在浏览器中打开；如下：<br>
<img src="https://img-blog.csdnimg.cn/20200518161921829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
然后复制里面的内容，保存到自己的项目中命名为：baiduApi.js；这个名字随意起；</p>
<h4 id="修改-api-文件">修改 API 文件</h4>
<p>然后需要修改里面的加载方式，进行加载我们本地的资源；首先需要去掉ak验证：搜索charset = 'utf-8'，添加 if (/^http/.test(a)) return;如下：<br>
<img src="https://img-blog.csdnimg.cn/20200518162304772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code class="language-js">  function pa(a, b) {
    // 下面是需要添加的代码
    // 如果是调用外部资源就退出去
    if (/^http/.test(a)) return;
    if (b) {
      var c = (1E5 * Math.random()).toFixed(0);
      z._rd[&quot;_cbk&quot; + c] = function(a) {
        b &amp;&amp; b(a);
        delete z._rd[&quot;_cbk&quot; + c]
      };
      a += &quot;&amp;callback=BMap._rd._cbk&quot; + c
    }
    var d = K(&quot;script&quot;, {
      type: &quot;text/javascript&quot;
    });
    d.charset = &quot;utf-8&quot;;
    d.src = a;
    d.addEventListener ? d.addEventListener(&quot;load&quot;,
    function(a) {
      a = a.target;
      a.parentNode.removeChild(a)
    },
    q) : d.attachEvent &amp;&amp; d.attachEvent(&quot;onreadystatechange&quot;,
    function() {
      var a = window.event.srcElement;
      a &amp;&amp; (&quot;loaded&quot; == a.readyState || &quot;complete&quot; == a.readyState) &amp;&amp; a.parentNode.removeChild(a)
    });
    setTimeout(function() {
      document.getElementsByTagName(&quot;head&quot;)[0].appendChild(d);
      d = p
    },
    1)
  }
</code></pre>
<blockquote>
<p>可以将复制的百度地图API的代码在 https://www.bejson.com/jshtml_format/这里进行格式化；这样看的比较清楚。</p>
</blockquote>
<h3 id="创建本地工具资源文件getmodulesjs">创建本地工具资源文件getModules.js</h3>
<p>继续在我们保存的百度地图API中搜索 domain.main_domain_cdn.baidu[0]，找到使用它定义的z.ma，修改为z.ma = '';<br>
<img src="https://img-blog.csdnimg.cn/20200518162606186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code class="language-js">  z.dz = window.HOST_TYPE || &quot;0&quot;;
  z.url = z.l0[z.dz];
  z.Dp = z.url.proto + z.url.domain.baidumap + &quot;/&quot;;
  z.oc = z.url.proto + (&quot;2&quot; == z.dz ? z.url.domain.main_domain_nocdn.other: z.url.domain.main_domain_nocdn.baidu) + &quot;/&quot;;
  z.ma = z.url.proto + (&quot;2&quot; == z.dz ? z.url.domain.main_domain_cdn.other[0] : z.url.domain.main_domain_cdn.baidu[0]) + &quot;/&quot;;
  // 需要添加的代码
  z.ma = '';
  z.hj = z.url.proto + z.url.domain.main_domain_cdn.webmap[0] + &quot;/&quot;;
</code></pre>
<h4 id="加载模块短路处理">加载模块短路处理</h4>
<p>首先创建一个我们本地工具模块保存的脚本，本项目中命名为getModules.js；<br>
然后在我们保存的百度地图API中搜索搜索 <code>&amp;mod=</code>，替换。那个 console.log(a),是为了给后面创建getModules.js，用于打印出需要加载的工具模块；注意这里的函数 pa，就是我们前面去掉ak验证：添加 if (/^http/.test(a)) return;的方法。<br>
<img src="https://img-blog.csdnimg.cn/20200518162905207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code class="language-js">    load: function(a, b, c) {
      var d = this.kb(a);
      if (d.Cd == this.Kj.lq) c &amp;&amp; b();
      else {
        if (d.Cd == this.Kj.DG) {
          this.zK(a);
          this.NN(a);
          var e = this;
          e.PC == q &amp;&amp; (e.PC = o, setTimeout(function() {
            for (var a = [], b = 0, c = e.Rd.Ln.length; b &lt; c; b++) {
              var d = e.Rd.Ln[b],
              l = &quot;&quot;;
              ja.Zy.tK(d) ? l = ja.Zy.get(d) : (l = &quot;&quot;, a.push(d + &quot;_&quot; + Cc[d]));
              e.Rd.ew.push({
                fN: d,
                YE: l
              })
            }
            e.PC = q;
            e.Rd.Ln.length = 0;
            // 需要修改的地方
            // 0 == a.length ? e.kL() : pa(e.wG.nQ + &quot;&amp;mod=&quot; + a.join(&quot;,&quot;))
            0 == a.length ? e.kL() : pa(&quot;../../public/data/getmodules.js&quot;)
            console.log(a)
          },
          1));
          d.Cd = this.Kj.XP
        }
        d.av.push(b)
      }
    },
</code></pre>
<h4 id="创建本地工具资源文件getmodulesjs-2">创建本地工具资源文件getModules.js</h4>
<p>在这里面放API需要调用的模块，上面打印的数组a里面是需要请求的模块，打印出来，通过下面方式获取，放到getmodules.js,例如 canvablepath_lf2t4w, 通过http://api0.map.bdimg.com/getmodules?=v=2.0&amp;t=20140707&amp;mod=canvablepath_lf2t4w下载。<br>
<img src="https://img-blog.csdnimg.cn/20200518163523382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
复制内容保存到getmodules.js文件中，注意：将我们上一步骤打印的a中所有的内容都需要按照这种方法保存到getmodules.js文件中；</p>
<h3 id="下载地图瓦片">下载地图瓦片</h3>
<p>首先我们的下载思路是获取到每个瓦片的请求地址，然后通过nodejs进行下载图片；下面只是做了简单的下载瓦片的方法，下载的内容还有有局限性，如果需要比较全的数据可以找一些瓦片地图的下载工具进行下载。</p>
<h4 id="获取瓦片请求地址">获取瓦片请求地址</h4>
<p>在保存的百度地图API脚本中搜索getTilesUrl方法：<br>
<img src="https://img-blog.csdnimg.cn/20200518164211809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
修改如下</p>
<pre><code class="language-js">  Kd.getTilesUrl = function(a, b, c) {
    var d = a.x,
    a = a.y,
    e = Tb(&quot;normal&quot;),
    f = 1,
    c = Jd[c];
    this.map.Vx() &amp;&amp; (f = 2);
    d = this.map.gb.Mw(d, b).ns;
    var nUrl = (Id[Math.abs(d + a) % Id.length] + &quot;?qt=vtile&amp;x=&quot; + (d + &quot;&quot;).replace(/-/gi, &quot;M&quot;) + &quot;&amp;y=&quot; + (a + &quot;&quot;).replace(/-/gi, &quot;M&quot;) + &quot;&amp;z=&quot; + b + &quot;&amp;styles=&quot; + c + &quot;&amp;scaler=&quot; + f + (6 == x.da.la ? &quot;&amp;color_dep=32&amp;colors=50&quot;: &quot;&quot;) + &quot;&amp;udt=&quot; + e + &quot;&amp;from=jsapi2_0&quot;).replace(/-(\d+)/gi, &quot;M$1&quot;)
    window.xxxUrls = window.xxxUrls || [];
    var nname = 'tiles/' + b + '/' + d + '/' + a + '.png'
    var urlArr = {
      url: nUrl,
      name: nname
    }
    window.xxxUrls.push(urlArr)
    return nUrl
  };
</code></pre>
<p>我们将每个瓦片请求的地址存放到了window.xxxUrls 数组中；在浏览器中打印该数组：<br>
<img src="https://img-blog.csdnimg.cn/20200518164431286.png" alt="在这里插入图片描述"><br>
先对地图进行拖拽，确保想要的省市都出现在窗口可视范围内，然后会将每个瓦片请求的地址保存到window.xxxUrls 数组中；不过需要放大到每个级别然后进行拖拽显示完成整个需要下载的范围。这样保证将指定级别获取所有范围图片的地址。</p>
<h4 id="下载瓦片">下载瓦片</h4>
<p>首先获取到window.xxxUrls 数组中的数据，可以在前端发送 ajax请求，然后进行下载。这里我只做了简单的下载，直接在浏览器中打印window.xxxUrls 数组，然后复制内容，到下面down.js文件：<br>
<img src="https://img-blog.csdnimg.cn/20200518165154458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这里的imgArr 就是window.xxxUrls 数组中的数据；</p>
<pre><code class="language-js">const imgArr = [{&quot;url&quot;:&quot;http://maponline3.bdimg.com/tile/?qt=vtile&amp;x=6327&amp;y=2356&amp;z=15&amp;styles=pl&amp;scaler=1&amp;udt=20200514&amp;from=jsapi2_0&quot;,&quot;name&quot;:&quot;tiles/15/6327/2356.png&quot;}]
const newArr = new Set(imgArr); //去重
const finalArr = Array.from(newArr); 
//创建目录
const fs = require('fs');
// const axios = require('axios');

const request = require('request');
const path = require('path')

const hostdir = &quot;./&quot;;
function mkdirSync(dirname) {
    if (fs.existsSync(dirname)) {
        return true;
    } else {
        if (mkdirSync(path.dirname(dirname))) {   
            fs.mkdirSync(dirname);
            return true;
        }
    }
    return false
}
var n = 0;
for (const item of finalArr) {
  const last = item.name.lastIndexOf('/')
  if (last &gt; 0) {
    const name = item.name.substr(last + 1)
    const dir = item.name.substr(0, last)
    const dstpath = hostdir + dir + '/' + name
    if (name.length &amp;&amp; dir.length &amp;&amp; !fs.existsSync(dstpath)) {
      if (mkdirSync(hostdir + dir)) {
        ++ n;
        request(item.url).pipe(fs.createWriteStream(dstpath))
      }
    }
  }
}
</code></pre>
<p>然后运行命令 node down.js，执行完之后就会看到下载的tiles文件夹：<br>
<img src="https://img-blog.csdnimg.cn/20200518165321646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="使用离线瓦片进行加载">使用离线瓦片进行加载</h4>
<p>还是找到我们刚刚修改的getTilesUrl的位置，修改如下：<br>
注意加载的tiles文件夹的地址要写正确。</p>
<pre><code class="language-js">  Kd.getTilesUrl = function(a, b, c) {
    var x = a.x
    var y = a.y
    var e = 1
    var z = a
    return 'tiles/'+b+'/'+x+'/'+y+'.png';
  };
</code></pre>
<p>这样就完成了百度地图的离线加载。</p>
<h4 id="echart-中加载百度地图">echart 中加载百度地图</h4>
<p>首先项目中使用我们下载的百度地图api文件，有两种方式，一种是在public文件夹下的index.html中直接使用：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
  &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;./data/baiduapi.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;noscript&gt;
    &lt;strong&gt;We're sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn't work properly without JavaScript enabled.
      Please enable it to continue.&lt;/strong&gt;
  &lt;/noscript&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;!-- built files will be auto injected --&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>另一种是直接在项目的入口文件引入：</p>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
import '../public/data/baiduapi.js'

Vue.config.productionTip = false

new Vue({
  render: h =&gt; h(App),
}).$mount('#app')
</code></pre>
<p>该项目中使用vue，整体代码如下：</p>
<pre><code class="language-js">&lt;template&gt;
  &lt;div style=&quot;position: absolute;left: 0px; top: 0px;width: 100%;height: 100%;&quot;&gt;
    &lt;div id=&quot;main&quot; style=&quot;height: 100%;width: 100%;&quot;&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import echarts from 'echarts';
import { geoCoordMap, datas } from './data';
import 'echarts/extension/bmap/bmap';
export default {
  name: 'allView',
  data() {
    return {
      options: {},
      mapChart: null,
    };
  },
  computed: {
    convertedData() {
      return [this.convertData(datas), this.convertData(datas.sort((a, b) =&gt; { b.value - a.value; }).slice(0, 6))];
    }
  },
  created() {
    this.option = {
      // 百度地图api的设置
      bmap: {
        center: [116.404, 39.915],
        zoom: 15,
        roam: true,
      },
      series: [
        {
          name: '全部',
          type: 'scatter',
          symbol: 'pin',
          coordinateSystem: 'bmap',
          data: this.convertData(datas),
          symbolSize: val =&gt; {
            return val[2];
          },
          label: {
            normal: {
              formatter: '{@[2]}',
              show: true,
              textStyle: {
                color: '#fff',
                fontSize: 9
              }
            },
            emphasis: {
              show: true
            }
          },
          itemStyle: {
            normal: {
              color: '#F62157'
            }
          },
          zlevel: 6
        }
      ]
    };
  },
  mounted() {
    this.$nextTick(() =&gt; {
      this.mapChart = echarts.init(document.getElementById('main'));
      this.mapChart.setOption(this.option);
      this.mapChart.on('click', 'series.scatter', item =&gt; {
        console.log(item);
      });
    });
  },
  methods: {
    convertData(data) {
      const res = [];
      for (let i = 0; i &lt; data.length; i++) {
        const geoCoord = geoCoordMap[data[i].name];
        if (geoCoord) {
          res.push({
            name: data[i].name,
            value: geoCoord.concat(data[i].value),
            imgUrl: data[i].imgUrl
          });
        }
      }
      console.log(res);
      return res;
    }
  }
};
&lt;/script&gt;
</code></pre>
<p>data.js文件：</p>
<pre><code class="language-js">export const geoCoordMap = {
  '位置1': [90.9180416971, 41.0807155340],
  '位置2': [123.4965120599, 51.0206466741],
  '位置3': [100.4728967514, 26.1734892363],
  '位置4': [121.5121844054, 31.2106872661],
  '位置5': [111.50148, 31.2458353752],
  '位置6': [111.50148, 24.2458353752]
};

export const datas = [
  {name: '位置1', value: 19, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']},
  {name: '位置2', value: 20, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']},
  {name: '位置3', value: 32, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']},
  {name: '位置4', value: 24, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']},
  {name: '位置5', value: 46, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']},
  {name: '位置6', value: 30, imgUrl: ['http://localhost:8030/ad.jpg', 'http://localhost:8030/ad.jpg']}
];

</code></pre>
<p>展示效果如下：<br>
<img src="https://img-blog.csdnimg.cn/20200518172025328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>参考 https://segmentfault.com/a/1190000016024960</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebGIS实战系列 四 基于React Hooks、Typescript、arcgis API for js3.x 的例子]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webgis-shi-zhan-xi-lie-si-ji-yu-react-hookstypescriptarcgis-api-for-js3x-de-li-zi</id>
        <link href="https://jiegiser.github.io/newBlog/post/webgis-shi-zhan-xi-lie-si-ji-yu-react-hookstypescriptarcgis-api-for-js3x-de-li-zi">
        </link>
        <updated>2020-06-15T10:13:51.000Z</updated>
        <summary type="html"><![CDATA[<p>此例子是基于 React Hooks、TS 以及 arcgis api for js 的例子；该项目还在完善中；<br>
github地址：https://github.com/jiegiser/arcgis3.x_examples 觉得不错的话可以给个 <code>star</code>；<br>
已完成下面内容：</p>
]]></summary>
        <content type="html"><![CDATA[<p>此例子是基于 React Hooks、TS 以及 arcgis api for js 的例子；该项目还在完善中；<br>
github地址：https://github.com/jiegiser/arcgis3.x_examples 觉得不错的话可以给个 <code>star</code>；<br>
已完成下面内容：</p>
<h2 id="-more-"><!-- more --></h2>
<h3 id="加载-osm-地图">加载 osm 地图（√）</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200524210528571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="加载天地图">加载天地图（√）</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200524210559834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="加载高德地图">加载高德地图（√）</h3>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200524210613361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="加载百度地图">加载百度地图（√）</h3>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200605151239691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="人员定位">人员定位（√）</h3>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200525115318971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="线标注">线标注（√）</h3>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200531121048345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="加载热力图">加载热力图（√）</h3>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200604194734583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="自定义绘制箭头路线">自定义绘制箭头路线（√）</h3>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20200606164950852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="项目存在的问题">项目存在的问题</h3>
<ul>
<li>没有充分发挥 ts 的作用；后续完善 arcgis api 的 ts 支持。</li>
</ul>
<p>通过查资料发现 esri 发布的 @types/arcgis-js-api 虽然是有 3.x 的版本，但是只支持 4 的版本导出 __esri 命名空间以及直接使用:</p>
<pre><code class="language-js">import Map from 'esri/map'
const map = new Map()
</code></pre>
<ul>
<li>解决方法</li>
</ul>
<p>可以通过下面的方法来进行类型注释：</p>
<pre><code class="language-js">import React, { useEffect } from 'react';
import * as esriLoader from 'esri-loader';
import IMap from 'esri/map';
import IPoint from 'esri/geometry/Point'
import ISpatialReference from 'esri/SpatialReference'
const options = {
  url: 'http://localhost/arcgis/init.js',
}
//加载脚本
esriLoader.loadScript(options)
esriLoader.loadCss(`http://localhost/arcgis/esri/css/esri.css`)
const PathReplay: React.FC = () =&gt; {
  useEffect(() =&gt; {
    initMap()
  }, [])
  const initMap =  () =&gt; {
    esriLoader.loadModules([
      'esri/map',
      'esri/geometry/Point',
      'esri/SpatialReference'
    ])
      .then(([Map, Point, SpatialReference]) =&gt; {
        const map: IMap = new Map('mapCon', {
          basemap: 'osm',
          center: [0, 0],
          zoom: 0
        })
        const spatialRe: ISpatialReference = new SpatialReference({
          wkid: 4326
        })
        // 矢量注记图层
        const PointObj: IPoint = new Point({
          x: 114.41703647375107,
          y: 23.10750961303711,
          spatialReference: spatialRe
        })
        map.centerAndZoom(PointObj, 11)
      })
      .catch(err =&gt; {
        console.error(err)
      })
  }
  return (
    &lt;div id=&quot;mapCon&quot;&gt;
    &lt;/div&gt;
  )
}
export default PathReplay;
</code></pre>
<p>这样写 arcgis API 就会有对应的提示：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200525150404695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<hr>
<p>更新</p>
<h3 id="react-hooks-中-ts-类型注释">react hooks 中 ts 类型注释</h3>
<pre><code class="language-js">// 可以推断 age 是 number类型
const [age, setAge] = useState(20);

// 初始化值为 null 或者 undefined时，需要显示指定 name 的类型,
// name 为 string 或者 undefined
const [name, setName] = useState&lt;string&gt;();

// 初始化值为一个对象时
interface People {
    name: string;
    age: number;
    country?: string;
}
const [owner, setOwner] = useState&lt;People&gt;({name: 'jiegiser', age: 18});

// 初始化值是一个数组时
const [members, setMembers] = useState&lt;People[]&gt;([]);

</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[geoserver 中 WMS 服务说明]]></title>
        <id>https://jiegiser.github.io/newBlog/post/geoserver-zhong-wms-fu-wu-shuo-ming</id>
        <link href="https://jiegiser.github.io/newBlog/post/geoserver-zhong-wms-fu-wu-shuo-ming">
        </link>
        <updated>2019-12-21T01:10:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p><code>OGC Web</code>地图服务（<code>WMS</code>）规范定义了一个<code>HTTP</code>接口，用于从服务器请求地理参考的地图图像。<code>GeoServer</code>支持<code>WMS 1.1.1</code>（使用最多的<code>WMS</code>版本）以及<code>WMS 1.3.0</code>。<br>
<code>GeoServer</code>还支持样式化图层描述符（<code>SLD</code>）标准对<code>WMS</code>规范的某些扩展，以控制地图输出的样式。</p>
<h3 id="wms可以做什么">WMS可以做什么</h3>
<p><code>WMS</code>提供了用于请求地理空间地图图像的标准接口。这样做的好处是<code>WMS</code>客户端可以从多个<code>WMS</code>服务器请求图像，然后将它们组合到一个用户视图中。该标准保证了这些图像都可以像现实中那样完全重叠。许多服务器和客户端支持<code>WMS</code>。</p>
<h3 id="功能">功能</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exceptions</td>
<td>发生异常</td>
</tr>
<tr>
<td>GetCapabilities</td>
<td>检索有关服务的元数据，包括支持的操作和参数以及可用层的列表</td>
</tr>
<tr>
<td>GetMap</td>
<td>检索指定区域和内容的地图图像</td>
</tr>
<tr>
<td>GetFeatureInfo</td>
<td>检索地图上像素位置的基础数据，包括几何和属性值</td>
</tr>
<tr>
<td>DescribeLayer</td>
<td>指示WFS或WCS检索有关该图层的其他信息。</td>
</tr>
<tr>
<td>GetLegendGraphic</td>
<td>检索地图生成的图例</td>
</tr>
</tbody>
</table>
<p>下面就详细介绍一个每个功能类型。</p>
<h4 id="exceptions">Exceptions</h4>
<p><code>WMS</code>可以报告异常的格式。支持的异常值为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>XML格式</td>
<td>EXCEPTIONS=application/vnd.ogc.se_xml</td>
<td>Xml输出。（默认格式）</td>
</tr>
<tr>
<td>图形</td>
<td>EXCEPTIONS=application/vnd.ogc.se_inimage</td>
<td>生成图像（在geoserver的图层预览功能中发生异常会使用）</td>
</tr>
<tr>
<td>空白</td>
<td>EXCEPTIONS=application/vnd.ogc.se_blank</td>
<td>生成空白图像</td>
</tr>
<tr>
<td>局部图</td>
<td>EXCEPTIONS=application/vnd.gs.wms_partial</td>
<td>这是一个GeoServer供应商参数，仅适用于getMap请求。返回渲染过程引发异常时渲染的所有内容。可以与WMS配置限制一起使用，以返回部分图像，即使由于超过这些限制之一而被终止的请求也是如此。它也可以与timeout vendor参数一起使用。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>EXCEPTIONS=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>EXCEPTIONS=text/javascript</td>
<td>返回以下格式的JsonP：paddingOutput（…jsonp…）。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<h4 id="getcapabilities">GetCapabilities</h4>
<p>该操作请求有关由<code>WMS</code>服务器提供的操作，服务和数据的元数据。<br>
<code>GetCapabilities</code>操作的参数为：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是一个1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetCapabilities。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>为<code>GetCapabilities</code>操作提供以下特定于供应商的参数。它们在<code>WMS</code>供应商参数部分中有完整记录。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>namespace</td>
<td>否</td>
<td>将响应限制为给定名称空间中的层</td>
</tr>
<tr>
<td>format</td>
<td>否</td>
<td>以某种格式请求功能文档</td>
</tr>
<tr>
<td>rootLayer</td>
<td>否</td>
<td>标记以启用/禁用标准“根”顶层图层元素。值是对还是错。如果为false，则仅当存在多个顶级层时才包括Root元素，如果只有一层，则它将是根层本身。指定后，将以相同的行为覆盖全局WMS设置或图层/组设置。</td>
</tr>
</tbody>
</table>
<p><code>GetCapabilities</code>请求的一个示例：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
service=wms&amp;
version=1.1.1&amp;
request=GetCapabilities
</code></pre>
<p>有被传递到<code>WMS</code>服务器，三个参数<code>service=wms</code>，<code>version=1.1.1</code>和<code>request=GetCapabilities</code>。该<code>service</code>参数告诉<code>WMS</code>服务器即将收到<code>WMS</code>请求。该<code>version</code>参数表示正在请求哪个版本的<code>WMS</code>。该<code>request</code>参数指定<code>GetCapabilities</code>操作。<code>WMS</code>标准要求请求始终包含这三个参数。<code>GeoServer</code>放宽了这些要求（如果省略则通过设置默认版本），但是对于标准合规性，应始终指定它们。</p>
<p>响应是功能<code>XML</code>文档，该文档是<code>WMS</code>服务的详细说明。它包含三个主要部分：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Service</td>
<td>包含服务元数据，例如服务于服务器的组织的服务名称，关键字和联系信息。</td>
</tr>
<tr>
<td>Request</td>
<td>描述WMS服务提供的操作以及每个操作的参数和输出格式。如果需要，可以将GeoServer配置为禁用对某些WMS操作的支持。</td>
</tr>
<tr>
<td>Request</td>
<td>列出可用的坐标系和图层。在GeoServer中，图层以“名称空间：图层”的形式命名。每一层都提供服务元数据，例如标题，摘要和关键字。</td>
</tr>
</tbody>
</table>
<h4 id="getmap">GetMap</h4>
<p><code>GetMap</code>操作是获取到服务器生成的地图。他的请求参数可以控制在地图上显示的一个或多个图层和样式，地图范围的边界框，目标空间参考系统以及输出的宽度，高度和格式。</p>
<p>响应是地图图像或其他地图输出工件，具体取决于请求的格式。<code>GeoServer</code>提供了多种输出格式，以<code>WMS</code>输出格式描述。</p>
<p><code>GetMap</code>操作的标准参数为：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值可以是1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetMap。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>要在地图上显示的图层。值是层名称的逗号分隔列表。</td>
</tr>
<tr>
<td>styles</td>
<td>是</td>
<td>渲染图层的样式。值是样式名称的逗号分隔列表，如果需要默认样式，则为空。列表中的样式名称可能为空，以使用默认的图层样式。</td>
</tr>
<tr>
<td>srs/crs</td>
<td>是</td>
<td>地图输出的空间参考系统。格式是<code>EPSG:nnn</code>。 crs是WMS 1.3.0中使用的参数。</td>
</tr>
<tr>
<td>bbox</td>
<td>是</td>
<td>地图范围的边界框。格式是 minx,miny,maxx,maxy以SRS 为单位。</td>
</tr>
<tr>
<td>width</td>
<td>是</td>
<td>地图输出的宽度（以像素为单位）。</td>
</tr>
<tr>
<td>height</td>
<td>是</td>
<td>地图输出的高度，以像素为单位。</td>
</tr>
<tr>
<td>format</td>
<td>是</td>
<td>地图输出的格式。有关支持的值，请参阅WMS输出格式。</td>
</tr>
<tr>
<td>transparent</td>
<td>否</td>
<td>地图背景是否应该透明。值是true或false。默认为false</td>
</tr>
<tr>
<td>bgcolor</td>
<td>否</td>
<td>地图图像的背景色。格式是RRGGBB。默认为FFFFFF（白色）。</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
<tr>
<td>time</td>
<td>否</td>
<td>地图数据的时间值或范围。有关更多信息，请参见GeoServer WMS中的时间支持。</td>
</tr>
<tr>
<td>sld</td>
<td>否</td>
<td>引用StyledLayerDescriptor XML文件的URL，该URL 可以控制或增强地图图层和样式</td>
</tr>
<tr>
<td>sld_body</td>
<td>否</td>
<td>URL编码的StyledLayerDescriptor XML文档，用于控制或增强地图图层和样式</td>
</tr>
</tbody>
</table>
<p>下面的示例是在<code>SRS:'EPGS：4326'</code>中使用默认样式,将图层输出为<code>PNG</code>的<code>WMS</code>请求：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
request=GetMap
&amp;service=WMS
&amp;version=1.1.1
&amp;layers=topp%3Astates
&amp;styles=population
&amp;srs=EPSG%3A4326
&amp;bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578&amp;
&amp;width=780
&amp;height=330
&amp;format=image%2Fpng
</code></pre>
<p>使用<code>GetMap XML</code>文档的示例<code>WMS</code>请求为：</p>
<pre><code class="language-html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;ogc:GetMap xmlns:ogc=&quot;http://www.opengis.net/ows&quot;
            xmlns:gml=&quot;http://www.opengis.net/gml&quot;
   version=&quot;1.1.1&quot; service=&quot;WMS&quot;&gt;
   &lt;StyledLayerDescriptor version=&quot;1.0.0&quot;&gt;
      &lt;NamedLayer&gt;
        &lt;Name&gt;topp:states&lt;/Name&gt;
        &lt;NamedStyle&gt;&lt;Name&gt;population&lt;/Name&gt;&lt;/NamedStyle&gt;
      &lt;/NamedLayer&gt;
   &lt;/StyledLayerDescriptor&gt;
   &lt;BoundingBox srsName=&quot;http://www.opengis.net/gml/srs/epsg.xml#4326&quot;&gt;
      &lt;gml:coord&gt;&lt;gml:X&gt;-130&lt;/gml:X&gt;&lt;gml:Y&gt;24&lt;/gml:Y&gt;&lt;/gml:coord&gt;
      &lt;gml:coord&gt;&lt;gml:X&gt;-55&lt;/gml:X&gt;&lt;gml:Y&gt;50&lt;/gml:Y&gt;&lt;/gml:coord&gt;
   &lt;/BoundingBox&gt;
   &lt;Output&gt;
      &lt;Format&gt;image/png&lt;/Format&gt;
      &lt;Size&gt;&lt;Width&gt;550&lt;/Width&gt;&lt;Height&gt;250&lt;/Height&gt;&lt;/Size&gt;
   &lt;/Output&gt;
&lt;/ogc:GetMap&gt;
</code></pre>
<p><code>time</code>参数允许按时间切片和空间图块过滤数据集以进行渲染。</p>
<h4 id="getfeatureinfo">GetFeatureInfo</h4>
<p><code>GetFeatureInfo</code>操作是请求地图上给定位置要素的空间和属性数据。它与<code>WFS GetFeature</code>操作类似，但是在输入和输出方面都不太灵活。由于<code>GeoServer</code>提供了<code>WFS</code>服务，因此建议尽可能不要使用<code>GetFeatureInfo</code>。<br>
<code>GetFeatureInfo</code>操作的一个优点是他的请求使用来自返回的<code>WMS</code>图像的（<code>x，y</code>）像素值。对于有时候获取不到地理参考坐标，这个操作还是很方便的。<br>
<code>GetFeatureInfo</code>操作的标准参数是：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是一个1.0.0，1.1.0，1.1.1，1.3.0。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是GetFeatureInfo。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>styles</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>srs/crs</td>
<td>是}	同GetMap操作</td>
<td></td>
</tr>
<tr>
<td>bbox</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>width</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>height</td>
<td>是</td>
<td>同GetMap操作</td>
</tr>
<tr>
<td>query_layers</td>
<td>是</td>
<td>用逗号分隔的一层或多层查询列表。</td>
</tr>
<tr>
<td>info_format</td>
<td>否</td>
<td>功能信息响应的格式。有关值，请参见下文。</td>
</tr>
<tr>
<td>feature_count</td>
<td>否</td>
<td>要返回的最大特征数。默认值为1。</td>
</tr>
<tr>
<td>x / i</td>
<td>是</td>
<td>地图上查询点的X坐标，以像素为单位。左侧为0。 i是WMS 1.3.0中使用的参数键。</td>
</tr>
<tr>
<td>y / j</td>
<td>是</td>
<td>地图上查询点的Y坐标，以像素为单位。0是顶部。 j是WMS 1.3.0中使用的参数键。</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>支持多种<code>GetFeatureInfo</code>响应输出格式。默认的格式是服务器上定义的<code>HTML</code>格式。为了最大程度地控制和定制，客户端应使用<code>GML3</code>并对原始数据本身进行样式设置。支持的格式为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本</td>
<td>info_format=text/plain</td>
<td>简单文本输出。（默认格式）</td>
</tr>
<tr>
<td>GML 2</td>
<td>info_format=application/vnd.ogc.gml</td>
<td>仅适用于简单功能（请参阅复杂功能）</td>
</tr>
<tr>
<td>GML 3</td>
<td>info_format=application/vnd.ogc.gml/3.1.1</td>
<td>适用于简单功能和复杂功能（请参阅“ 复杂功能”）</td>
</tr>
<tr>
<td>HTML</td>
<td>info_format=text/html</td>
<td>使用服务器上定义的HTML模板。有关如何对HTML输出进行模板化的信息，请参见GetFeatureInfo模板。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>info_format=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>info_format=text/javascript</td>
<td>返回JSONP形式：parseResponse(...json...)。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>为<code>GetFeatureInfo</code>操作提供以下特定于供应商的参数。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>否</td>
<td>查询点周围搜索半径的宽度。</td>
</tr>
<tr>
<td>cql_filter</td>
<td>否</td>
<td>过滤返回的数据，采用ECQL格式</td>
</tr>
<tr>
<td>filter</td>
<td>否</td>
<td>以OGC过滤器格式过滤返回的数据</td>
</tr>
<tr>
<td>propertyName</td>
<td>否</td>
<td>要返回的特征属性</td>
</tr>
<tr>
<td>exclude_nodata_result</td>
<td>否</td>
<td>设置为true时，当要素的查询像素值为nodata时，将返回NaN。</td>
</tr>
</tbody>
</table>
<p>下面的示例是从<code>topp:states</code>图层以<code>HTML</code>格式请求要素信息：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
request=GetFeatureInfo
&amp;service=WMS
&amp;version=1.1.1
&amp;layers=topp%3Astates
&amp;styles=
&amp;srs=EPSG%3A4326
&amp;format=image%2Fpng
&amp;bbox=-145.151041%2C21.73192%2C-57.154894%2C58.961059
&amp;width=780
&amp;height=330
&amp;query_layers=topp%3Astates
&amp;info_format=text%2Fhtml
&amp;feature_count=50
&amp;x=353
&amp;y=145
&amp;exceptions=application%2Fvnd.ogc.se_xml
</code></pre>
<p>对<code>GeoJSON</code>格式的特征信息的示例请求为：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?
&amp;INFO_FORMAT=application/json
&amp;REQUEST=GetFeatureInfo
&amp;EXCEPTIONS=application/vnd.ogc.se_xml
&amp;SERVICE=WMS
&amp;VERSION=1.1.1
&amp;WIDTH=970&amp;HEIGHT=485&amp;X=486&amp;Y=165&amp;BBOX=-180,-90,180,90
&amp;LAYERS=COUNTRYPROFILES:grp_administrative_map
&amp;QUERY_LAYERS=COUNTRYPROFILES:grp_administrative_map
&amp;TYPENAME=COUNTRYPROFILES:grp_administrative_map
</code></pre>
<p>请求的结果：</p>
<pre><code class="language-js">{
&quot;type&quot;:&quot;FeatureCollection&quot;,
&quot;features&quot;:[
   {
      &quot;type&quot;:&quot;Feature&quot;,
      &quot;id&quot;:&quot;dt_gaul_geom.fid-138e3070879&quot;,
      &quot;geometry&quot;:{
         &quot;type&quot;:&quot;MultiPolygon&quot;,
         &quot;coordinates&quot;:[
            [
               [
                  [
                     XXXXXXXXXX,
                     XXXXXXXXXX
                  ],
                  ...
                  [
                     XXXXXXXXXX,
                     XXXXXXXXXX
                  ]
               ]
            ]
         ]
      },
      &quot;geometry_name&quot;:&quot;at_geom&quot;,
      &quot;properties&quot;:{
         &quot;bk_gaul&quot;:X,
         &quot;at_admlevel&quot;:0,
         &quot;at_iso3&quot;:&quot;XXX&quot;,
         &quot;ia_name&quot;:&quot;XXXX&quot;,
         &quot;at_gaul_l0&quot;:X,
         &quot;bbox&quot;:[
            XXXX,
            XXXX,
            XXXX,
            XXXX
         ]
      }
   }
],
&quot;crs&quot;:{
   &quot;type&quot;:&quot;EPSG&quot;,
   &quot;properties&quot;:{
      &quot;code&quot;:&quot;4326&quot;
   }
},
&quot;bbox&quot;:[
   XXXX,
   XXXX,
   XXXX,
   XXXX
]
}
</code></pre>
<h4 id="describelayer">DescribeLayer</h4>
<p>该<code>DescribeLayer</code>操作主要是通过了解基于<code>SLD-WMS</code>客户端使用。为了制作<code>SLD</code>，需要知道数据的结构。<code>WMS</code>和<code>WFS</code>都有执行此操作的操作，因此<code>DescribeLayer</code>操作仅将客户端路由到适当的服务。<br>
<code>DescribeLayer</code>操作的标准参数是：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>是否必须</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>service</td>
<td>是</td>
<td>服务名称。值是WMS。</td>
</tr>
<tr>
<td>version</td>
<td>是</td>
<td>服务版本。值是1.1.1。</td>
</tr>
<tr>
<td>request</td>
<td>是</td>
<td>操作名称。值是DescribeLayer。</td>
</tr>
<tr>
<td>layers</td>
<td>是</td>
<td>同GetMap</td>
</tr>
<tr>
<td>exceptions</td>
<td>否</td>
<td>报告异常的格式。默认值为application/vnd.ogc.se_xml。</td>
</tr>
</tbody>
</table>
<p><code>GeoServer</code>支持多种<code>DescribeLayer</code>响应输出格式。最常用的格式是服务器样式的<code>HTML</code>模板。支持的格式为：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本</td>
<td>output_format=text/xml</td>
<td>与默认值相同。</td>
</tr>
<tr>
<td>GML 2</td>
<td>output_format=application/vnd.ogc.wms_xml</td>
<td>默认格式。</td>
</tr>
<tr>
<td>JSON格式</td>
<td>output_format=application/json</td>
<td>简单的Json表示形式。</td>
</tr>
<tr>
<td>JSONP</td>
<td>output_format=text/javascript</td>
<td>返回以下格式的JsonP：paddingOutput（…jsonp…）。请参阅WMS供应商参数以更改回调名称。请注意，默认情况下禁用此格式（请参阅影响WMS的全局变量）。</td>
</tr>
</tbody>
</table>
<p>对图层组上的<code>JSON</code>格式的特征描述的示例请求为：</p>
<pre><code class="language-js">http://localhost:8080/geoserver/wms?service=WMS
&amp;version=1.1.1
&amp;request=DescribeLayer
&amp;layers=sf:roads,topp:tasmania_roads,nurc:mosaic
&amp;outputFormat=application/json
</code></pre>
<p>请求结果：</p>
<pre><code class="language-js">{
  version: &quot;1.1.1&quot;,
  layerDescriptions: [
    {
        layerName: &quot;sf:roads&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wfs/WfsDispatcher?&quot;,
        owsType: &quot;WFS&quot;,
        typeName: &quot;sf:roads&quot;
    },
    {
        layerName: &quot;topp:tasmania_roads&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wfs/WfsDispatcher?&quot;,
        owsType: &quot;WFS&quot;,
        typeName: &quot;topp:tasmania_roads&quot;
    },
    {
        layerName: &quot;nurc:mosaic&quot;,
        owsURL: &quot;http://localhost:8080/geoserver/wcs?&quot;,
        owsType: &quot;WCS&quot;,
        typeName: &quot;nurc:mosaic&quot;
    }
  ]
</code></pre>
<h4 id="getlegendgraphic">GetLegendGraphic</h4>
<p>可以查看这篇文章 https://docs.geoserver.org/stable/en/user/services/wms/get_legend_graphic/index.html#get-legend-graphic</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/vue-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/vue-bi-ji">
        </link>
        <updated>2019-12-06T01:57:39.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-传统的-mvp-开发模式与-mvvm-开发模式对比">1. 传统的 MVP 开发模式与 MVVM 开发模式对比</h4>
<ol>
<li>对于传统的<code>mvp</code>开发模式，<code>m</code>也就是<code>model</code>一般是通过发送<code>ajax</code>请求获取到的数据，<code>v</code>也就是视图，<code>p</code>就是<code>Presenter</code>相当于控制器，</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-传统的-mvp-开发模式与-mvvm-开发模式对比">1. 传统的 MVP 开发模式与 MVVM 开发模式对比</h4>
<ol>
<li>对于传统的<code>mvp</code>开发模式，<code>m</code>也就是<code>model</code>一般是通过发送<code>ajax</code>请求获取到的数据，<code>v</code>也就是视图，<code>p</code>就是<code>Presenter</code>相当于控制器，</li>
</ol>
<!-- more -->
<p><code>Presenter</code>作为View和<code>Model</code>之间的“中间人”，除了基本的业务逻辑外，还有大量代码需要对从<code>View</code>到<code>Model</code>和从<code>Model</code>到<code>View</code>的数据进行“手动同步”，这样<code>Presenter</code>显得很重，维护起来会比较困难。而且由于没有数据绑定，如果<code>Presenter</code>对视图渲染的需求增多，它不得不过多关注特定的视图，一旦视图需求发生改变，<code>Presenter</code>也需要改动,我们大部分的关注点是在视图与数据，以及通过控制器进行操作。</p>
<ol>
<li>对于<code>vue</code>的开发模式<code>mvvm</code>，他把<code>View</code>和<code>Model</code>的同步逻辑自动化了，与<code>MVP</code>不同，没有了<code>View</code>为<code>Presenter</code>提供的接口，之前由<code>Presenter</code>负责的<code>View</code>和<code>Model</code>之间的数据同步交给了<code>ViewModel</code>中的数据绑定进行处理，当<code>Model</code>发生变化，<code>ViewModel</code>就会自动更新；<code>ViewModel</code>变化，<code>Model</code>也会更新。我们的关注点主要是在<code>model</code>与<code>view</code>之间，而<code>model</code>发生变化，<code>view</code>进行同步更新，这些都交给了<code>viewmodel</code>，<code>mvp</code>的模式我们大部分的关注点是在操作了<code>dom</code>，提高了开发效率。</li>
</ol>
<h4 id="2-一些指令以及使用技巧">2. 一些指令以及使用技巧</h4>
<h5 id="21-vue-中计算属性的使用技巧">2.1.  Vue 中计算属性的使用技巧</h5>
<p><code>get、set</code>；如果是获取数值，通过<code>get</code>获取到值，也可以通过<code>set</code>函数设置值，注意如果你为一个计算属性使用了箭头函数，则 this 不会指向这个组件的实例，不过可以通过其实例作为函数的第一个参数来访问：</p>
<pre><code class="language-js">computed: {
  aDouble: vm =&gt; vm.a * 2
}
</code></pre>
<p><code>get、set</code>用法：</p>
<pre><code class="language-js">var vm = new Vue({
  data: { a: 1 },
  computed: {
    // 仅读取
    aDouble: function () {
      return this.a * 2
    },
    // 读取和设置
    aPlus: {
      get: function () {
        return this.a + 1
      },
      set: function (v) {
        this.a = v - 1
      }
    }
  }
})
vm.aPlus   // =&gt; 2
vm.aPlus = 3
vm.a       // =&gt; 2
vm.aDouble // =&gt; 4
</code></pre>
<blockquote>
<p>计算属性的结果会被缓存，除非依赖的变量变化才会重新计算。注意，如果某个依赖 (比如非响应式属性) 在该实例范畴之外，则计算属性是不会被更新的。 我们一般如果处理数据显示，如果声明函数、计算属性、侦听器这三者都可以实现的话，一般建议使用计算数据，因为存在缓存机制。</p>
</blockquote>
<p>计算属性设置值的时候直接使用<code>=</code>，如上面的<code>aPlus</code>数值，而不是与函数类似进行赋值。</p>
<pre><code class="language-js">aPlus = 10
</code></pre>
<h5 id="22-v-bind-绑定-class-与-内联样式">2.2. v-bind 绑定 class 与 内联样式</h5>
<h6 id="221-v-bind-绑定-class">2.2.1.  v-bind 绑定 class</h6>
<p>在<code>v-bind</code>中，绑定<code>class</code>，使用:<code>class=&quot;{active:isActive}&quot;</code>，前面的active如果没有在data中定义是不会报错的，他是一个对象表达式，意思就是<code>active</code>这个类的显示与否都在于<code>isActive</code>这个变量，该变量为布尔类型，为<code>true</code>为显示，为<code>false</code>是不显示。</p>
<pre><code class="language-html">&lt;div
  class=&quot;static&quot;
  v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
&gt;&lt;/div&gt;
</code></pre>
<p><code>data</code>：</p>
<pre><code class="language-js">data: {
  isActive: true,
  hasError: false
}
</code></pre>
<p>渲染的结果：如果<code>hasError</code>的值为<code>true</code>，<code>class</code> 列表将变为<code>&quot;static active text-danger&quot;</code></p>
<pre><code class="language-html">&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;
</code></pre>
<p>而如果使用:<code>class=&quot;[chextType, active ]&quot;</code>，这样<code>chextType</code>这个必须在<code>data</code>中定义。<code>div</code>显示的类名就是显示<code>chextType、active</code>变量中存储的类名。另外他也可以与普通的	<code>class</code>共存</p>
<pre><code class="language-html">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p><code>data</code>：</p>
<pre><code class="language-js">data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
</code></pre>
<p>渲染的结果：如果<code>hasError</code>的值为<code>true</code>，<code>class</code> 列表将变为<code>&quot;static active text-danger&quot;</code></p>
<pre><code class="language-html">&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这样写将始终添加<code>errorClass</code>，但是只有在<code>isActive</code> 是<code>true</code>时才添加 <code>activeClass</code>。不过，当有多个条件 <code>class</code> 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p>
<pre><code class="language-html">&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>当在一个自定义组件上使用 <code>class</code>属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。<br>
例如，如果你声明了这个组件：</p>
<pre><code class="language-js">Vue.component('my-component', {
  template: '&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;'
})
</code></pre>
<p>然后在使用它的时候添加一些 <code>class</code>：</p>
<pre><code class="language-html">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;
</code></pre>
<p><code>HTML</code> 将被渲染为:</p>
<pre><code class="language-html">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;
</code></pre>
<p>对于带数据绑定的<code>class</code>跟前面是一样的。</p>
<h6 id="222-绑定内联样式">2.2.2.  绑定内联样式</h6>
<p>对象语法：<br>
<code>v-bind:style</code> 的对象语法十分直观——看着非常像<code>CSS</code>，但其实是一个 <code>JavaScript</code> 对象。<code>CSS</code>属性名可以用驼峰式 或短横线分隔 (记得用引号括起来) 来命名：</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">data: {
  activeColor: 'red',
  fontSize: 30
}
</code></pre>
<p>直接绑定到一个样式对象通常更好，这会让模板更清晰：同样的，对象语法常常结合返回对象的计算属性使用。</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-js">data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
</code></pre>
<p>数组语法:<br>
<code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p>
<pre><code class="language-html">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>自动添加前缀：<br>
当 <code>v-bind:style</code> 使用需要添加浏览器引擎前缀的 <code>CSS</code>属性时，如<code>transform</code>，<code>Vue.js</code> 会自动侦测并添加相应的前缀。</p>
<h5 id="23-v-if-与-v-else-标签必须要连在一起使用不然会抛出错误">2.3. v-if 与 v-else 标签必须要连在一起使用，不然会抛出错误。</h5>
<h5 id="24-key-值">2.4. key 值</h5>
<p><code>Vue</code>在重新渲染页面的时候，会尝试复用页面里面的<code>dom</code>元素，如果页面有两个相同的标签可以添加一个<code>key</code>，这样，<code>vue</code>会区分，不会复用。</p>
<h5 id="25-v-for-循环">2.5.  v-for 循环</h5>
<p>一般在<code>v-for</code>循环的时候，一般建议加一个<code>:key</code>值，绑定一个唯一的标识，不建议直接绑定循环的<code>index</code>，会消耗性能，建议绑定后台传入的数据的主键。</p>
<h5 id="26-vue-中操作数组">2.6. Vue 中操作数组</h5>
<p><code>Vue</code>中，不能直接通过数组下标的方法，进行添加数据，这样页面不会渲染的，需要通过数据的操作函数进行增删改查：<code>push、pop、shift、unshift、splice、sort、reverse</code></p>
<h5 id="27-template-模板占位符">2.7.  template 模板占位符</h5>
<p><code>template</code>模板占位符，比如我们使用v-for要循环两个标签，可以在两个标签外层加一个<code>div</code>，但是这个<code>div</code>会在页面显示出来，我们可以把外层的<code>div</code>换成<code>template</code>，不会显示在页面。</p>
<h5 id="28-vue-中遍历对象进行渲染以及对根级别响应式对象添加属性">2.8. Vue 中遍历对象进行渲染以及对根级别响应式对象添加属性</h5>
<p>对象的循环：<code>key</code>是，键；<code>index</code>是位置信息，<code>item</code>是值；</p>
<pre><code class="language-html">&lt;div v-for=&quot;(value, name, index) in object&quot;&gt;
  {{ index }}. {{ name }}: {{ value }}
&lt;/div&gt;
</code></pre>
<p>渲染结果：</p>
<pre><code class="language-html">&lt;div id=&quot;v-for-object-value-name-index&quot; class=&quot;demo&quot;&gt;&lt;div&gt;
    0. title: How to do lists in Vue
  &lt;/div&gt;&lt;div&gt;
    1. author: Jane Doe
  &lt;/div&gt;&lt;div&gt;
    2. publishedAt: 2016-04-10
  &lt;/div&gt;&lt;/div&gt;
</code></pre>
<p>给对象直接修改属性是可以再次进行渲染。<br>
给对象直接添加值，是不变的，可以直接改变引用，换成一个全新的对象，也可以使用<code>set</code>方法，<code>Vue.set(vm.userInfo,&quot;address&quot;,&quot;wuhan&quot;)</code>这样，<code>userInfo</code>对象会增加数据，页面也会变动，重新渲染。也可以使用实例的<code>$set方法</code>，<code>vm.$set(vm.userInfo,&quot;address&quot;,&quot;wuhan&quot;)</code><br>
对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 <code>Vue.set(object, propertyName, value)</code>方法向嵌套对象添加响应式属性。</p>
<h5 id="29-对于数组的-set-方法">2.9. 对于数组的 set 方法</h5>
<p>对于数组的<code>set</code>方法。<code>Vue.set(vm.userInfo,4,5)</code>，将第四个位置的数据改成5，也可以用实例<code>vm.$set(vm.userInfo,4,5)</code>，所以改变数组的值有两种方法，第一个是使用js的数组操作函数，另一个是使用<code>vue</code>的<code>set</code>方法、</p>
<h5 id="210-v-text-与-v-html">2.10 v-text 与 v-html</h5>
<p>这两个指令旨在显示数值，跟我们直接在<code>html</code>中使用插值表达式类似：</p>
<pre><code class="language-html">&lt;div&gt;{{message}}&lt;/div&gt;
</code></pre>
<p><code>v-text</code>显示的结果与插值表达式一致的，而<code>v-html</code>会展示为<code>html</code>，如果字符串是一个<code>html</code>的字符串，他会进行渲染显示。</p>
<h4 id="3-组件的一些知识">3. 组件的一些知识</h4>
<h5 id="31-is属性">3.1. is属性</h5>
<p>有些 <code>HTML</code> 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。比如<code>tbody</code>里只能显示<code>tr</code>，我们希望在tr里放其他的内容，可以借助<code>is</code>属性：</p>
<pre><code class="language-html">&lt;table&gt;
  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;
&lt;/table&gt;
</code></pre>
<p>这个自定义组件<code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is 特性给了我们一个变通的办法：</p>
<pre><code class="language-html">&lt;table&gt;
  &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
<p>这句代码就是说，我们在<code>tbody</code>是显示<code>tr</code>，其实是<code>is</code>里面的组件；遇到组件上的小<code>bug</code>，可以使用<code>is</code>进行解决；比如<code>ol、select</code>等等。</p>
<h5 id="32-子组件中-data">3.2 . 子组件中 data</h5>
<p>子组件中<code>data</code>为函数；是为了保证每一个组件中的数据互不干扰；</p>
<h5 id="33-组件中操作-dom">3.3. 组件中操作 DOM</h5>
<p><code>ref</code>：引用 ，被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code>对象上。如果在普通的<code>DOM</code>元素上使用，引用指向的就是 <code>DOM</code> 元素；如果用在子组件上，引用就指向组件实例：</p>
<pre><code class="language-html">&lt;!-- `vm.$refs.p` will be the DOM node --&gt;
&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;

&lt;!-- `vm.$refs.child` will be the child component instance --&gt;
&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
</code></pre>
<p>获取<code>dom</code>节点，通过<code>this.$refs.ref</code>的值这样获取<code>dom</code>节点；比如上面的结构，如果需要获取<code>this.$refs.child</code>就会获取到对应的<code>dom</code>信息。<br>
当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。<br>
关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p>
<h5 id="34-组件之间的通讯">3.4. 组件之间的通讯</h5>
<h6 id="341-子组件向父组件派发事件">3.4.1 子组件向父组件派发事件</h6>
<p>使用<code>this.$emit('change')</code>;在父组件触发change事件。<code>@change=&quot;handleChange&quot;;</code>父组件的<code>change</code>事件执行<code>handleChange</code>方法。</p>
<h6 id="342-父组件向子组件传递">3.4.2 父组件向子组件传递</h6>
<p>父组件向子组件传递是通过属性，用<code>v-bind</code>进行绑定，子组件尽量不要修改父组件传进来的参数，可以使用<code>data</code>复制一份传入的值；<br>
对于组件参数的校验，直接在<code>props</code>，接收的时候，为一个对象，<code>type</code>为类型，<code>default</code>为默认值，<code>required</code>为设置参数是否必须，<code>validator(value){return (value.length&gt;5)}</code>传入的值必须大于五；</p>
<pre><code class="language-js">Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<p>还是需要注意的是v-bind绑定的属性后面是一个对象，直接跟<code>class</code>一样绑定属性，为字符串；<code>props</code>传递的属性，在<code>dom</code>渲染出来的<code>HTML</code>上不会显示出来。</p>
<h5 id="35-组件绑定原生事件">3.5 组件绑定原生事件</h5>
<p>给父组件绑定事件，其实是一个自定义事件，想要给组件绑定事件，需要在<code>template</code>里面进行绑定。子组件想要触发自定义事件，需要使用<code>this.$emit('chandleClick')；</code>如果想在父组件添加事件，需要添加<code>native</code>事件修饰符:<code>@click.native=&quot;handleClick&quot;;</code></p>
<blockquote>
<p>这里在子组件向父组件传值定义事件名的时候需要注意，不同于组件和 <code>prop</code>，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。所以如果我们定义了一个<code>this.$emit('myEvent')</code>，然后在父组件监听的时候：<code>&lt;my-component v-on:my-event=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code>使用短横行的方式去监听，是监听不到的，因为不同于组件和<code>prop</code>，事件名不会被用作一个 <code>JavaScript</code> 变量名或属性名，所以就没有理由使用 <code>camelCase</code> 或 <code>PascalCase</code> 了。并且<code>v-on</code>事件监听器在<code>DOM</code>模板中会被自动转换为全小写 (因为 <code>HTML</code>是大小写不敏感的)，所以<code>v-on:myEvent</code>将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code>不可能被监听到。<br>
所以推荐我们一般使用短横线的方式去命名。</p>
</blockquote>
<h5 id="36-非父子组件传值-bus-总线发布订阅模式观察者模式">3.6. 非父子组件传值（ Bus 总线/发布订阅模式/观察者模式）</h5>
<pre><code class="language-javascript">Vue.prototype.bus = new Vue();
//子组件触发事件
this.bus.$emit('change',this.value)//来触发事件；然后组件进行监听：
//在父组件的mounted中去监听子组件触发的事件
mounted(){
  this.bus.$on('change',function(msg)
    {
      //...
    }
);
</code></pre>
<h5 id="37-插槽相关知识">3.7.  插槽相关知识</h5>
<p>在<code>slot</code>插槽中，如果在父组件中不进行插入<code>dom</code>，在子组件的<code>&lt;slot&gt;</code>默认内容<code>&lt;/slot&gt;</code>,里面的字会显示出来，自定义的内容放在<code>&lt;slot&gt;中间</code>，如果父组件有数据，则不会显示；具名插槽也可以有默认内容。<br>
具名插槽：<br>
有时我们需要多个插槽。例如对于一个带有如下模板的 <base-layout> 组件：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;!-- 我们希望把页头放这里 --&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;!-- 我们希望把主要内容放这里 --&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;!-- 我们希望把页脚放这里 --&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>对于这样的情况，<code>&lt;slot&gt;</code>元素有一个特殊的特性：<code>name</code>。这个特性可以用来定义额外的插槽：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<p>一个不带<code>name</code> 的 <code>&lt;slot&gt;</code>出口会带有隐含的名字<code>“default”</code>。<br>
在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以<code>v-slot</code>的参数的形式提供其名称：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有<code>v-slot</code>的<code>&lt;template&gt;</code>中的内容都会被视为默认插槽的内容。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code>中包裹默认插槽的内容：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;template v-slot:default&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/template&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<p>最终上面的代码渲染的结果为：</p>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
    &lt;p&gt;And another one.&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>注意 v-slot 只能添加在一个<code>&lt;template&gt;</code>上</p>
</blockquote>
<p>作用域插槽：在父组件向子组件传入内容时候，需要使用<code>template</code>标签进行包裹，这里的<code>template</code>是必须的</p>
<pre><code class="language-html">&lt;child&gt;
  &lt;template slot-scope=&quot;props&quot;&gt;
    &lt;h1&gt;{{props.item}}&lt;/h1&gt;
  &lt;/template&gt;
&lt;/child&gt;
</code></pre>
<p>在子组件中：</p>
<pre><code class="language-html">&lt;div&gt;
  &lt;ul&gt;
    &lt;slot 
       v-for=&quot;item of list&quot; 
       :item=item
       &gt;
    &lt;/slot&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>应用场景：子组件进行循环或者某一dom渲染的样式需要外部传入，进行不同的显示；作用域插槽也就相当于就是插槽之间的数据通讯。</p>
</blockquote>
<h5 id="38-动态组件">3.8.  动态组件</h5>
<p>动态组件：<code>component</code>标签的<code>is</code>属性来自动加载组件:<code>&lt;component :is=&quot;com-a&quot;&gt;&lt;/component&gt;,</code>显示<code>com-a</code>组件；不像<code>v-if</code>，它是将组件进行缓存在内存里面的。</p>
<h5 id="39-vue-中的动画">3.9. vue 中的动画</h5>
<p><code>vue</code>中的动画，需要使用<code>transition</code>标签进行包裹需要动画显示的组件，他会给里面包裹的元素添加多个类名<code>fade-enter、fade-enter-active、fade-enter-to</code>等， 前缀为<code>fade</code>是因为我们添加的<code>name</code>为<code>fade，vue</code>默认为<code>v-enter、v-enter-active</code>等等。<code>div</code>标签外只要使用<code>transition</code>包裹，<code>div</code>不管使用<code>v-show</code>还是<code>v-if</code>过渡动画都是可以显示的。如果我们需要自定义类名，直接在<code>transform</code>标签上添加 <code>enter-active-class=&quot;active&quot; leave-active-class=&quot;leave&quot;</code>对应的<code>active</code>以及<code>leave</code>是自定义的类名；<br>
<code>vue</code>中使用<code>animate.css</code>在<code>transition</code>标签上直接使用：<code>enter-active-class=&quot;animated swing&quot; leave-active-class=&quot;animated shake&quot;</code>；<br>
为了让<code>div</code>能在初次进去页面的时候有动画，添加一个自定义属性<code>appear-active-class</code>,还需要加一个<code>appear</code>，意思就是让组件第一次显示的时候也有一个动画效果，就是<code>appear-active-class</code>；可以添加属性<code>type=&quot;&quot;</code>来指定动画播放时长；</p>
<h5 id="311-非-props-特性">3.11. 非 Props 特性</h5>
<p>一个非<code>prop</code>特性是指传向一个组件，但是该组件并没有相应 <code>prop</code>定义的特性。<br>
因为显式定义的 <code>prop</code> 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的特性，而这些特性会被添加到这个组件的根元素上。<br>
例如，想象一下你通过一个 <code>Bootstrap</code> 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code>上用到一个 <code>data-date-picker</code>特性。我们可以将这个特性添加到你的组件实例上：<br>
然后这个<code>data-date-picker=&quot;activated&quot;</code>特性就会自动添加到<code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<h5 id="312-组件中替换合并已有的特性">3.12. 组件中替换/合并已有的特性</h5>
<p>如果定义了一个组件 <bootstrap-date-input> 的模板是这样的：</p>
<pre><code class="language-html">&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;
</code></pre>
<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<pre><code class="language-html">&lt;bootstrap-date-input
  data-date-picker=&quot;activated&quot;
  class=&quot;date-picker-theme-dark&quot;
&gt;&lt;/bootstrap-date-input&gt;
</code></pre>
<p>在这种情况下，我们定义了两个不同的<code>class</code> 的值:</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数特性来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code>就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code>和<code>style</code> 特性会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h5 id="313-组件的禁用特性继承">3.13. 组件的禁用特性继承</h5>
<p>如果你不希望组件的根元素继承特性，也就是说你不希望你的组件的根元素取绑定你没有接受的属性值，你可以在组件的选项中设置 inheritAttrs: false。例如：</p>
<pre><code class="language-js">Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
</code></pre>
<p>这尤其适合配合实例的 <code>$attrs</code> 属性使用，该属性包含了传递给一个组件的特性名和特性值，例如：</p>
<pre><code class="language-js">{
  required: true,
  placeholder: 'Enter your username'
}
</code></pre>
<p>有了 <code>inheritAttrs: false</code>和<code>$attrs</code>，你就可以手动决定这些特性会被赋予哪个元素。在撰写基础组件的时候是常会用到的：</p>
<pre><code class="language-js">Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    &lt;label&gt;
      {{ label }}
      &lt;input
        v-bind=&quot;$attrs&quot;
        v-bind:value=&quot;value&quot;
        v-on:input=&quot;$emit('input', $event.target.value)&quot;
      &gt;
    &lt;/label&gt;
  `
})
</code></pre>
<blockquote>
<p>注意<code>inheritAttrs: false</code> 选项不会影响<code>style</code> 和 <code>class</code>的绑定。</p>
</blockquote>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 <code>HTML</code>元素，而不会担心哪个元素是真正的根元素：</p>
<pre><code class="language-html">&lt;base-input
  v-model=&quot;username&quot;
  required
  placeholder=&quot;Enter your username&quot;
&gt;&lt;/base-input&gt;
</code></pre>
<p>可以看到我们的组件并没有接收<code>required</code>以及<code>placeholder</code>属性，因此，<code>$attrs</code>的值就是：</p>
<pre><code class="language-js">{
  required: true,
  placeholder: 'Enter your username'
}
</code></pre>
<p>然后我们在组件中直接将这些属性进行绑定了：<code>v-bind=&quot;$attrs&quot;</code>，也就是说<code>$attrs</code>存储非<code>prop</code>特性，<code>inheritAttrs</code>控制<code>vue</code>对非<code>prop</code>特性默认行为，在标签内添加<code>$attrs</code>可以渲染上未注册的属性<code>inheritAttrs:false</code>是允许组件绑定的未注册属性渲染到组件根节点上的。<code>$attrs</code>是一个对象。</p>
<h4 id="4-vue-cli-以及-vue-router">4.  vue-cli 以及 vue-router</h4>
<h5 id="41-javascript-中-promise-对象与-callbacks-的区别">4.1. Javascript 中 Promise 对象与 callbacks 的区别</h5>
<p><code>Javascript</code>中<code>Promise</code>对象与<code>callbacks</code>的区别进行比较，显著的优点就是，<code>promise</code>对象减少了嵌套，有效的防止了进入回调地狱；并且可以一次触发多个<code>promise</code>对象：</p>
<pre><code class="language-javascript">	const eatMeal=Promise.all([firstPromise,burgerPromise,drinkPromise]) 
	.then([fries,burger,drinks]=&gt;{
	console.log(`Chomp. Awesome ${burger}`);
	console.log(`Chomp. Awesome ${fries}`);
	console.log(`Chomp. Awesome ${drinks}`);
	})；
</code></pre>
<p><code>reject</code>与<code>reslove</code>使用，在创建<code>promise</code>对象的时候进行判断，如果符合条件，就执行<code>resolve</code>，不符合就执行<code>reject</code>；<br>
然后就是<code>.then</code>，不管是成功还是失败，都会执行，也就是执行<code>reject</code>的时候会执行<code>.catch</code>；<code>.catch</code>是执行失败的时候会调用。</p>
<h5 id="42-vue-cli-知识">4.2. vue-cli 知识</h5>
<p><code>.vue</code>文件是代表<code>vue</code>的一个组件，在<code>js</code>文件中我们创建一个组件，是通过<code>Vue.component('com-a',{})</code>这样，在<code>vue</code>工程化中，我们使用<code>.vue</code>的文件进行创建组件。<br>
对于<code>vue-cli</code>脚手架的理解，首先我们在根目录的<code>main.js</code>文件中，可以看到：引用了<code>route</code>r以及<code>app</code>文件。</p>
<pre><code class="language-javascript">import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  // 局部组件
  components: { App },
  // 下面这句话意思是将app组件渲染在页面中，可以不在这里写，直接在index里面进行书写app标签。
  template: '&lt;App/&gt;'
})

// 路由 &lt;route-view&gt;显示的是当前路由地址所对应的内容
</code></pre>
<p>在<code>App.vue</code>文件中，我们可以看到：<code>&lt;route-view&gt;</code>显示的是当前路由地址所对应的内容 ,</p>
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    [外链图片转存失败(img-cbxcO81D-1562120294364)(https://mp.csdn.net/mdeditor/assets/logo.png)]
    &lt;!-- &lt;route-view&gt;显示的是当前路由地址所对应的内容 --&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;
</code></pre>
<p>打开<code>Router</code>夹子中的<code>index.js</code>文件：它配置了当路由显示为<code>home</code>，也就是<code>http://localhost:8080/#/home</code>这样的时候，显示组件<code>HelloWorld</code>，这样控制到不同的路由显示不同的内容。</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/home',
      name: 'HelloWorld',
      component: HelloWorld
    }
  ]
})

</code></pre>
<p>下面的代码注释：</p>
<pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import Home from '@/pages/home/Home'
import List from '@/pages/list/List'

Vue.use(Router)

export default new Router({
  routes: [
    // 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
    {
      path: '/',
      // 路由名字
      name: 'home',
      component: Home
    }, {
      // 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
      path: '/list',
      name: 'List',
      component: List
    }
  ]
})
</code></pre>
<p>有关<code>.vue</code>中的页面跳转，以前我们使用<code>a</code>标签进行跳转的，在<code>.vue</code>中，我们使用<code>&lt;router-link&gt;</code>，进行跳转，如下面代码：</p>
<pre><code class="language-javascript">&lt;template&gt;
&lt;!-- 这里需要注意的是template只能包裹一个内容，如果有多个，需要在外层再加一个div --&gt;
  &lt;div&gt;
    &lt;div&gt;home&lt;/div&gt;
    &lt;!-- 页面跳转 to里面是跳转到根路径下的list页面，就是路由里面配置--&gt;
    &lt;router-link to=&quot;/list&quot;&gt;列表&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  // 组件的名字
  name: 'Home'
}
&lt;/script&gt;

&lt;style&gt;
div {
  font-size: 19px;
}
&lt;/style&gt;

</code></pre>
<p>当然我们可以使用<code>router</code>的函数式导航的方式进行跳转页面：可以看到跳转到了<code>backCar</code>页面，传入的参数为<code>id: carInfo.CARID</code>，在另一个组件接收传入的参数<code>this.$router.query.id</code> ， 对于页面传值的方式还有很多。</p>
<pre><code class="language-js">this.$router.push({ path: '/backCar', query: {ID: carInfo.CARID} });
</code></pre>
<blockquote>
<p><code>还有一个需要注意的是：&lt;template&gt;标签只能向外暴露一个根标签，如果有多个，需要再到外层加一个div</code>；<br>
单页应用：通过js进行控制页面的显示。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190505172511257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h5 id="43-项目中一些技巧">4.3. 项目中一些技巧</h5>
<h6 id="431-import-引入-css">4.3.1. import 引入 css</h6>
<p>通过import可以直接引用css，如下面代码，可以直接写在<code>main.js</code>中：</p>
<pre><code class="language-javascript">	import './assets/style/reset.css'
</code></pre>
<h6 id="432-移动端-click-事件延迟执行">4.3.2. 移动端 Click 事件延迟执行</h6>
<p>防止移动端中出现点击<code>click</code>事件，延迟300毫秒执行的插件，在工程中输入下面命令进行安装：</p>
<pre><code class="language-javascript">	cnpm install fastclick --save
</code></pre>
<p>然后在<code>main.js</code>中进行设置：</p>
<pre><code class="language-javascript">	// 使用attach方法，绑定到body中。
	fastClick.attach(document.body)
</code></pre>
<h6 id="433-vue-cl项目中配置路径别名">4.3.3. vue-cl项目中配置路径别名</h6>
<p>在<code>vue-cli</code>项目中配置路径引用的标记，我们经常在项目中看到@符号，代表就是<code>src</code>路径，<code>~@</code>代表的是<code>src</code>路径下的两层路径，有时候我们的层级特别多，不能使用@符号，我们可以进行配置我们的简写路径。打开配置文件，修改如下：<br>
<code>styles</code>就是代表我们的<code>src/assets/style</code>这个路径。</p>
<pre><code class="language-js">	  resolve: {
	    extensions: ['.js', '.vue', '.json'],
	    alias: {
	      'vue$': 'vue/dist/vue.esm.js',
	      '@': resolve('src'),
	      'styles': resolve('src/assets/style'),
	    }
	  },
</code></pre>
<p>所以我们在引用该目录下的文件的直接就直接这样写：</p>
<pre><code class="language-js">	import 'styles/border.css'
	import 'styles/iconfont.css'
</code></pre>
<h6 id="434-vue-cl项目中使用-stylus">4.3.4. vue-cl项目中使用 stylus</h6>
<p>引入<code>stylus</code>,他类似<code>sass</code>或者<code>less</code>这种，可以直接在css中进行定义变量；帮助我们工程化代码；输入下面的命令进行安装：</p>
<pre><code class="language-js">	npm install stylus --save
	npm install stylus-loader --save
</code></pre>
<pre><code>然后我们可以在我们的项目中使用，如下面的`&lt;style&gt;`标签内，需要添加一个`lang=&quot;stylus&quot;`属性，这样就直接可以使用`stylus`进行写css代码，
</code></pre>
<pre><code class="language-css">	&lt;style lang=&quot;stylus&quot; scoped&gt;
	@import '~styles/varibles.styl'
	  .header
	    display: flex
	    line-height: .86rem
	    background: $bgColor
	    color: #fff
	    .header-left
	      width: .64rem
	      float: left
	      .back-icon
	        text-align: center
	        font-size: .4rem
	&lt;/style&gt;
</code></pre>
<p>这里还有需要注意的是，我们可以使用<code>stylus</code>，新建一个<code>varibles.styl</code>文件，来进行定义变量，比如我们主题的颜色，在很多css文件中都要使用，如果后期需要更换主题颜色，就很麻烦；这时候，我们可以通过新建一个<code>styl</code>后缀的文件，在里面进行定义我们的变量，这样后期维护就比较方便；<code>varibles.styl</code>文件内如下：</p>
<pre><code class="language-css">	$bgColor = #00bcd4
	$darkTextColor = #333
	$headerHeight = .86rem
	```
	然后我们引入这个文件，直接可以使用在里面定义的变量，代码如下：
	```css
	@import '~styles/varibles.styl'
	  .header
	    display: flex
	    line-height: .86rem
	    background: $bgColor
</code></pre>
<h6 id="435-移动端像素问题">4.3.5. 移动端像素问题</h6>
<p>首先需要明白<code>rem</code>与<code>px</code>像素单位之间的转化；<code>1rem = html font-size = 50px</code>；经常为了方便处理转换<code>rem</code>；我们会将<code>html</code>的<code>font-size</code>设置为<code>50px</code>，这样我们直接在页面中写<code>rem</code>的时候就方便计算了，直接是像素(<code>px</code>)/100这样计算就可以了。比如我们要设置<code>width=86px</code>，直接写成<code>width=.86rem</code>就可以了。</p>
<blockquote>
<p>需要注意的一个问题是，如果修改了<code>webpack</code>里面的配置项，需要重新启动服务才会有效。</p>
</blockquote>
<h4 id="5-项目开发中的一些知识">5. 项目开发中的一些知识</h4>
<h5 id="51-开发流程">5.1. 开发流程</h5>
<p>开发项目中的流程：大多数公司在进行开发一个项目的时候，都会首先建立一个主分支(<code>master</code>),然后将其他功能的编写，都放在其他分支上，最后将其他分支合并到主分支这样的开发流程。<br>
在码云上新建分支，然后在项目文件夹下输入命名：<br>
<code>git push</code> 他会提示提交到哪一个分支上，然后输入命令：<code>git checkout index-swiprer</code> 其中<code>index-swiprer</code>是我们新建的一个分支。<br>
将分支内容提交到主分支，还是通过<code>git add . ; git commit -m '&quot; ; git push</code>提交之后，然后输入命令<code>git checkout master</code>切换到主分支，然后进行合并，输入命令:<code>git merge origin/index-swiper</code>其中<code>index-swiprer</code>是我们要合并的分支；最后再<code>git push</code></p>
<h5 id="52-vue-第三方轮播图插件-vue-awesome-swiper">5.2. vue 第三方轮播图插件 vue-awesome-swiper</h5>
<p><code>vue</code>第三方轮播图插件<code>vue-awesome-swiper</code>，安装如下：<br>
输入命令<code>npm install vue-awesome-swiper@2.6.7 --save</code>然后根据官网的操作步骤，就可以使用了。官网地址：https://github.com/surmon-china/vue-awesome-swiper</p>
<h5 id="53-浏览器的小技巧模拟网络">5.3. 浏览器的小技巧模拟网络</h5>
<p>浏览器的小技巧：可以点击调试面试的<code>network</code>右侧有一个<code>offline</code>右侧的向下的箭头，可以模拟不同的网速，比如可以选择<code>slow 3G</code>模拟<code>3G</code>网络。</p>
<h5 id="54-css-代码技巧">5.4.  css 代码技巧</h5>
<h6 id="541-宽高保持一定的百分比">5.4.1. 宽高保持一定的百分比</h6>
<p>高度根据宽度撑开百分比，设置宽高始终保持在<code>31.25%</code>如下面的代码：</p>
<pre><code class="language-css">	  overflow: hidden
	  width: 100%
	  height: 0
	  /*高度会根据宽度自动撑开31.25% */
	  padding-bottom: 31.25%
</code></pre>
<p>或者直接写一个<code>height：31.25vm</code>，把<code>overflow</code>以及<code>padding-bottom</code>删除 ,也是可以的。</p>
<h6 id="542-修改第三方插件样式">5.4.2. 修改第三方插件样式</h6>
<p>查找<code>wrapper</code>下面的<code>swiper-pagination-bullet-active</code>类都加一个背景色。应用场景是，有时候引用了第三方的插件，需要改插件的颜色，直接通过加<code>! important</code>是不行的，可以通过下面的方法进行修改。</p>
<pre><code class="language-css">.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active
  background: #fff
</code></pre>
<p>另一个技巧：当页面显示的时候有可能显示的字体会很多，我们可以设置多余的显示为<code>...</code>，可以通过css类控制：</p>
<pre><code class="language-css">  overflow: hidden
  white-space: nowrap
  text-overflow: ellipsis
</code></pre>
<p>我们可以借助<code>stylus</code>进行封装css函数，如下面代码：</p>
<pre><code class="language-css">	ellipsis()
	  overflow: hidden
	  white-space: nowrap
	  text-overflow: ellipsis
</code></pre>
<p>然后在css中进行引入：<code>mixins.styl</code>文件就是我们写的代码，直接加一个<code>ellipsis()</code>就可以了。</p>
<pre><code class="language-css">	@import '~styles/mixins.styl'
	  .icon-desc
	    position: absolute
	    left: 0
	    right: 0
	    bottom: 0
	    height: .44rem
	    line-height: .44rem
	    text-align: center
	    color: $darkTextColor
	    ellipsis()
</code></pre>
<h6 id="543-div-元素垂直居中">5.4.3. div 元素垂直居中</h6>
<p><code>CSS</code>技巧：让给<code>div</code>中的元素垂直居中：</p>
<pre><code class="language-css">	  display: flex
	  flex-direction: column
	  justify-content: center
</code></pre>
<p>然后里面的可以设置<code>css</code>进行水平居中：</p>
<pre><code class="language-css">	    line-height: .44rem
	    text-align: center
</code></pre>
<h6 id="544-移动端获取元素离顶部元素真实高度">5.4.4. 移动端获取元素离顶部元素真实高度</h6>
<p>对于页面中获取离上面元素高度：</p>
<pre><code class="language-javascript">	        // 元素离顶部元素的高度
	        const startY = this.$refs['A'][0].offsetTop
	        // 获取到手离开屏幕的高度，他是获取到设备的最顶部到手指离开时的高度，这里高度需要减去顶部的header
	        //touch事件会传入一个手势参数，第一个存储着变量，跟点击事件一样，存储事件属性。
	        const touchY = e.touches[0].clientY - 79
</code></pre>
<h5 id="55-vue-cli-项目中的静态资源访问以及代码提交配置">5.5.  vue-cli 项目中的静态资源访问以及代码提交配置</h5>
<p><code>vue-cli</code>项目中，我们一般是将就静态文件放在<code>static</code>文件夹中，因为整个项目，只能那个文件夹可以被外部访问到。访问其他文件夹中的内容会自动跳转到主页面。我们可以修改项目中的<code>.gitignore</code>文件，进行配置在git提交代码的时候，提交哪些文件。如下面代码。设置将<code>static</code>下面的<code>mock</code>文件夹内的东西不进行提交:</p>
<pre><code class="language-javascript">	.DS_Store
	node_modules/
	/dist/
	npm-debug.log*
	yarn-debug.log*
	yarn-error.log*
	static/mock
	
	# Editor directories and files
	.idea
	.vscode
	*.suo
	*.ntvs*
	*.njsproj
	*.sln
	
</code></pre>
<h5 id="56-项目接口的转接">5.6. 项目接口的转接</h5>
<p>我们在写项目代码的时候，前端写的模拟数据，通过自己写的模拟接口，有可能是通过模拟的<code>json</code>数据，但是当项目 上线的时候需要进行替换真的<code>API</code>接口，如果在上线前进行替换，是有风险的，我们可以通过<code>webpack</code>提供的配置，在<code>config</code>文件夹下通过配置，将接口进行跳转，如下面的配置：</p>
<pre><code class="language-javascript">	    proxyTable: {
	      '/api': {
	        target: 'http://localhost:8080',
	        pathRewrite: {
	          '^/api': 'static/mock'
	        }
	      }
	    },
</code></pre>
<p>代码的意思是，将有<code>/api</code>请求的路径替换成<code>http://localhost:8080/static/mock</code>这样</p>
<h5 id="57-math-对象的一些方法">5.7. Math 对象的一些方法</h5>
<p><code>Math.round()，Math.ceil()，Math.floor()，Math.trunc</code>的区别：<code>Math.floor()</code>首先是向下取整，<code>Math.ceil()</code>是向上取整，<code>Math.round()</code>就类似我们的四舍五入,<code>Math.trunc()</code>方法会将数字的小数部分去掉，只保留整数部分。</p>
<h5 id="58-css-的-rem-以及-vm">5.8. CSS 的 rem 以及 vm</h5>
<p><code>rem</code> 是 <code>CSS3</code>新增的一个相对单位<code>（root em）</code>，即相对 <code>HTML</code> 根元素的字体大小的值。<br>
<code>em</code> 也是一个相对单位，却是相对于当前对象内文本的字体大小。<br>
一般建议在 <code>line-height</code>使用<code>em</code>。因为在需要调整字体大小的时候，只需修改<code>font-size</code> 的值，而<code>line-height</code>已经设置成了相对行高了。<br>
首行缩进两个字符：<code>text-indent: 2em</code><br>
视口单位 <code>vw | vh</code>:</p>
<blockquote>
<p>vw: 1vw = 视口宽度的 1%<br>
vh: 1vh = 视口高度的 1%</p>
</blockquote>
<h5 id="59-better-scroll-插件">5.9. Better-scroll 插件</h5>
<p><code>Better-scroll</code>插件的用法：<br>
首先进行安装，输入命令：<code>cnpm install better-scroll --save</code><br>
然后在页面就可以使用，如下面的代码：它主要的功能是做一个滚动，还有一个弹性的动画。</p>
<pre><code class="language-javascript">	import Bscroll from 'better-scroll'
	export default {
	  name: 'CityList',
	  mounted () {
	    //   传入dom元素
	    this.scroll = new Bscroll(this.$refs.wrapper)
	  }
	}
</code></pre>
<p>可以使用该插件自带的方法，进行滚动到对应的<code>DOM</code>元素，<code>element</code>是对应要滚动到的元素<code>DOM</code>节点，代码如下</p>
<pre><code class="language-javascript">	this.scroll.scrollToElement(element)
</code></pre>
<p>在<code>vue</code>中，我们获取组件，通常是在组件添加一个<code>ref</code>属性，然后通过<code>this.$refs.wrapper</code>获取到对应的组件，其中<code>wrapper</code>是我们定义组件的<code>ref</code>属性名字。</p>
<h5 id="510-防抖节流的例子">5.10. 防抖节流的例子</h5>
<p>一个防抖节流的例子：这个是做了一个类似通讯录滑动右侧字母列表进行显示对应首字母的人员，我们会通过<code>touch</code>事件来完成。思路是这样的：首先获取到<code>A</code>到顶部的距离，然后获取到手指滑动结束后的位置，用手指滑动后的位置减去<code>A</code>的位置，就是之间的距离差，然后根据距离差除以每一个字母的高度，就可以获取到到第几个位置，然后显示对应的数据。<br>
<img src="https://img-blog.csdnimg.cn/20190507212023344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
但是当我们手指拖动的时候，会频繁的触发触摸事件，所以我们在这里就可以做一个节流的操作，定义一个计时器，每次移动完之后，首先清除上次的定时器，然后重新定义计时器，每隔16毫秒执行一次事件。这样避免了频繁调用事件，下面是实现的代码：</p>
<pre><code class="language-javascript">	    handleTouchMove (e) {
	      if (this.touchStatus) {
	        if (this.timer) {
	          clearTimeout(this.timer)
	        }
	        // 延迟16毫秒执行
	        this.timer = setTimeout(() =&gt; {
	          // 获取到手离开屏幕的高度，他是获取到设备的最顶部到手指离开时的高度，这里高度需要减去顶部的header
	          const touchY = e.touches[0].clientY - 79
	          const index = Math.floor((touchY - this.startY) / 20)
	          if (index &gt;= 0 &amp;&amp; index &lt; this.letter.length) {
	            this.$emit('change', this.letter[index - 1])
	          }
	        }, 16)
	      }
	    },
</code></pre>
<h5 id="511-touch-事件与-click-事件的冲突">5.11.  touch 事件与 click 事件的冲突</h5>
<p>有时候我们做的拖动页面，比如通讯录的右侧拖动字母表，显示对应的人，但是发现拖动的时候整个页面也会动，这个时候就需要阻止<code>touchstart</code>事件的默认行为，需要在给组件绑定该事件的时候加一个事件修饰符，如下代码：</p>
<pre><code class="language-javascript">          @click=&quot;handleLetterClick&quot;
          @touchstart.prevent=&quot;handleTouchStart&quot;
          @touchmove=&quot;handleTouchMove&quot;
          @touchend=&quot;handleTouchEnd&quot;
</code></pre>
<h5 id="512-解决手机不支持-es6-新特性">5.12.  解决手机不支持 es6 新特性</h5>
<p>有些手机会不支持<code>promise</code>对象，进行发送<code>ajax</code>请求，这时候我们需要使用一个插件来解决；在项目中安装插件，输入下面的命令：<br>
这个插件，会检测浏览器是否支持<code>es6</code>的新特性，如果不支持，会进行修改。</p>
<pre><code class="language-javascript">	  npm install babel-polyfill --save
</code></pre>
<p>然后在<code>main.js</code>文件中直接引入该插件就可以了<code>import 'babel-polyfill'</code></p>
<h4 id="6-vuex-知识">6. vuex 知识</h4>
<h5 id="61-vuex-的使用">6.1.  vuex 的使用</h5>
<p>他是为了在多个组件共享数据的时候，方便我们管理共享状态；首先如果需要使用该插件，还是等进行安装。可以看下面的<code>vuex</code>实现步骤：<br>
<img src="https://img-blog.csdnimg.cn/2019050812593849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
每一个 <code>Vuex</code> 应用的核心就是 <code>store</code>（仓库）。<code>“store”</code>基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>);所以在使用的使用进行实例化<code>Store</code>对象，如下面的代码：</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	
	Vue.use(Vuex)
	
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  //  组件可以直接调用commit进行修改数据，可以不进行事件的派发dispatch
	  //   actions: {
	  //     changeCity (ctx, city) {
	  //       //  通过触发commit事件，来触发mutations来修改数据
	  //       ctx.commit('changeCity', city)
	  //     }
	  //   },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>从上面的示意图可以看到，如果需要改变状态里面的数据，首先得执行<code>Dispatch</code>进行分发一个事件，去执行一个<code>Actions</code>，然后通过<code>commit</code>去触发<code>Motations</code>里面的方法，去改变状态值；下面代码是<code>Dispatch</code>进行分发一个事件：</p>
<pre><code class="language-javascript">	      // 触发changeCity这个Action
       this.$store.dispatch('changeCity', city)
</code></pre>
<p>在<code>Store</code>对象的<code>Actions</code>里面我们这样写</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	Vue.use(Vuex)
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  //  组件可以直接调用commit进行修改数据，可以不进行事件的派发dispatch
	   actions: {
	       changeCity (ctx, city) {
	         //  通过触发commit事件，来触发mutations来修改数据
	       ctx.commit('changeCity', city)
	       }
	     },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>组件可以直接通过commit调用执行mutation里面的方法就行修改数据，在页面直接这样写</p>
<pre><code class="language-javascript">	  // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
      this.$store.commit('changeCity', city)
</code></pre>
<p>然后在<code>Store</code>对象的<code>Mutations</code>直接写对应的处理函数<code>changeCity</code>,代码：</p>
<pre><code class="language-javascript">	import Vue from 'vue'
	import Vuex from 'vuex'
	
	Vue.use(Vuex)
	
	export default new Vuex.Store({
	  state: {
	    city: '武汉'
	  },
	  mutations: {
	    changeCity (state, city) {
	      state.city = city
	    }
	  }
	})
</code></pre>
<p>在页面中，我们直接这样访问<code>store</code>对象里面的数值：</p>
<pre><code class="language-html">	  &lt;div class=&quot;header-right&quot;&gt;
          {{this.$store.state.city}}
          &lt;span class=&quot;iconfont arrow-icon&quot;&gt;&amp;#xe64a;&lt;/span&gt;
      &lt;/div&gt;
</code></pre>
<h5 id="62-页面之间跳转">6.2. 页面之间跳转</h5>
<p>对于页面跳转的，不仅可以使用<code>&lt;router-link to=&quot;/&quot;&gt;&lt;/router-link&gt;</code>这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以，代码如下：</p>
<pre><code class="language-javascript">	  methods: {
	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      this.$store.commit('changeCity', city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    }
	  },
</code></pre>
<h5 id="63-访问-vuex-数据技巧">6.3. 访问 vuex 数据技巧</h5>
<h6 id="631-组件中访问state数据">6.3.1. 组件中访问state数据</h6>
<p>由于 <code>Vuex</code>状态存储是响应式的，从<code>store</code>实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p>
<pre><code class="language-js">// 创建一个 Counter 组件
const Counter = {
  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
</code></pre>
<p>调用<code>Vue.use(Vuex)</code>状态从根组件“注入”到每一个子组件中：</p>
<pre><code class="language-js">const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    &lt;div class=&quot;app&quot;&gt;
      &lt;counter&gt;&lt;/counter&gt;
    &lt;/div&gt;
  `
})
</code></pre>
<p>然后在组件中可以使用：</p>
<pre><code class="language-js">const Counter = {
  template: `&lt;div&gt;{{ count }}&lt;/div&gt;`,
  computed: {
    count () {
      return this.$store.state.count
    }
  }
}
</code></pre>
<h6 id="632-mapstate-辅助函数">6.3.2. mapState 辅助函数</h6>
<p>访问<code>vuex</code>数据技巧：前面写了可以通过<code>this.$store.state.city</code>这样来获取到我们在<code>Store</code>对象中定义的<code>state</code>里面的数据，我们也可以这样写：需要注意的是，遍历命名只能使<code>mapState</code>这样，下面的代码就是将<code>store</code>里面的<code>city</code>映射到计算属性里面的<code>city</code></p>
<pre><code class="language-javascript">	import { mapState } from 'vuex'
	  computed: {
	    // 展开运算符 把 store里面的city映射到计算属性里面的city
	    ...mapState(['city'])
	  }
</code></pre>
<p>其实<code>mapState</code>里面也可以包含一个对象，这样写，如下面的代码：代码意思是将<code>vuex</code>的<code>city</code>映射到计算属性的<code>currentCity</code></p>
<pre><code class="language-javascript">	import { mapState } from 'vuex'
		  computed: {
	    // 将vuex的city映射到计算属性的currentCity
	    ...mapState({
	      currentCity: 'city'
	    })
	  },
</code></pre>
<p>同样对于通过<code>commit</code>调用<code>Mutations</code>中的方法，也可以进行改写，之前是这样的：</p>
<pre><code class="language-javascript">	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      this.$store.commit('changeCity', city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    },
</code></pre>
<p>可以借助 <code>vuex</code>的简单方法，进行改写如下：需要注意的是<code>changeCity</code>这个方法要对应你在<code>store</code>对象的<code>Mutations</code>中定义的一致。还有需要注意的是，需要进行引入<code>import { mapState, mapMutations } from 'vuex'</code></p>
<pre><code class="language-javascript">	import { mapState, mapMutations } from 'vuex'
	  methods: {
	    handleCityClick (city) {
	      // 触发changeCity这个Action
	      // this.$store.dispatch('changeCity', city)
	      // 组件可以直接通过commit调用执行mutation里面的方法就行修改数据
	      // this.$store.commit('changeCity', city)
	      // 可以用下面的方法这样写
	      this.changeCity(city)
	      // 不仅可以使用&lt;router-link&gt;&lt;/router-link&gt;这种方法跳转，也可以使用编程式导航这种。进行push要跳转的地址就可以
	      this.$router.push('/')
	    },
	    ...mapMutations(['changeCity'])
	  },
</code></pre>
<h6 id="633-使用常量替代-mutation-事件类型">6.3.3. 使用常量替代 Mutation 事件类型</h6>
<p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code>实现中是很常见的模式。这样可以使<code>linter</code>之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个<code>app</code> 包含的<code>mutation</code>一目了然：</p>
<pre><code class="language-js">// mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION'
</code></pre>
<pre><code class="language-js">// store.js
import Vuex from 'vuex'
import { SOME_MUTATION } from './mutation-types'

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})
</code></pre>
<h5 id="64-vuex-中的-getters-属性">6.4.  vuex 中的 getters 属性</h5>
<p><code>vuex</code>中的<code>getters</code>属性：他类似<code>vue</code>的计算属性一样，可以根据<code>state</code>中的数据计算出其他数据，也就是从<code>state</code>中派生出一些状态;比如下面的代码。我需要获取到我的城市名，出现两次，代码如下:下面是<code>store</code>里面的代码</p>
<pre><code class="language-javascript">	  getters: {
	    doubleCity (state) {
	      return state.city + ' ' + state.city
	    }
	  }
</code></pre>
<p>然后在页面中，我们同样首先引入<code>mapGetters</code>,代码如下：</p>
<pre><code class="language-javascript">	import { mapGetters } from 'vuex'
		  computed: {
	    // 展开运算符 把 store里面的doubleCity映射到计算属性里面的doubleCity
	    ...mapGetters(['doubleCity'])
	  }
</code></pre>
<h5 id="65-使用-keep-alive-优化性能">6.5. 使用 keep-alive 优化性能</h5>
<p>使用<code>keep-alive</code>优化性能：我们的页面每次切换之后，都会进行重新的<code>ajax</code>请求，这样会耗费性能，我们可以在<code>&lt;router-view/&gt;</code>外层包裹一个<code>&lt;keep-alive&gt;</code>，他是只要路由渲染过的页面，会存储在内存中，再一次加载的时候，不会进行重新渲染 相当于添加了一个缓存</p>
<pre><code class="language-html">	    &lt;!-- keep-alive是只要路由渲染过的页面，会存储在内存中，再一次加载的时候，不会进行重新渲染 相当于添加了一个缓存--&gt;
	    &lt;keep-alive&gt;
	      &lt;router-view/&gt;
	    &lt;/keep-alive&gt;
</code></pre>
<p>但是有的时候，我们需要重新渲染页面，而不是读取缓存的内容，在使用<code>keep-alive</code>会触发一个<code>activated</code>方法，只要缓存的页面，再次显示，都会执行这个方法。我们可以在这里进行判断某些值是否改变，用不用重新发送请求。</p>
<pre><code class="language-javascript">	  activated () {
	    // 如果添加了keep-alive会有这个事件
	    if (this.lastCity !== this.city) {
	      this.lastCity = this.city
	      this.getHomeInfo()
	    }
	  },
</code></pre>
<h5 id="66-router-link-一些知识">6.6. router-link 一些知识</h5>
<h6 id="661-tag-属性">6.6.1. tag 属性</h6>
<p><code>router-link</code>一些知识：对于<code>router-link</code>，<code>vue</code>会渲染成一个<code>a</code>标签，当我们点击跳转到其他页面之后，会变颜色，当然我们可以通过<code>css</code>进行控制跳转后链接的颜色，我们还可以直接将其他元素改为 <code>router-link</code>然后添加一个<code>tag</code>属性，等于替换的标签，如下面的代码：下面的代码。本身是一个<code>li</code>标签，用<code>router-link</code>替换之后，添加一个<code>tag=&quot;li&quot;</code>属性</p>
<pre><code class="language-html">	            &lt;router-link tag=&quot;li&quot; class=&quot;item border-bottom&quot; v-for=&quot;item of list&quot; :key=&quot;item.id&quot; to=&quot;/detail&quot;&gt;
	                ![在这里插入图片描述]()
	                &lt;div class=&quot;item-info&quot;&gt;
	                    &lt;p class=&quot;item-title&quot;&gt;{{item.title}}&lt;/p&gt;
	                    &lt;p class=&quot;item-desc&quot;&gt;{{item.desc}}&lt;/p&gt;
	                    &lt;button class=&quot;item-button&quot;&gt;查看详情&lt;/button&gt;
	                &lt;/div&gt;
	            &lt;/router-link&gt;
</code></pre>
<h6 id="662-返回到前一页">6.6.2. 返回到前一页</h6>
<p><code>router-link</code>中：如果想要返回到前一个页面，属性<code>to='/'</code>这样就可以了,代码如下</p>
<pre><code class="language-html">	        &lt;router-link tag=&quot;div&quot; to=&quot;/&quot; class=&quot;header-abs&quot;&gt;
	            &lt;div class=&quot;iconfont header-abs-back&quot;&gt;&amp;#xe624;&lt;/div&gt;
	        &lt;/router-link&gt;
</code></pre>
<h5 id="67-keep-alive-一些知识点">6.7.   &lt;keep-alive&gt;  一些知识点</h5>
<p><code>&lt;keep-alive&gt;</code>一些知识点：对全局事件解析解绑；当我们在全局使用它进行包裹我们的组件的时候，前面也说了，会将我们的组件进行缓存，但是，他会因此产生两个生命周期函数，上面介绍了一个每次进入缓存页面的时候，执行的<code>activated</code>钩子函数，还有一个与之对应的钩子函数就是<code>deactivated</code>函数，就是离开这个页面的时候执行的方法。比如现在我们有一个页面，需要在<code>windoes</code>对象绑定<code>scroll</code>事件，但是如果在这个页面进行绑定了该事件之后，在其他的页面，还是会执行这个方法，所以我们需要对全局事件进行解绑。代码如下：<code>activated</code>钩子函数是当进入到使用<code>&lt;keep-alive&gt;</code>缓存的页面的时候执行的方法，我们在整理进行绑定了滚动事件,<code>deactivated</code>是当要离开缓存的这个页面的时候，执行的钩子函数，我们在这里进行移除绑定的滚动事件。</p>
<pre><code class="language-javascript">	  activated () {
	    window.addEventListener('scroll', this.handleScroll)
	  },
	  deactivated () {
	    window.removeEventListener('scroll', this.handleScroll)
	  }
</code></pre>
<h5 id="68-vuex-中的插件">6.8.  vuex 中的插件</h5>
<p><code>Vuex</code> 的 <code>store</code> 接受 <code>plugins</code> 选项，这个选项暴露出每次<code>mutation</code>的钩子。<code>Vuex</code>插件就是一个函数，它接收<code>store</code> 作为唯一参数：</p>
<pre><code class="language-js">const myPlugin = store =&gt; {
  // 当 store 初始化后调用
  store.subscribe((mutation, state) =&gt; {
    // 每次 mutation 之后调用
    // mutation 的格式为 { type, payload }
  })
}

</code></pre>
<p>使用：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  // ...
  plugins: [myPlugin]
})
</code></pre>
<h5 id="68-严格模式">6.8.  严格模式</h5>
<p>开启严格模式，仅需在创建<code>store</code> 的时候传入<code>strict: true</code>：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  // ...
  strict: true
})
</code></pre>
<h4 id="7-vue-router-知识点">7. vue-router 知识点</h4>
<h5 id="71-路由中参数的传递">7.1. 路由中参数的传递</h5>
<p>如果需要在路由带参数，直接在路由后面写上<code>:id</code>这样，<code>id</code>是参数名；如下面的代码：</p>
<pre><code class="language-javascript">    {
      // 动态路由 id为参数
      path: '/detail/:id',
      name: 'Detail',
      component: Detail
    }
</code></pre>
<p>如果需要在页面中需要获取路由中的参数，如下面的代码：使用<code>this.$route.params.id</code>来进行获取该页面中的参数</p>
<pre><code class="language-javascript">	    getDetailInfo () {
	      axios.get('/api/detail.json?id=', {
	        params: {
	          id: this.$route.params.id
	        }
	      }).then(this.handleGetDataSucc)
	    }
</code></pre>
<blockquote>
<p>一般我们发送<code>ajax</code>请求的时候，一般是在页面挂载之后执行，也就是<code>mounted</code>钩子函数里面去执行发送请求。</p>
</blockquote>
<p>还有一种传递参数的方式：</p>
<pre><code class="language-html">          &lt;router-link :to=&quot;{path:'/mailDetail',query:{id: item.id, type: 'rec'}}&quot; :key=&quot;item.id&quot;&gt;
            &lt;InfoList :info=&quot;item&quot;&gt;&lt;/InfoList&gt;
          &lt;/router-link&gt;
</code></pre>
<p>在组件中接收参数：</p>
<pre><code class="language-js">  data () {
    return {
      form: {},
      fjhref:'',
      activeName: '1',
      id: this.$route.query.id,
      type: this.$route.query.type,
    }
  },
</code></pre>
<h5 id="72-组件中-name-的用法总结">7.2 组件中 name 的用法总结</h5>
<p>组件中<code>name</code>的用法：组件的递归、去除缓存 、清除页面滚动。</p>
<h6 id="721-去除缓存">7.2.1. 去除缓存</h6>
<p>在指定页面去除缓存：在<code>keep-alive</code>组件中添加一个属性<code>exclude</code>,属性内容就是要去除缓存的页面的<code>name</code>值，如下面的代码：<br>
这里我的组件名叫<code>Detail</code>，前面我们是通过缓存的两个钩子函数<code>activated</code>和<code>deactivated</code>配合清除缓存的，下面是另一种方法。<br>
代码意思就是除了<code>Detail</code>这个页面不被缓存，其他页面都是被缓存的。</p>
<pre><code class="language-html">    &lt;keep-alive exclude=&quot;Detail&quot;&gt;
      &lt;router-view/&gt;
    &lt;/keep-alive&gt;
</code></pre>
<h6 id="722-清除页面滚动">7.2.2. 清除页面滚动</h6>
<p>清除页面滚动行为：我们在前面时候写到一个请求滚动的也是通过缓存的两个钩子函数<code>activated</code>和<code>deactivated</code>配合清除滚动的，其实在<code>vue-router</code>中，有一个配置项，是清除页面滚动行为的，使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 <code>vue-router</code>能做到，而且更好，它让你可以自定义路由切换时页面如何滚动，在<code>router</code>添加下面的代码，如下：<code>scrollBehavior</code>选项意思就是每次进行路由切换，始终回到最顶部。</p>
<pre><code class="language-javascript">	export default new Router({
		routes: [
			// 当用户访问根目录的时候，&lt;router-view&gt;显示home组件
			{
				path: '/',
				// 路由名字
				name: 'home',
				component: Home
			}, {
				// 动态路由 id为参数
				path: '/detail/:id',
				name: 'Detail',
				component: Detail
			}
		],
		scrollBehavior (to, from, savedPosition) {
			return { x: 0, y: 0 }
		}
	})
</code></pre>
<h6 id="723-组件的递归">7.2.3. 组件的递归</h6>
<p>递归组件：有时候我们在页面中，会有类似折叠菜单的这种，样式是一样的，使用同一个组件，这就需要使用递归组件，如下面数据：</p>
<pre><code class="language-javascript">     categoryList&quot;: [{
        &quot;title&quot;: &quot;成人票&quot;,
        &quot;children&quot;: [{
          &quot;title&quot;: &quot;成人三馆联票&quot;,
          &quot;children&quot;: [{
            &quot;title&quot;: &quot;成人三馆联票 - 某一连锁店销售&quot;
          }]
        },{
          &quot;title&quot;: &quot;成人五馆联票&quot;
     }]
</code></pre>
<p>递归组件就是在组件中调用他本身，上面的数据，只要有<code>children</code>我们就进行调用它本身，代码如下：</p>
<pre><code class="language-html">        &lt;div class=&quot;item&quot; v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt;
            &lt;div class=&quot;item-title border-bottom&quot;&gt;
                &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt;
                {{item.title}}
            &lt;/div&gt;
            &lt;div class=&quot;item-chilren&quot; v-if=&quot;item.children&quot;&gt;
                &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</code></pre>
<blockquote>
<p>需要注意的是<code>detail-list</code>这个是改组件的<code>name</code>值，这就是组件<code>name</code>的其他用法</p>
</blockquote>
<h5 id="73-响应路由参数的变化">7.3. 响应路由参数的变化</h5>
<p>当使用路由参数时，例如从 <code>/user/foo</code>导航到<code>/user/bar</code>，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <code>watch</code>(监测变化) <code>$route</code>对象：</p>
<pre><code class="language-js">const User = {
  template: '...',
  watch: {
    '$route' (to, from) {
      // 对路由变化作出响应...-----可以再次请求数据
    }
  }
}
</code></pre>
<p>或者使用 2.2 中引入的<code>beforeRouteUpdate</code>导航守卫：</p>
<pre><code class="language-js">const User = {
  template: '...',
  beforeRouteUpdate (to, from, next) {
    // react to route changes...
    // don't forget to call next()
  }
}
</code></pre>
<h5 id="74-路由中传递参数">7.4. 路由中传递参数</h5>
<p>函数式编程导航：</p>
<pre><code class="language-js">// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
</code></pre>
<p>这里需要注意：如果提供了<code>path</code>，<code>params</code>会被忽略，上述例子中的 <code>query</code>并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的<code>name</code>或手写完整的带有参数的<code>path</code>：</p>
<pre><code class="language-js">const userId = '123'
router.push({ name: 'user', params: { userId }}) // -&gt; /user/123
router.push({ path: `/user/${userId}` }) // -&gt; /user/123
// 这里的 params 不生效
router.push({ path: '/user', params: { userId }}) // -&gt; /user
</code></pre>
<h5 id="75-命名路由">7.5. 命名路由</h5>
<p>我们在写路由对象的时候可以给路由对象加一个<code>name</code>属性，通过一个名称来表示一个路由会显得更方便一些：</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    }
  ]
})
</code></pre>
<p>要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：</p>
<pre><code class="language-js">&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;
</code></pre>
<p>或者使用编程式导航的方式：</p>
<pre><code class="language-js">router.push({ name: 'user', params: { userId: 123 }})
</code></pre>
<p>两种方式导航的地址：<code>/user/123</code></p>
<h5 id="76-命名视图">7.6. 命名视图</h5>
<p>如果我们的一个页面需要展示多个视图，就可以使用命名视图，如果 <code>router-view</code>没有设置名字，那么默认为 <code>default</code>。</p>
<pre><code class="language-html">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;
</code></pre>
<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code>配置 (带上 <code>s</code>)：</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
})
</code></pre>
<h5 id="77-组建内的守卫">7.7. 组建内的守卫</h5>
<p>组建内的守卫有三种：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code></li>
<li><code>beforeRouteLeave</code></li>
</ul>
<pre><code class="language-js">const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
</code></pre>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code>来取消。</p>
<pre><code class="language-js">beforeRouteLeave (to, from , next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}
</code></pre>
<h5 id="78完整的导航解析流程">7.8.完整的导航解析流程</h5>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h4 id="8-项目上线准备">8. 项目上线准备</h4>
<h5 id="81-api-接口的替换">8.1. API 接口的替换</h5>
<p>在项目上线的时候，需要前后台的联调，需要使用真实的<code>api</code>接口进行测试，这时候，我们需要在<code>config</code>文件夹下的<code>index</code>进行配置后台的接口，地址，配置如下面的代码:这里，我的后台的对应的地址是<code>http://localhost:80</code></p>
<pre><code class="language-javascript">    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
      '/api': {
        target: 'http://localhost:80',
        pathRewrite: {
          '^/api': 'static/mock'
        }
      }
</code></pre>
<p>如果后台跟前台写的<code>api</code>地址是一样的，可以不进行配置<code>pathRewrite</code>选项，如下：</p>
<pre><code class="language-javascript">    assetsSubDirectory: 'static',
    assetsPublicPath: '/',
    proxyTable: {
      '/api': {
        target: 'http://localhost:80'
      }
</code></pre>
<h5 id="82-移动端项目真机调试">8.2. 移动端项目真机调试</h5>
<p>在<code>vue</code>项目中，<code>webpack</code>服务器默认是不能通过<code>ip</code>地址进行访问我们的项目，比如运行<code>cmd</code>输入<code>ipconfig</code>查看我们的<code>ip</code>地址，输入到网页，是看不到我们的项目，输入端口80是可以看到的，我们可以通过修改配置，只需要修改项目中的<code>package.json</code>文件的配置项，代码如下：</p>
<pre><code class="language-javascript">		&quot;scripts&quot;: {
			&quot;dev&quot;: &quot;webpack-dev-server --host 0.0.0.0 --inline --progress --config build/webpack.dev.conf.js&quot;,
			&quot;start&quot;: &quot;npm run dev&quot;,
			&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,
			&quot;build&quot;: &quot;node build/build.js&quot;
		},
</code></pre>
<h5 id="83-项目打包">8.3. 项目打包</h5>
<p><code>vue</code>项目打包上线：输入命令<code>npm run build</code>将我们的代码进行打包编译，然后我们的项目会多出来一个<code>dist</code>的文件夹。里面就是我们打包项目的代码。直接将<code>dist</code>文件夹放在后台的站点就可以运行了，但是有时候我们的站点需要放在后台服务器的一个文件夹里面，比如说，我们需要将前台的代码放在一个<code>project</code>的文件夹中，如果直接放进去，运行项目，你会发现报错，这个时候，我们需要修改<code>config</code>文件夹中的<code>inedx.js</code>里面的打包项：主要是<code>assetsPublicPath: '/project',</code>这个</p>
<pre><code class="language-javascript">	    build: {
				index: path.resolve(__dirname, '../dist/index.html'),

				// Paths
				assetsRoot: path.resolve(__dirname, '../dist'),
				assetsSubDirectory: 'static',
				assetsPublicPath: '/project',
			}
</code></pre>
<h4 id="9-vue-学习路线">9. vue 学习路线</h4>
<p><code>vue</code>学习思路：边缘知识点进行查看，查看生态系统<code>v-router</code>中的路由别名等等，查看<code>vuex</code>中的一些核心概念，然后查看服务器端渲染，然后学习<code>vue</code>的插件，查看官网的<code>vue</code>资源。最后研究<code>vue</code>源码，查看<code>commit</code>，了解每次提交的的添加的功能的思路。</p>
<h4 id="10-其他">10. 其他</h4>
<ol>
<li>使用<code>JSX</code>，需要注意的是：如果使用<code>JSX</code>，需要在<code>webpack</code>中进行配置<code>babel-plugin-transform-vue-jsx</code>，</li>
<li>看了一篇文章，有关个人技术突破的，首先要了解技术门槛，认清自己当下局势。然后进行习惯养成与指定目标计划，<br>
比如读源码，或者整理原理图，当完成目标可以给自己奖励，也可以不断测试自己的底线，调整目标。然后就是训练自己的<br>
思维，善于对问题进行提问：问题是什么，当前真相是什么，为什么会发生。最后，，就是不怕吃亏。。</li>
<li>Vue中的插件开发：使用一个公开的方法<code>install</code>；<code>v-router</code>（实现原理跟使用is用来设置显示组件一样）、<code>v-vuex</code>（非父子组件之间通讯的原理）等插件。</li>
<li>浏览器的基本工作原理从输入url到使用各种线程渲染页面。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack4.X 基础知识笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack4x-ji-chu-zhi-shi-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack4x-ji-chu-zhi-shi-bi-ji">
        </link>
        <updated>2019-12-06T01:50:32.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-webpack-基础知识">1. WebPack 基础知识</h4>
<p>首先需要明白<code>webpack</code>为什么会出现，作用是什么，总之他就是一个模块打包工具；<br>
<code>commonJS</code>的模块导出方式为:</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-webpack-基础知识">1. WebPack 基础知识</h4>
<p>首先需要明白<code>webpack</code>为什么会出现，作用是什么，总之他就是一个模块打包工具；<br>
<code>commonJS</code>的模块导出方式为:</p>
<!-- more -->
<pre><code class="language-javascript">function SiderBar() {
    var dom = document.getElementById('root');
    var siderbar = document.createElement('div');
    siderbar.innerHTML = 'siderbar';
    dom.append(siderbar);
}

module.exports = SiderBar
</code></pre>
<p><code>commonJS</code>的模块导入(引入)方式为:</p>
<pre><code class="language-javascript">var SiderBar = require('./siderbar.js')
</code></pre>
<p><code>webpack</code>是一个打包工具，，他能识别任何一个模块引入的语法，包括<code>ES Module(也就是 import export)、CommonJS 、CMD 、AMD</code>都可以识别。<code>webpack</code>都能够进行很好的翻译。</p>
<h4 id="2-webpack-安装-使用配置文件-浅析打包输出的内容-loader-使用-loader-打包静态资源图片篇-使用-loader-打包静态资源样式篇">2. Webpack 安装、使用配置文件、浅析打包输出的内容、Loader、使用 Loader 打包静态资源（图片篇）、使用 Loader 打包静态资源（样式篇）</h4>
<h5 id="21-安装有两种方式全局安装与局部安装">2.1 安装有两种方式：全局安装与局部安装</h5>
<ul>
<li>全局安装：<code>npm install webpack webpack-cli -g</code> 不推荐使用,卸载<code>npm uninstall webpack webpack-cli -g</code>;</li>
<li>局部安装：<code>npm install webpack webpack-cli --save-dev</code> 或者<code>npm install webpack webpack-cli -D</code>是等价的。局部安装的直接输入<code>webpack -v</code>是不能运行这个命令的，可以通过 <code>npx webpack -v</code>去运行命令。<code>npx</code>会从项目的<code>node_modul</code>去找<code>wenpack</code>包，所以可以通过<code>npx</code>去查找我们在项目中的<code>webpack</code>包;可以在不同的项目中使用不同版本的<code>webpack</code> ；<br>
输入<code>npm info webpack</code>可以查看包的信息，包括版本等信息。</li>
<li>安装指定版本的<code>webpack</code>:<code>npm install webapck@版本号 webpack-cli -D</code></li>
</ul>
<h5 id="22-使用配置文件">2.2 使用配置文件</h5>
<p><code>webpack</code>在进行打包的时候，首先会查找项目中是否存在配置文件<code>webpack.config.js</code>，如果没有，他会使用默认的配置文件进行打包。<br>
在项目的目录下新建<code>webpack.config.js</code>文件，里面输入内容：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')

module.exports = {
    // 入口文件
    entry: './src/index.js',
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,改成bundle就是说，打包后的文件放在bundle文件夹中
      path: path.resolve(__dirname,'bundle')
    }
}
</code></pre>
<p>代码的注释很详细，就不在重复；上面代码就是说将我们项目中的<code>/src/index.js</code>文件进行打包到<code>bundle</code>文件夹下的<code>bundle.js</code>中。<br>
一般情况，我们将我们的源代码放在<code>src</code>目录下。</p>
<blockquote>
<p>需要注意的是： <code>webpack</code>中默认的配置文件是<code>webpack.config.js</code>，我们可以输入命令<code>npx webpack --config webpackconfig.js</code>将默认的配置文件指向<code>webpackconfig.js</code>这个文件。</p>
</blockquote>
<p>我们每次进行打包的时候，都需要输入命令<code>npm webpack</code>,我们可以在<code>webpack.config.js</code>这个文件中进行配置我们允许的命令；如下面代码：</p>
<pre><code class="language-javascript">  &quot;scripts&quot;: {
    &quot;bundle&quot;: &quot;webpack&quot;
  },
</code></pre>
<p>上面的配置就是当我们输入<code>npm run build</code>的时候相当于输入 <code>npm webpack</code>,进行打包我们的文件。这里运行 <code>npm webpack</code>是不会进行全局检测是否安装了 <code>webpack</code>，而是从项目的<code>node_module</code>去查找。</p>
<blockquote>
<p>补充：查看官网的<code>guides</code>中的<code>Getting started</code>里面的内容</p>
</blockquote>
<h5 id="23-浅析打包输出的内容">2.3 浅析打包输出的内容</h5>
<p>我们输入命令<code>npm run bundle</code>或者<code>npx webpack</code>之后，控制台会输出下面的内容：</p>
<pre><code>Hash: 7d4f5a28d798a39e7e58
Version: webpack 4.31.0
Time: 293ms
Built at: 2019-05-16 08:56:10
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]

WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
</code></pre>
<p><code>Hash</code>：是对应打包成功后文件的<code>Hash</code>值是唯一值；<br>
<code>bundle.js</code>：我们打包出的文件；<br>
<code>Chunks</code>：我们打包后的文件，每一个文件都会有一个自己的<code>id</code>值，这里面存放该文件的<code>id</code>值跟与其他打包后的文件有关系的对应文件的<code>id</code>值；<br>
<code>Chunk Names</code>:存放<code>Chunks</code>中每一个<code>id</code>值对应的名字。这里的<code>main</code>，这里的入口文件，对应的名字就是<code>main</code>；我们前面说到配置打包的入口文件：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: './src/index.js',
</code></pre>
<p>其实是下面的简写形式：</p>
<pre><code class="language-javascript">    // 入口文件
    entry: {
      main: './src/index.js',
    },
</code></pre>
<p><code>WARNING in configuration</code>:这里的警告说，我们在进行打包的时候，没有配置打包的模式与打包的环境；其实我们在没有配置模式的情况下默认是<code>production</code>，如下面的代码：</p>
<pre><code class="language-javascript">// 引入node核心模块path
const path = require('path')
module.exports = {
    // 配置打包模式
    mode: 'production',
    // 入口文件
    entry: {
      main: './src/index.js',
    },
    // 打包出的文件配置
    output: {
      // 文件名
      filename: 'bundle.js',
      //  打包后的文件放在哪个文件夹，是一个绝对路径 
      //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
      path: path.resolve(__dirname,'dist')
    }
}
</code></pre>
<p>添加之后，再次进行打包就不会出现警告了：</p>
<pre><code>Hash: 81601a0beb210cf86adc
Version: webpack 4.31.0
Time: 632ms
Built at: 2019-05-16 15:20:51
    Asset      Size  Chunks             Chunk Names
bundle.js  1.36 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js 870 bytes {0} [built]
[1] ./src/header.js 249 bytes {0} [built]
[2] ./src/siderbar.js 246 bytes {0} [built]
[3] ./src/content.js 240 bytes {0} [built]
</code></pre>
<p>这个<code>production</code>模式打包后的文件，会对文件进行压缩，上面打包后的文件内容如下：打包为一行；</p>
<pre><code class="language-javascript">!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){&quot;undefined&quot;!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},t.t=function(e,n){if(1&amp;n&amp;&amp;(e=t(e)),8&amp;n)return e;if(4&amp;n&amp;&amp;&quot;object&quot;==typeof e&amp;&amp;e&amp;&amp;e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,&quot;default&quot;,{enumerable:!0,value:e}),2&amp;n&amp;&amp;&quot;string&quot;!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&amp;&amp;e.__esModule?function(){return e.default}:function(){return e};return t.d(n,&quot;a&quot;,n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p=&quot;&quot;,t(t.s=0)}([function(e,n,t){var r=t(1),o=t(2),u=t(3);new r,new o,new u},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;header&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;SiderBar&quot;,e.append(n)}},function(e,n){e.exports=function(){var e=document.getElementById(&quot;root&quot;),n=document.createElement(&quot;div&quot;);n.innerHTML=&quot;content&quot;,e.append(n)}}]);
</code></pre>
<p>我们将打包模式配置成<code>mode: 'development'</code>;打包后的内容就不会进行压缩，内容如下：</p>
<pre><code class="language-javascript">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode &amp; 1: value is a module id, require it
/******/ 	// mode &amp; 2: merge all properties of value into the ns
/******/ 	// mode &amp; 4: return value when already ns object
/******/ 	// mode &amp; 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode &amp; 1) value = __webpack_require__(value);
/******/ 		if(mode &amp; 8) return value;
/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === 'object' &amp;&amp; value &amp;&amp; value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
</code></pre>
<h5 id="24-loader解析">2.4 Loader解析</h5>
<p><code>webpack</code>本身只是识别<code>js</code>文件的打包，当我们需要进行打包比如图片等文件时，需要在配置文件里面进行配置；<code>webpack</code>在进行打包的时候，首先是直接打包<code>js</code>文件，然后其他的文件会通过配置文件里面的<code>module</code>里面进行查找对应文件的打包规则；如果我们需要对图片文件进行打包，配置如下：</p>
<pre><code class="language-javascript">    module: {
      rules: [{
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: 'file-loader'
        }
      }]
    },
</code></pre>
<p>然后记得进行安装对应的<code>loader</code>；输入命令：<code>npm install file-loader --save-dev</code>然后运行打包命令就可以了；<br>
<code>loader</code>就是一个打包方案，只要不是.<code>js</code>文件，就需要进行配置打包的规则。</p>
<h5 id="25-使用-loader-打包静态资源图片篇-url-loader的使用">2.5 使用 Loader 打包静态资源（图片篇）、url-loader的使用</h5>
<p>如果我们在打包静态资源的时候，比如图片，默认打包后的结果是会生成一个字符串为图片命名，我们现在希望我们打包之后他的文件名以及扩展名，也就是文件类型都是不会改变，可以进行如下配置：<code>[name].[ext]</code>分别代表的是之前文件的文件名以及之前文件的后缀，他其实就是一个<code>webpack</code>的一个占位符。可以在官网的<code>file-loader</code>里面可以看到很多占位符的用法。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                  // 占位符 Placeholders
                  name: '[name].[ext]'
                }
            }
        }]
    },
</code></pre>
<p>同时我们可以设置打包后输出的的文件夹的位置：下面是将图片文件打包在<code>images</code>文件夹中。可以查看官网的文档里面<code>file-loader</code>的相关配置。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'file-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/'
                }
            }
        }]
    },
</code></pre>
<h6 id="url-loader-的使用">url-loader 的使用:</h6>
<p><code>url-loader</code>可以进行上面的打包，但是唯一不同的是，<code>url-loader</code>是将图片直接打包成一个<code>base:64</code>的字符串，进行显示在<code>src</code>中。<br>
<img src="https://img-blog.csdnimg.cn/20190516200022406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这个会有一些问题，是减少了发送<code>http</code>请求，但是如果文件很大，加载的时间也是很长，页面会显示空白。如果图片小，可以使用这种方式进行打包。如果图片很大，需要将图片通过<code>file-loader</code>打包到一个文件夹，这样更适合项目。其实在<code>url-loader</code>中已经考虑到了，我们可以进行添加一个配置进行限制：<code>limit: 2048</code>意思就是如果图片超过2048个字节，也就是<code>2kb</code>就将图片打包到<code>imagees</code>文件夹中，如果小于，就直接生成一个<code>base:64</code>的字符串进行显示。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 2048
                }
            }
        }]
    },
</code></pre>
<p>可以查看官网<code>API</code>进行深入的研究这两个<code>loader</code>；</p>
<h5 id="26-使用-loader-打包静态资源样式篇">2.6 使用 Loader 打包静态资源（样式篇）</h5>
<p>首先需要进行配置打包<code>css</code>文件的打包配置，需要使用<code>style-loader、css-loader</code>两个<code>loader</code>进行打包。其中<code>css-loader</code>他是可以解析我们<code>css</code>文件之间的依赖关系，比如我们的<code>index.css</code>中引用了<code>avatar.css</code>文件，如下：<code>@import './avatar.css';</code>他就会进行解析，之间的依赖关系，最终将这些文件打包到一个文件中。<code>style-loader</code>的作用是，当得到<code>css-loader</code>打包后的内容之后，会将这些挂载到页面的<code>header部分</code>，也就是放在了<code>style</code>标签中。配置如下：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
        }]
    },
</code></pre>
<p>如果我们需要打包<code>.sass、scss</code>这些其他<code>css</code>文件，我们需要引入<code>sass-loader</code>进行打包:<code>npm install sass-loader node-sass webpack --save-dev</code>如下的配置：</p>
<pre><code class="language-javascript">    module: {
        rules: [ {
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader'
            ]
        }]
    },
</code></pre>
<p>其实<code>loader</code>的执行是有先后顺序的：从上到下、从右到左；比如上面的配置，首先是通过<code>sass-loader</code>进行处理，然后通过<code>css-loader</code>进行处理文件关系，最后通过<code>style-loader</code>进行挂载到页面。</p>
<h6 id="261-对于-css-打包进行添加厂商前缀使用postcss-loader自动添加厂商前缀">2.6.1 对于 css 打包进行添加厂商前缀，使用<code>postcss-loader</code>自动添加厂商前缀:</h6>
<p>首先进行安装<code>npm i -D postcss-loader</code>;然后新建<code>postcss.config.js</code>文件，然后进行安装一个<code>autoprefixer</code>插件，输入命令：<code>npm install autoprefixer -D</code>。<code>postcss.config.js</code>文件配置如下：</p>
<pre><code class="language-javascript">module.exports = {
    plugins: [
      require('autoprefixer')
    ]
}
</code></pre>
<p>最后需要记得在打包配置里面进行添加<code>postcss-loader</code>配置项：</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                'css-loader',
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>其实我们的厂商前缀是由<code>postcss-loader</code>里面我们添加的<code>autoprefixer</code>插件给我们添加的厂商前缀。</p>
<h6 id="262-css-loader-中一些常用的配置项">2.6.2 css-loader 中一些常用的配置项：</h6>
<p>我们在进行配置<code>loader</code>的时候，如果里面需要配置参数，那么将<code>loader</code>写成一个对象，而不是数组里面的字符串，我们给<code>css-loader</code>添加一个选项：<code>importLoaders: 2</code>，如下面代码：<code>importLoaders: 2</code>参数的意思是：如果我们在<code>js</code>文件里面通过<code>import</code>语句进行引入<code>scss</code>文件是可以进行打包的，按照我们前面说的，从下往上执行<code>loader</code>,但是如果我们的在<code>js</code>文件中引入的<code>scss</code>文件中还通过<code>import</code>引入了其他<code>scss</code>文件，那么这里的<code>scss</code>文件在进行打包的时候不会进行类似在<code>js</code>文件中<code>scss</code>打包的过程从下往上执行<code>loader</code>，所以我们需要添加配置项<code>importLoaders: 2</code>，意思就是我们在打包<code>scss</code>文件的时候（或者<code>css</code>）需要执行前面两个<code>loader</code>，这样就保证了不管<code>scss</code>文件（或者<code>css</code>）中通过<code>import</code>引入多少其他的<code>scss</code>文件（或者<code>css</code>），都能够正常的打包，都会依次从上到下依次执行<code>loader</code>进行打包。</p>
<pre><code class="language-javascript">    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<h6 id="263-css-文件模块化打包只在一个模块内有效">2.6.3 css 文件模块化打包：只在一个模块内有效</h6>
<p>我们在写<code>css、scss</code>的时候会直接将他们在代码中进行引入，如下：这会导致如果页面创建元素，所有的元素的样式都会受到影响，</p>
<pre><code class="language-javascript">import  './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<p>在<code>createAvatar.js</code>文件中也是创建一个<code>img</code>标签：</p>
<pre><code class="language-javascript">import avater from './avater.png'
function createAvatar () {
    var img = new Image();
    img.src = avater;
    img.classList.add('avater')
    var dom = document.getElementById('root');
    dom.append(img);
}
export default createAvatar
</code></pre>
<p>在<code>index.scss</code>中，代码如下：</p>
<pre><code class="language-css">
body {
    .avater {
        height: 150px;
        width: 150px;
        transform: translate(100px, 100px);
    }
}
</code></pre>
<p>这样写会导致页面中两个图片显示都一样，都使用了<code>index.scss</code>中的样式；解决这个问题，就是我们可以在打包<code>css</code>这些文件的时候，实现模块化打包，如下面代码：<br>
在打包的时候，进行配置打包为模块;<code>modules: true</code>意思就是开启模块化打包。</p>
<pre><code class="language-javascript">module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2,
                    modules: true
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }]
    },
</code></pre>
<p>然后在代码中通过<code>style.avater</code>这种方法，进行添加样式，这样就不影响全部文件了。</p>
<pre><code class="language-javascript">import style from './index.scss';
import avater from './avater.png';

import createAvatar from './createAvatar'

createAvatar();
// 打包图片文件--avater为打包后的文件名
var img = new Image();
img.src = avater;
img.classList.add(style.avater)
var dom = document.getElementById('root');
dom.append(img);
</code></pre>
<h6 id="264-打包字体文件">2.6.4  打包字体文件：</h6>
<p>我们项目里面也经常会用到图片库中的小图片，比如<code>iconfont</code>里面的小图片，我们查看<code>iconfont.css</code>发现，里面引入了<code>eot|ttf|svg|woff</code>这些文件，如下面代码：</p>
<pre><code class="language-css">@font-face {
    font-family: &quot;iconfont&quot;;
    src: url('./font/iconfont.eot?t=1558162704401'); /* IE9 */
    src: url('./font/iconfont.eot?t=1558162704401#iefix') format('embedded-opentype'), /* IE6-IE8 */
    url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAASIAAsAAAAACQgAAAQ7AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCfgqFVIRuATYCJAMMCwgABCAFhG0HWxvRBxHVoy2Q/SxwzuYE2hXq6ImKdq351ClK774P+U+55ftJYCczKxZYca2qhqqHlK24nUQMelK9FgLpdvvtgwTDKPAeOIriDMIYEisANjdD9/zrCMWSnOf9tMy0dKYX0l//czm9awvOD5TLXMuOegGGvYACGmPbAgq0QBL0luFVB7kbx4EAXIwsNBq16ABGoY8jAN1DB/cFS+goFcWEIdaCpQV60LG2WLoDYKX3ffpREAyQWBL61DaDGg5Anff0XpJ1r+50EPD7swBgVwEyIAugAB2FtjaQg1gWGZdtiqTqSgXBe8nrdXDEm+0fHkAkoAm6zBcT0+ISvCeLv2t8jAN/31cBVgAD/KeVEEN3tJC34tqkxgXGTXfu3rlOc+Hr8MTcgtOSZ+3EUtPhtPGde0E3oi52evhU0NLOz59jd2fHqMcOJzH9aVu+ZJ1uCLHUbjdt5HAiDzx61pbXhwd6tFHySNO01ZCj8/OxS00ix/7dJ0PLqOZyCt95MQyuS8liz5VIqjb2mDW2dlPIXA/rQrkT1MMuDA2uc6mtTW+mbvTjrn1LDzj2L9k7nXc2x/GEdvDtNJpV1zp2gypowHGWmss91q3j/kucZHGY9gDD0AZ06pO7BjY2dOwwyZt01y77UnvnPY7KoDOqqHeEt4hBq+jG0Q2HDWvo3qU1Wiwqad9EuDX31jEYFDiWezSPWuu6WdkBXdvGt4yfOiXOrmmLLgk3fnYYtWktF5e2b/3+HjE28ELhIt/x3G1z8/Kr68rbo2ub+FZxU6bGtUxo2zWhbvgrVVl9RW0Z2zqmcVRDu79wi7pB4of00ieV0apXehC7x4L0V6uIUZ1JeW/lSTsn1Ss7KmKZ/kpX76nOnVhdS//Izv3GW+tyT3G/NHRKGJQwMKEjSpfDB3r3Ghz6PXTSnDnclEwKxJNTvXY8GOzXzW/Qg3cPJnmPmsy2+BxQ37ELrJt6fsw7fT/z45fmG22bHfdtLL5pblGya8Ku8ZWrLf/OW/gez1jlt7tslshAHwCA91KekTNJ4nqek8v/ld8g8P38sHdA1T8mFADAS8u9QOzxXirAHAC7m3aCP4MPrFMUoa6XS+JZPC0pO4x+77XgihNe6K5gnvYKDVwIEEaLQOIjGmRMEqoQs8BCKAIrpjZwmRqvFkKMg4xKBZBhPgIS6AhI/F0BWaC7qEJ0g4XNN7AKDBm4ThSypZASuFU74yK4w/oDu1HSplGUX3xDU8LCcaFHfSGfNghd3aaTV0zIfcw436YX0aCZIozoNAyBIDM53KQ+RPLQNLroRfVGsVLqMy6CO1h/wG6UtNNcVObzNzQlLFyBKbO+kE/bOejUWgB6lSUQ5lx6n2/TE9HUKM0UwYgtGIwYgVw8yOEmtaNFJA8a0khDZfX4inh922CmT81okVHCriWZ/1FMit0iU0QrfosS7CXX8isp8K5UVQA=') format('woff2'),
    url('./font/iconfont.woff?t=1558162704401') format('woff'),
    url('./font/iconfont.ttf?t=1558162704401') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
    url('./font/iconfont.svg?t=1558162704401#iconfont') format('svg'); /* iOS 4.1- */
  }
</code></pre>
<p>我们如果直接使用<code>webpack</code>打包会提示报错，无法打包那些后缀的文件，我们可以通过<code>file-loader</code>进行打包这些字体文件，在<code>webpack.config.js</code>里面进行配置，如下：使得将字体文件打包到<code>dist</code>的相对路径里面，我们直接使用。</p>
<pre><code class="language-js">    module: {
        rules: [ {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }]
    },
</code></pre>
<blockquote>
<p>然后我们可以继续深入，查看官网的<code>document</code>中的<code>GUIDS</code>里面的<code>Asset Management</code>里面的内容，还有<code>loader</code>里面的<code>sass-loader、css-loader、postcss-loader</code>进行深入了解。</p>
</blockquote>
<h4 id="3-使用plugins让打包更便捷">3. 使用Plugins让打包更便捷</h4>
<h5 id="3-1-html-webpack-plugin-插件的使用将html进行打包并根据设置的html模板进行打包">3. 1    html-webpack-plugin 插件的使用——将html进行打包，并根据设置的html模板进行打包</h5>
<p>我们在打包的时候，每次打包之后，打包后的文件，并没有<code>index.html</code>就是我们在<code>src</code>文件夹里面写的网页，都需要我们进行复制到<code>dist</code>目录里面，很是麻烦，我们可以使用<code>webpack</code>插件，来帮助我们解决这个问题。<br>
首先需要安装这个插件:<code>cnpm install --save-dev html-webpack-plugin</code>,然后在<code>webpack.config.js</code>里面进行配置，代码如下：</p>
<pre><code class="language-javascript">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>这样，打包之后，会将我们的<code>html</code>文件也会进行打包，<code>html-webpack-plugin</code>这个插件在打包结束后，自动生成一个<code>html</code>文件，并把打包生成的<code>js</code>自动引入到这个<code>html</code>中。我们打开打包后的<code>html</code>文件，会发现，我们在里面的<code>html</code>结构没有显示，比如我们在里面写的<code>&lt;div&gt;&lt;/div&gt;</code>没有被打包显示，这个时候，我们需要对<code>html-webpack-plugin</code>这个插件进行配置一个<code>template</code>选项，让他根据模板进行打包我们的<code>html</code>文件，模板文件也就是我们需要打包的文件，也就是以模板文件进行打包。配置如下：</p>
<pre><code class="language-js">const HtmlWebpakcPlugin = require('html-webpack-plugin')

module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    })],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p><code>Plugin</code>可以在<code>webpack</code>运行到某一时刻的时候，帮你做一些事情，很类似<code>vue</code>的声明周期函数；</p>
</blockquote>
<h5 id="32-clean-webpack-plugin-插件的使用清除打包地址的文件">3.2  clean-webpack-plugin 插件的使用——清除打包地址的文件</h5>
<p>我们在查看我们打包后的内容，我们如果将<code>output</code>配置里面的输出文件名修改为其他的，我们重新进行打包，会发现，打包是成功了，但是我们修改之前打包的<code>js</code>文件还是存在在<code>dist</code>文件夹中，我们需要做的是，每次打包之前，需要将<code>dist</code>中之前打包的文件先进行删除，然后再次进行打包<code>js</code>文件。这个时候，我们需要引入一个插件<code>clean-webpack-plugin</code>,<br>
首先输入命令进行安装：<code>npm install clean-webpack-plugin -D</code><br>
然后在<code>webpack.config.js</code>里面进行配置，如下：<code>new CleanWebpackPlugin()</code>意思是每次打包之前删除<code>dist</code>里面所有的内容。</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
module.exports = {
    // 配置打包模式
    mode: 'development',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    plugins: [new HtmlWebpakcPlugin({
      template: './src/index.html'
    }),new CleanWebpackPlugin()],
    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'bundle.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<blockquote>
<p>这里需要注意的是<code>HtmlWebpakcPlugin</code>是在打包之后运行的插件，<code>CleanWebpackPlugin</code>是在打包之前运行的插件。还有一个需要注意的是<code>new CleanWebpackPlugin(['dist'])</code>这里的<code>dist</code>是不需要添加的，直接<code>new CleanWebpackPlugin()</code>就好了</p>
</blockquote>
<h4 id="4-entry-与-output-的基础配置">4. Entry 与 Output 的基础配置</h4>
<h5 id="41-多个文件的打包">4.1 多个文件的打包</h5>
<p>我们在打包文件的时候，经常会遇到打包多个文件，而不是一个<code>js</code>文件，这时候我们需要修改我们的配置；比如，下面代码，我们打包<code>main</code>跟<code>sub</code>的文件：</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        sub: './src/index.js'
    },
</code></pre>
<p>如果我们还是用之前的打包输出的配置；就会报错，提示多个文件打包到一个文件的错误:</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: 'main.js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这个时候我们需要配置输出的文件，让他根据入口配置的文件，也就是那个对象的键，根据键来进行打包输出文件，配置如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样，打包后输出的文件分别为<code>main.js</code>跟<code>sub.js</code>；这样就完成了多个文件的打包。</p>
<h5 id="42-将打包后的js文件在html中通过配置cdn地址进行引入">4.2 将打包后的js文件在html中，通过配置cdn地址进行引入</h5>
<p>我们经常会遇到，我们在打包我们的<code>js</code>代码之后，会将<code>js</code>文件放在<code>cdn</code>服务器上，通过<code>cdn</code>服务器的地址来在页面进行引入脚本。比如，我们希望在<code>html</code>引入<code>js</code>的时候地址前面加上<code>cdn</code>域名：<code>http://cdn.com/main.js</code>这样。我们需要在<code>output</code>里面进行配置一个<code>publicPath</code>的选项：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        publicPath: 'http://cdn.com.cn',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>打包后<code>html</code>的引入如下：</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/main.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/sub.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>进一步学习：查看官网的<code>document</code>里的<code>configuration</code>中的<code>output</code>的配置参数。然后进行查看<code>guides</code>里面的<code>output management</code>里的内容。查看<code>plugins</code>里面的<code>htmlwebpackplugin</code>插件，查看该插件对应的官网。</p>
<h4 id="5-sourcemap-的配置">5. SourceMap 的配置</h4>
<p>我们在前面配置了我们的打包模式 为开发者模式：<code>mode: 'development',</code>在这个模式，默认<code>SourceMap</code>已经被配置进去了，我们可以关掉认<code>SourceMap</code>，配置如下：</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'none',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101150701.png" alt="在这里插入图片描述"><br>
如果我们关闭了<code>SourceMap</code>，我们如果在写代码的时候，不小心制造一个小<code>bug</code>，比如说我们把<code>console</code>写成了<code>conssole</code>这样，在打包时，是不会出现问题的，但是在页面的控制台会提示，该方法不存在，我们点击之后，提示打包后的文件的第153行报错，其实我们真正 想知道的不是打包后文件哪里出错，而是我们在源代码里哪个位置出现错误；而<code>SourceMap</code>他是一个映射关系，他知道<code>dist</code>目录下的<code>main.js</code>也就是我们打包生成的文件153行实际上对应是<code>src</code>目录下<code>index.js</code>文件也就是我们的源代码文件中的第58行。我们可以通过<code>SourceMap</code>获取到<code>index.js</code>中第一行代码出错了；所以我们需要进行配置<code>SourceMap</code>，来根据<code>SourceMap</code>的映射关系，找到我们源代码出错位置：我们查看打包后的文件，会多出一个<code>main.js.map</code>的文件，就是我们的源文件，存放着映射关系。</p>
<pre><code class="language-js">    // 配置打包模式
    mode: 'development',
    devtool: 'source-map',
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190519101052959.png" alt="在这里插入图片描述"><br>
我们可以查看官网有关<code>SourceMap</code>的配置，也就是<code>devtool</code>的配置，其中如果将<code>devtool</code>配置成<code>inline-cheap-source-map</code>意思他会将打包后的<code>SourceMap</code>直接通过地址放在在打包的文件代码的底部：</p>
<pre><code class="language-js">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQ
</code></pre>
<p>这里，需要说明的是，前面我们进行配置成<code>source-map</code>，点击报错，他会提示代码报错位置的行与列，其实我们在查看问题的时候，并不需要精确到哪一列代码出现问题，只需要知道在哪一行；这时候我们可以将<code>devtool</code>配置成<code>cheap-source-map</code>，他只会提示代码在哪一行报错。<br>
这里的<code>cheap-source-map</code>他就会映射我们写的业务代码，比如打包的文件<code>index.js</code>而不会将我们在<code>loder</code>里面引入的第三方模块代码的映射，如果需要映射<code>loder</code>里面的的代码需要将配置修改为<code>cheap-module-inline-source-map</code><br>
还有一种打包方式就是<code>eval</code>，他是打包速度最快的，但是如果代码过多，也会影响打包速度；</p>
<blockquote>
<p>这里建议我们配置<code>sourceMap</code>的打包方式，如果是在<code>development</code>环境进行打包的时候，将<code>devtool</code>配置成<code>cheap-module-eval-source-map</code>，提示的错误比较全，打包速度也是比较快。如果我们代码已经上线，也就是在<code>production</code>模式下，我们可以将<code>devtool</code>配置成<code>cheap-module-source-map</code>，这样提示效果会好一些。</p>
</blockquote>
<h4 id="6-使用-webpackdevserver-提升开发效率">6. 使用 WebpackDevServer 提升开发效率</h4>
<p>我们现在每次进行打包的时候还要需要输入打包命令，打包之后在将<code>html</code>打开，查看打包结果；这样操作是比较麻烦的，我们需要的是可以监听到我们改动的文件，然后自动进行重新打包，我们有三种方法进行配置；</p>
<h5 id="61-第一种我们可以在packagejson进行配置监听文件变化">6.1 第一种：我们可以在package.json进行配置，监听文件变化</h5>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;
  },
</code></pre>
<p>他的意思是，会进行监听我们打包的文件，只要打包文件发生变化，就会重新打包。</p>
<h5 id="62-第二种监听打包文件变化并自动启动服务器加载html文件">6.2 第二种：监听打包文件变化，并自动启动服务器，加载html文件</h5>
<p>我们的第二种打包方式是，我们不仅需要监听打包文件的变化并重新打包，而且需要在打包完成之后，直接打开我们的<code>html</code>文件，类似在服务器中。前提是首先安装<code>webpack-dev-server</code>,输入命令：<code>npm install webpack-dev-server -D</code>。<br>
我们可以在<code>webpack.config.js</code>添加一个<code>devServer</code>配置：</p>
<pre><code class="language-js">module.exports = {
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist'
    }
}
</code></pre>
<p>然后在<code>package.json</code>里面添加一个运行命令，来运行我们的服务器：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;start&quot;: &quot;webpack-dev-server&quot;
  },
</code></pre>
<p>这时候会启动一个服务器，<code>webpack-dev-server</code>比我们之前配置的<code>webpack --watch</code>这种方式的好处是，他不仅会监听我们打包文件变化，并进行更新打包，而且也会重新刷新我们的网页。我们还可以在<code>webpack.config.js</code>中的<code>devServer</code>配置添加一个<code>open: true</code>选项，他会在打开服务器后，自动打开浏览器，并自动访问启动的服务器地址，打开网页，不用我们手动进行将服务器启动后的地址输入到浏览器进行打开：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true
    },
</code></pre>
<p>还有一个就是我们在使用<code>vue-cli</code>脚手架的时候，我们会在<code>devServer</code>里面配置一个<code>proxy</code>选项，用来模拟后台<code>API</code>请求地址或者转发我们的接口<code>API</code>地址，解决跨域代理；如下面的配置：他的意思是当我们访问<code>localhost:8080/api</code>地址的时候，他会自动将地址转发到<code>localhost:3000</code>端口。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      }
    },
</code></pre>
<h5 id="63-第三种自己手写一个服务器实现类似webpack-dev-server的效果">6.3 第三种：自己手写一个服务器，实现类似Webpack-dev-server的效果</h5>
<p>首先在<code>package.json</code>里面进行配置命令，使得运行命令之后，就运行我们的脚本文件：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;middleware&quot;: &quot;node server.js&quot;
  },
</code></pre>
<p>我们可以借助<code>node</code>的框架，去搭建服务器，这里使用<code>express</code>框架来实现，首先进行安装该框架：<code>npm install express webpack-dev-middleware -D</code>,我们这里同时安装了一个<code>webapck</code>的<code>webpack-dev-middleware</code>中间件，用来监听我们打包文件的变化，来自动进行打包。<br>
然后我们修改<code>webpack.config.js</code>里面的<code>output</code>配置，添加一个<code>publicPath: '/'</code>将文件打包成功后的引用地址前面都加一个根路径，确保打包生成文件的引用路径不会出现错误。</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: '/',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>然后我们的<code>server.js</code>代码如下：</p>
<pre><code class="language-js">const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');
const config = require('./webpack.config.js');
// 进行webpack编译--执行编译器，进行打包一次代码,
// 在node中直接使用webpack
const complier = webpack(config);

const app = express();
// 只要打包的文件内容发生变化，就会重新打包，通过编译器；将打包的文件放在跟webpack.config.js配置的一致
app.use(webpackDevMiddleware(complier, {
  publicPath: config.output.publicPath
}));

app.listen(3000, () =&gt; {
  console.log('server is run')
})
</code></pre>
<p>上面的我们是直接通过调用<code>webpack</code>配置在<code>node</code>里面使用<code>webpack</code>，我们也可以直接在命令行里去执行<code>webpack</code>，可以在官网的<code>API</code>里面的<code>Command Line Interface</code>查找到很多的命令：比如<code>webpack index.js -o main.js</code>将<code>index.js</code>打包成<code>main.js</code>输出。如果需要查找在<code>node</code>里面运行<code>webpack</code>，可以查看<code>node.js APi</code>里面去查找。</p>
<blockquote>
<p>深入学习：打开官网的<code>documentation</code>里面的<code>Guides</code>中的<code>development</code>里面的内容阅读，然后查看<code>configuration</code>里面有关<code>devtool、devServer</code>里面的内容。</p>
</blockquote>
<h4 id="7-hot-module-replacement-热模块更新">7. Hot Module Replacement 热模块更新</h4>
<p>我们使用<code>webpack-dev-server</code>帮助我们进行打包，会发现不会产生一个<code>dist</code>，因为他会生成一个打包文件，不过没有放在文件里面而是放在了计算机的内存中，可以有效提升打包的速度。<br>
我们在写代码的时候，经常会碰到，我们在修改了我们的<code>css</code>文件后，只是想每次在更新页面的时候，只是将样式文件重新加载，进行渲染，并不想让整个页面进行重新加载，破坏了我们页面的状态；我们想做的就是每次改完样式文件之后，只是重新加载样式文件，不破坏页面的状态；我们可以使用热模块更新来解决这个问题：我在<code>webpack.config.js</code>里面的<code>devServer</code>配置项中添加一个<code>hot: true</code>(让<code>webpack-dev-server</code>开启热模块更新的功能)选项跟<code>hotOnly：true</code>(即便是HTML的功能没有生效，也不让浏览器自动重新刷新，)</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
</code></pre>
<p>然后我们在<code>webpack.config.js</code>中引入<code>webpack</code>，在<code>plugin</code>里面进行添加一个<code>webpack</code>的插件<code>webpack.HotModuleReplacementPlugin()</code>;代码如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');
module.exports = {
    //....
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.HotModuleReplacementPlugin()
    ]
 }
</code></pre>
<p>这样，如果只改了<code>css</code>样式，页面不会从新加载，只会重新加载<code>css</code>文件。<br>
如果对于<code>js</code>文件，也想通过热模块更新，在<code>webpack.config.js</code>里面的配置跟上面一样，但是我们在代码里面需要进行判断，加一些代码逻辑，用来判断是否开启热模块更新，然后进行处理我们的逻辑：需要进行监控我们需要修改的文件</p>
<pre><code class="language-js">// 如果支持热模块加载
if(module.hot) {
    // 监控number文件，如果发生改变，就会执行里面的代码。
    // 第一个参数为依赖的文件的名字，
  module.hot.accept('./number', ()=&gt; {
    document.body.removeChild(document.getElementById('number'))
    number();
  })
}
</code></pre>
<blockquote>
<p>查看官方文档<code>guides</code>里面的<code>Hot Module Replacement</code>中的内容深入了解，然后查看<code>api</code>查看<code>Hot Module Replacement</code>配置选项，然后进行查看<code>concepts</code>里面的<code>Hot Module Replacement</code>内容，进行更深入的了解。</p>
</blockquote>
<h4 id="8-使用-babel-处理-es6-语法">8. 使用 Babel 处理 ES6 语法</h4>
<h5 id="81-使用-babel-按需打包js文件">8.1 使用 Babel 按需打包js文件</h5>
<p>首先进行安装，输入命令<code>npm install --save-dev babel-loader @babel/core</code>，然后在<code>webpack.config.js</code>增加一个规则，如下：代码意思就是除了<code>node_modules</code>里面的<code>js</code>内容不检测，其他的<code>js</code>文件文件都通过<code>babel-loader</code>进行加载转换。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot; 
    }
  ]
}
</code></pre>
<p>其实<code>babel-loader</code>只是<code>Babel</code>与<code>webpack</code>之间的一个通讯工具，<code>babel-loader</code>并不会将<code>es6</code>语法翻译为<code>es5</code>语法，而<code>babel/preset-env</code>才是真正转换的工具。首选进行安装，输入命令：<code>npm install @babel/preset-env --save-dev</code>，然后进行配置在<code>webpack.config.js</code>：</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
         presets: [&quot;@babel/preset-env&quot;]
      }
    }
  ]
}
</code></pre>
<p>也可以新建一个<code>.babelrc</code>的文件，然后里面增加配置，启用一些插件。</p>
<pre><code class="language-js">{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}
</code></pre>
<p>这种转换只是一部分，低版本的有些函数还是不存在的，比如<code>promise</code>等函数，我们还需要借助<code>@babel/polyfill</code>，进行对低版本浏览器对<code>es6</code>中这些函数的支持，输入命令进行安装：<code>npm install --save @babel/polyfill</code>,然后全局引入，放在业务代码的最顶部，</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;
</code></pre>
<p>这样全局引入，会将所有<code>es6</code>的新增的函数打包到<code>js</code>文件中，这样会使打包的文件体积增大。我们需要的是在该<code>js</code>文件中使用的<code>es6</code>函数的实现，在<code>webpack.config.js</code>进行配置;</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
       presets: [[&quot;@babel/preset-env&quot;,{
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>就会实现按需加载，如果<code>js</code>中有用到<code>es6</code>新增函数，会将对应的实现代码打包到<code>js</code>中，而不是将全部<code>es6</code>新增的函数实现方式打包进去。</p>
<h5 id="82-打包转换中的其他参数设置打包支持浏览器的版本-编写类库文件babel转换配置">8.2 打包转换中的其他参数（设置打包支持浏览器的版本、编写类库文件babel转换配置）</h5>
<p>我们在打包的选项中，还可以进行配置其他选项，比如可以进行配置打包支持浏览器的版本，<code>babel</code>可以根据打包后支持的浏览器，去进行判断需要打包哪一些<code>es6</code>语法的实现函数，代码如下：这句代码是设置了打包后的为高于谷歌67版本的浏览器。</p>
<pre><code class="language-js">module: {
  rules: [
    { 
      test: /\.js$/,
      exclude: /node_modules/,
      loader: &quot;babel-loader&quot;,
      options: {
      presets: [[&quot;@babel/preset-env&quot;,{
        targets: {
           chrome: &quot;67&quot;,
         },
         useBuiltIns: 'usage'
        }]]
      }  
    }
  ]
}
</code></pre>
<p>我们如果写业务代码需要使用<code>babel</code>转换的时候，使用上面的配置就可以了，我们如果编写一个类库或者一个UI组件，需要进行不同的配置，配置步骤如下：<br>
安装<code>plugin-transform-runtime</code>,输入命令：<code>npm install --save-dev @babel/plugin-transform-runtime</code>，然后进行安装<code>babel/runtime</code>，输入命令：<code>npm install --save @babel/runtime</code>,然后进行安装<code>babel/runtime-corejs2</code> ,输入命令：<code>npm install --save @babel/runtime-corejs2</code>，然后在<code>webpack.config.js</code>进行配置;这样配置的好处是，我们在使用<code>babel</code>转换的时候，借助<code>polyfill</code>在全局进行注入，这样会污染全局，使用下面的配置，他会以闭包的形式，进行注入支持<code>es6</code>语法的函数。不存在全局污染。</p>
<pre><code class="language-js">    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;,
            options: {
            &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;,{
                &quot;corejs&quot;: 2,
                &quot;helpers&quot;: true,
                &quot;regenerator&quot;: true,
                &quot;useESModules&quot;: false
              }]]
            } 
        }]
    },
</code></pre>
<p>如果我们配置的<code>options</code>会很多的时候，可以在项目里面新建一个<code>.babelrc</code>的文件，将<code>options</code>里面的内容写在这里。然后去掉<code>webpack.config.js</code>中我们配置的<code>babel-loader</code>中<code>options</code>里面的内容。</p>
<h4 id="9-webpack-实现对react框架代码的打包">9. Webpack 实现对React框架代码的打包</h4>
<p>写<code>react</code>首选需要安装他，输入命令<code>npm install react react-dom --save</code>,然后在我们的<code>js</code>文件写<code>react</code>代码，如下：</p>
<pre><code class="language-js">import &quot;@babel/polyfill&quot;;

import React, {Component} from 'react'

import ReactDom from 'react-dom'

class App extends Component {
  return () {
    return &lt;div&gt;Hello World&lt;/div&gt;
  }
}
ReactDom.render(&lt;App /&gt;, document.getElementById('root'))
</code></pre>
<p>安装<code>babel/preset-react</code>，进行转换；输入命令<code>npm install --save-dev @babel/preset-react</code>,然后在<code>.babelrc</code>文件中增加配置：</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ]
}
</code></pre>
<p>这里的插件执行是从下往上执行的，就是先进行打包<code>react</code>代码，然后进行<code>es6</code>代码的转换。</p>
<h4 id="10-webpack-打包的一些坑">10. Webpack 打包的一些坑</h4>
<p>是遇到很多坑，比如使用了<code>html-webpack-plugin</code>插件，然后我们允许<code>webpack-dev-server</code>命令的时候，我们配置了打包入口的<code>html</code>模板，但是启动服务之后，没有页面显示，查看打包信息出现<code>Entrypoint undefined = index.html</code>，<code>webpack.config.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
        // sub: './src/index.js'
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpakcPlugin({
            template: './src/index.html'
        }),
        
    ],
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>后来经过测试，将输出配置成如下：</p>
<pre><code class="language-js">    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
</code></pre>
<p>这样就可以了，不要配置，打包输出的文件名以及地址就可以，虽然是解决了允许服务器没有显示页面的问题，但是这个解决办法还不是最佳。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebPack 4.X 高级概念笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-4x-gao-ji-gai-nian-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-4x-gao-ji-gai-nian-bi-ji">
        </link>
        <updated>2019-12-06T01:39:56.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-tree-shaking-概念详解">1. Tree Shaking 概念详解</h4>
<h5 id="11-babelpolyfill与babelpreset-env之间的引用小冲突">1.1 babel/polyfill与babel/preset-env之间的引用小冲突</h5>
<p>在<code>webpack 4.x</code>的版本中，如果我们在业务代码里面引用了<code>impport @babel/polyfill</code>，而且我们还对<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，我们在打包的时候，会提示下面的信息：</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-tree-shaking-概念详解">1. Tree Shaking 概念详解</h4>
<h5 id="11-babelpolyfill与babelpreset-env之间的引用小冲突">1.1 babel/polyfill与babel/preset-env之间的引用小冲突</h5>
<p>在<code>webpack 4.x</code>的版本中，如果我们在业务代码里面引用了<code>impport @babel/polyfill</code>，而且我们还对<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，我们在打包的时候，会提示下面的信息：</p>
<!-- more -->
<p><img src="https://img-blog.csdnimg.cn/20190523200107374.png" alt="在这里插入图片描述"><br>
提示的意思是，如果我们在<code>babel-loader</code>中的这个插件<code>@babel/preset-env</code>配置了<code>useBuiltIns: 'usage'</code>，可以不再业务代码里面，再次引入<code>impport @babel/polyfill</code>，<code>@babel/preset-env</code>插件会自动进行查看代码中<code>es6</code>语法进行添加对应的实现函数。</p>
<h5 id="12-tree-shaking-概念">1.2 Tree Shaking 概念</h5>
<p>我们在打包文件的时候，比如下面代码，有一个<code>math.js</code>文件，然后在<code>index.js</code>进行引入，代码如下：<br>
<code>math.js</code>文件</p>
<pre><code class="language-js">export const add = (a, b) =&gt;{
  console.log(a + b)
}
export const minus = (a, b) =&gt;{
  console.log(a - b)
}
</code></pre>
<p>·<code>index.js</code>里面内容</p>
<pre><code class="language-js">import { add } from './math.js';
add(1, 2);
</code></pre>
<p>这样，我们只是引入了<code>add</code>方法，但是我们查看打包的内容，会发现，他会将<code>math.js</code>文件所有的文件，都会打包到打包输出文件中，我们并不想让没有引入的方法等打包输出：</p>
<pre><code class="language-js">/*! exports provided: add, minus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;add\&quot;, function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;minus\&quot;, function() { return minus; });\nconst add = (a, b) =&gt; {\n  console.log(a + b);\n};\nconst minus = (a, b) =&gt; {\n  console.log(a - b);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoLmpzPzVhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PntcclxuICBjb25zb2xlLmxvZyhhICsgYilcclxufVxyXG5leHBvcnQgY29uc3QgbWludXMgPSAoYSwgYikgPT57XHJcbiAgY29uc29sZS5sb2coYSAtIGIpXHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/math.js\n&quot;);

</code></pre>
<p>这个时候，我们需要使用<code>Tree Shaking</code>功能来实现，不过需要注意的是<code>Tree Shaking</code>只支持<code>ES Module</code>，也就是只支持<code>import</code>这种方式的引入，不支持<code>require</code>这种<code>CommonJS</code>的引入方式，是因为<code>ES Module</code>这种底层是静态引入的方式，而<code>import</code>这种方式底层是动态的引入方式，<code>Tree Shaking</code>只支持静态引入的这种方法。我们在<code>webpack.config.js</code>中进行下面的配置：这里需要注意的是，我们下面的配置在开发模式下的配置<code>mode</code>为<code>development</code>；</p>
<pre><code class="language-js">   ....
module.exports = {
    // 配置打包模式
    mode: 'development',
   ....
    optimization: {
      usedExports: true
    },
   ....
}
</code></pre>
<p><code>usedExprots: true</code>意思就是我们去查看哪些导出的模块被使用，然后再进行打包；然后我们在<code>package.json</code>中进行下面的配置：添加<code>&quot;sideEffects&quot;: false,</code>意思就是，对所有的模块都进行<code>Tree Shaking</code>也就是将没有引入的方法等不进行打包到打包输出文件中。</p>
<pre><code class="language-js">{
  &quot;name&quot;: &quot;webpack&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;sideEffects&quot;: false,
  &quot;description&quot;: &quot;&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;bundle&quot;: &quot;webpack&quot;,
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;start&quot;: &quot;webpack-dev-server&quot;,
    &quot;server&quot;: &quot;node server.js&quot;
  },
</code></pre>
<blockquote>
<p>这里的<code>&quot;sideEffects</code>有很大的用途，比如我们在使用<code>@babel/polyfill</code>的时候，他的内部并没有使用<code>export</code>导出任何模块，他只是通过类似<code>windows.Promise</code>这样给全局T添加一些函数，但是我们使用<code>Tree Shaking</code>这种去打包的时候，他会发现这个模块我们并没有通过<code>import</code>引入任何模块，他会以为，我们并没有使用这个模块，不会对他进行打包，这时候，我们需要这样配置：添加<code>&quot;sideEffects&quot;: [&quot;@babel/polyfill&quot;]</code>这样，我们在打包的时候不会对这个模块进行<code>Tree Shaking</code>检查。</p>
</blockquote>
<p>一般我们在配置<code>sideEffects</code>选项的时候会配置成下面的：意思就是除了我们通过这种<code>import &quot;./strle.css&quot;</code>也不进行<code>Tree Shaking</code>检查，其他的对进行<code>Tree Shaking</code>检查，因为如果进行检查，会忽略我们的样式。</p>
<pre><code class="language-js">  &quot;sideEffects&quot;: [
   &quot;*.css&quot;
]
</code></pre>
<p>然后我们对上面的<code>inedx.js</code>进行重新打包，查看打包内容：<code>exports used: add</code>意思只有<code>add</code>方法被使用了。<code>Tree Shaking</code>并没有生效，因为开发环境下<code>Tree Shaking</code>会保留我们没用引入的代码，因为我们在查看报错的时候，如果去除了没有引入的代码，显示的行数会跟源代码不一致。如果我们的<code>mode</code>为<code>production</code>的时候，<code>Tree Shaking</code>就会生效了，其实在<code>mode</code>为<code>production</code>的时候，<code>optimization: { usedExports: true}</code>已经是配置好的，我们没必要再次进行配置，但是<code>package.json</code>中的<code>sideEffects</code>配置，还是需要的；同时将<code>devtool</code>改成：<code>devtool: 'cheap-module-source-map',</code></p>
<pre><code class="language-js。">/*! exports provided: add, minus */
/*! exports used: add */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
eval(&quot;/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;a\&quot;, function() { return add; });\n/* unused harmony export minus */\nconst add = (a, b) =&gt; {\n  console.log(a + b);\n};\nconst minus = (a, b) =&gt; {\n  console.log(a - b);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWF0aC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYXRoLmpzPzVhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PntcclxuICBjb25zb2xlLmxvZyhhICsgYilcclxufVxyXG5leHBvcnQgY29uc3QgbWludXMgPSAoYSwgYikgPT57XHJcbiAgY29uc29sZS5sb2coYSAtIGIpXHJcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/math.js\n&quot;);

</code></pre>
<h4 id="2-develoment-和-production-模式的区分打包">2. Develoment 和 Production 模式的区分打包</h4>
<p>我们一般写项目的时候，会对<code>webpack</code>进行两个配置，一个是生成版本的配置，一个是开发版本的配置；这里我的<code>Develoment</code>模式的配置文件在<code>webpack.dev.js</code>，我的<code>Production</code>模式的配置文件在<code>webapck.prod.js</code>中，然后我们在<code>package.json</code>进行配置我们允许的命令：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,
  },
</code></pre>
<p>这样，方面我们进行开发；<code>webpack.dev.js</code>配置如下：主要不同的是配置了打包的模式，开发环境的<code>devtool</code>配置为<code>cheap-module-eval-source-map</code>，生产环境的配置为：<code>cheap-module-source-map</code>,；我们在开发环境中使用下面的配置，每次修改js文件，需要进行手动刷新一次页面，我们去掉<code>hotOnly: true</code>，这样如果改变了<code>js</code>文件，就会自动刷新。</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new webpack.HotModuleReplacementPlugin(),
        new HtmlWebpakcPlugin({
            template: './src/index.html'
        }),
        
    ],
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        publicPath: './',
        // 文件名
        filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>我们查看我们的生产环境的配置以及开发环境的配置，会发现，有很多相同的配置，比如打包的规则，入口出口的配置等等，我们可以新建一个<code>webpack.common.js</code>文件，来存放两个配置中相同的部分，然后删除公共的部分；如下面的代码：<br>
<code>webpack.dev.js</code>配置如下：</p>
<pre><code class="language-js">
const webpack = require('webpack');

module.exports = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    optimization: {
      usedExports: true
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
}
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">
module.exports = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
}
</code></pre>
<p><code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')

module.exports = {
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>然后我们通过<code>webpack-merage</code>插件来进行合并我们的配置文件，输入命令：<code>npm install webpack-merge -D</code>进行安装；然后修改我们的<br>
<code>webpack.prod.js</code>以及<code>webpack.dev.js</code>中的代码，修改后如下：<br>
<code>webpack.dev.js</code>配置如下：</p>
<pre><code class="language-js">
const webpack = require('webpack');
const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const devConfig = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    optimization: {
      usedExports: true
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
}
module.exports = merge(commonConfig, devConfig)
</code></pre>
<p><code>webpack.prod.js</code>配置如下：</p>
<pre><code class="language-js">const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
}
//模块导出的是两个文件的合并
module.exports = merge(commonConfig, prodConfig)
</code></pre>
<p>一般情况，我们会新建一个<code>build</code>文件夹来存放我们的这三个配置文件，然后修改我们的<code>package.json</code>中的命令：这样就可以了。</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;,
  },
</code></pre>
<h4 id="3-webpack-和-code-splitting">3. Webpack 和 Code Splitting</h4>
<h5 id="31-打包配置的一些问题">3.1 打包配置的一些问题</h5>
<p>我们在上面将开发版本以及生产版本的配置都通过提取方式写在了一个文件中，并放在了<code>build</code>文件夹中，但是我们没有修改打包输出文件的地址以及<code>clean-webpack-plugin</code>插件中清除文件夹的地址，所以我们修改<code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">    plugins: [
        new CleanWebpackPlugin(['dist'], {
            root: path.resolve(__dirname, '../')
        }),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
         publicPath: './',
         filename: '[name].js',
        path: path.resolve(__dirname, '../dist')
    }
</code></pre>
<p><code>clean-webpack-plugin</code>添加的<code>root</code>的配置意思的，重新设置了根目录，默认是认为配置文件所在的地址为根目录，这里我们的配置文件在<code>build</code>中，所以根目录在他的上一级。我查看<code>clean-webpack-plugin</code>的插件，并没有配置这个<code>root</code>选项；不知道哪个版本里面的，我们直接用如下的配置即可:还有我删除了打包输出文件的一些配置，因为<code>html-webpack-plugin</code>插件会有<code>bug</code>在我的基础文章笔记里面写了，可以去看看。</p>
<pre><code class="language-js">    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        })
    ],
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, '../dist')
    }
</code></pre>
<h5 id="32-code-splitting代码分割">3.2 Code Splitting代码分割</h5>
<p>我们在写代码的时候，经常会遇到引用很多第三方的包，来方便我们处理业务逻辑，比如我们使用<code>lodash</code>，但是这样会导致我们打包输出的时候，会将业务逻辑代码以及第三方库的代码打包到到一起；如果我们的业务网逻辑代码很多，会导致打包成功后的文件很大；页面加载速度很慢，如果我们修改了业务代码；这样整个页面得重新加载我们的代码。这个时候我们可以进行代码的分割：</p>
<h6 id="321-第一种方式自己实现代码分割将其他引用的第三方库进行分离写在另一个js脚本中">3.2.1 第一种方式：自己实现代码分割：将其他引用的第三方库进行分离写在另一个js脚本中</h6>
<p>将其他引用的第三方库进行分离写在另一个js脚本中，然后我们进行修改打包配置，进行配置多个入口如下：<br>
我们之前写的<code>index.js</code>代码：</p>
<pre><code class="language-js">import _ from 'lodash';
// ...业务逻辑
console.log(_.join(['a','b','c'],'***'))
</code></pre>
<p>修改后的配置文件</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        lodash: './src/lodash.js',
    },
</code></pre>
<p>将<code>index.js</code>分离出一个<code>lodash.js</code>文件，内容如下：</p>
<pre><code class="language-js">import _ from 'lodash';
windows._ = _;
</code></pre>
<p>在<code>index.js</code>中我们不在引入<code>lodash</code>，因为他已经被挂载到了全局对象上，我们直接可以使用，这样，减少了如果业务逻辑代码频繁修改后页面重新加载很大的打包输出文件；减少了业务逻辑代码的体积；如果我们改变了业务代码，页面只会重新加载业务代码，第三方的<code>lodash.js</code>文件会被缓存起来，不会重新加载。</p>
<h6 id="322-第二种方式使用webpack的代码分割同步加载包进行打包使用插件配置进行code-splitting">3.2.2  第二种方式：使用webpack的代码分割：同步加载包进行打包，使用插件配置进行Code Splitting</h6>
<p>我们在<code>webpack.common.js</code>中添加一个配置，代码如下：意思就是帮我们做代码分割</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'all'
      }
    },
</code></pre>
<p>然后我们查看打包输出文件，会打包出一个<code>main.js</code>的业务逻辑代码，以及<code>vendors~main.js</code>的第三方库文件的代码：<br>
<img src="https://img-blog.csdnimg.cn/20190525150350385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<code>vendors~main.js</code>文件内容：</p>
<pre><code class="language-js">(window[&quot;webpackJsonp&quot;] = window[&quot;webpackJsonp&quot;] || []).push([[&quot;vendors~main&quot;],{

/***/ &quot;./node_modules/_lodash@4.17.11@lodash/lodash.js&quot;:
/*!*******************************************************!*\
  !*** ./node_modules/_lodash@4.17.11@lodash/lodash.js ***!
  \*******************************************************/
</code></pre>
<p><code>webpack</code>插件会很智能的分割我们的代码；</p>
<h6 id="323-第三种方式使用webpack的代码分割异步引入模块的代码分割">3.2.3  第三种方式：使用webpack的代码分割：异步引入模块的代码分割</h6>
<p>上面的包模块是一种同步的引入方式，然后<code>webpack</code>会先处理这些，然后进行处理我们的业务逻辑代码；我们这里再说一种异步b包模块引入的代码分割：我们的<code>index.js</code>代码如下</p>
<pre><code class="language-js">function getComponent () {
  return import('lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}

getComponent ().then((element) =&gt; {
  document.body.appendChild(element)
})
</code></pre>
<p>上面的代码通过<code>return import</code>这种引入方式是实验性质的语法会报错，我们可以通过一个<code>babel</code>的插件来解决这个问题，输入命令：<code>npm install babel-plugin-dynamic-import-webpack --save-dev</code>，然后在我们的<code>.babelrc</code>文件里面进行配置：多加一个<code>plugins: [&quot;dynamic-import-webpack&quot;]</code>配置</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ],
    plugins: [&quot;dynamic-import-webpack&quot;]
}
</code></pre>
<p>可以查看打包的日志：会生成两个<code>js</code>文件，<code>0.js</code>里面就是我们引入包的打包文件；<br>
<img src="https://img-blog.csdnimg.cn/20190525152610582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>这里需要注意的是：首先代码分割跟我们的<code>webpack</code>是无关的，我们只是通过代码分割这种思想来提升我们项目的性能；<code>webpack</code>中实现代码分割两种方式：</p>
<ol>
<li>同步代码：只需要在<code>webpack.common.js</code>中做<code>optimization</code>的配置；</li>
<li>异步代码（<code>import</code>）：无需做任何配置，会自动进行代码分割；</li>
</ol>
</blockquote>
<h4 id="4-splitchunksplugin-配置参数详解">4 SplitChunksPlugin 配置参数详解</h4>
<h5 id="41-修改打包输出的文件名">4.1 修改打包输出的文件名</h5>
<p>其实我们上面讲的<code>webpack</code>代码分割是使用了<code>SplitChunksPlugin</code>这个插件来实现的；我们查看打包结果，他会将<code>lodash</code>的第三方库打包成<code>0.js</code>的文件，我们如果想要改这个生成的文件名，可以通过魔法注释的方法来实现：我们在引入<code>lodash</code>前加了一个<code>/* webpackChunkName = &quot;lodash&quot;*/</code>意思就是打包后，这个模块的名字叫做<code>lodash.js</code></p>
<pre><code class="language-js">function getComponent () {
  return import(/* webpackChunkName:&quot;lodash&quot;*/'lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}

getComponent ().then((element) =&gt; {
  document.body.appendChild(element)
})
</code></pre>
<p>然后移除掉我们前面安装的<code>babel-plugin-dynamic-import-webpack</code>插件，因为这个插件不支持我们的魔法注释这种功能；在<code>package.json</code>删除<code>babel-plugin-dynamic-import-webpack</code>，然后在<code>.babelrc</code>文件里面去除我们的配置；然后我们使用官方提供的动态引入第三库的插件；输入命令：<code>npm install --save-dev @babel/plugin-syntax-dynamic-import</code>;然后在<code>.babelrc</code>文件中我们引入这个插件：</p>
<pre><code class="language-js">{
    presets: [
        [
            &quot;@babel/preset-env&quot;, {
                targets: {
                    chrome: &quot;67&quot;,
                },
                useBuiltIns: 'usage'
            }
        ],
        &quot;@babel/preset-react&quot;
    ],
    plugins: [&quot;@babel/plugin-syntax-dynamic-import&quot;]
}
</code></pre>
<p>这样修改还是不行，他打包出的文件会在前面加一个<code>vendors~lodash.js</code>这样，我们需要去除这个前缀，打开<code>webpack.common.js</code>,修改<code>optimization</code>的配置如下：这样，打包之后的文件名就是我们所想要的了。</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: false,
          default: false
        }
      }
    },
</code></pre>
<p>其实我们不进行<code>splitChunks</code>配置，也可以进行打包的，因为，它本身有一个默认的配置，配置内容如下：</p>
<pre><code class="language-js">    optimization: {
      splitChunks: {
        chunks: 'async',//代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all
        minSize: 30000,//设置模块大小大于30kb才会进行代码分割
        maxSize: 0,//设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出
        minChunks: 1,//当一个模块被用了至少多少次的时候，才进行分割。
        maxAsyncRequests: 5,//同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割
        maxInitialRequests: 3,//入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割
        automaticNameDelimiter: '~',//打包输出文件的连接符，例如vendors~main.js；vendors是组名，后面就是连接符；vendors~main.js意思是vendors组的入口文件是main.js
        name: true,
        cacheGroups: {
            // 如果引入的包是node_modules里面的内容，会进入到这里的配置
          vendors: {
            test: /[\\/]node_modules[\\/]/,//检测引入的第三方库是不是node_modules里面的内容
            priority: -10,
            filename: 'vendors.js' //如果是node_modules里面的内容，会打包到这个文件里面
          },
          // 如果引入的包不是node_modules里面的内容，会进入到这里的配置
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true,
            filename: 'common.js'
          }
        }
      }
   }
</code></pre>
<h5 id="42-splitchunksplugin-配置参数的意义">4.2 SplitChunksPlugin 配置参数的意义</h5>
<p>各个参数的意义：</p>
<ul>
<li><code>chunks</code>：设置打包是对异步代码（<code>async</code>）f分割；还是对同步代码（<code>initial</code>）做代码分割；还是对所有（<code>all</code>）的代码都打包；如果设置<code>all</code>或者<code>initial，他会进入到</code>cacheGroups`这个配置项，查看打包的配置；</li>
<li><code>vendors</code>：<code>test</code>是检测引入的包是不是<code>node_modules</code>里面的内容；如果是，他会将这库打包到<code>vendors</code>这个组中，打包后的文件会加一个<code>vendors~</code>前缀，代表是<code>vendors</code>这个组中；也就是这个库是<code>node_modules</code>里面的内容；我们可以加一个<code>filename: 'vendors.js'</code>这个配置项，这样，打包出来的所有的文件都会在<code>vendors.js</code>这个文件中；如果不是<code>node_modules</code>里面的内容，他会进入到<code>default</code>的配置中。</li>
<li><code>minSize</code>：设置模块大小大于30kb才会进行代码分割，设置打包文件的最小体积。</li>
<li><code>maxSize</code>：设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出</li>
<li><code>minChunks</code>：当一个模块被用了至少多少次的时候，才进行分割。</li>
<li><code>maxAsyncRequests</code>：同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割</li>
<li><code>maxInitialRequests</code>：入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割</li>
<li><code>automaticNameDelimiter</code>：打包输出文件的连接符，例如<code>vendors~main.js</code>；<code>vendors</code>是组名，后面就是连接符；<code>vendors~main.js</code>意思是<code>vendors</code>组的入口文件是<code>main.js</code></li>
<li><code>cacheGroups</code>：具体的打包输出文件的规则；注意这里的<code>priority</code>，其实大部分的包都是满足既是<code>node_modules</code>中的，又是满足默认的配置，我们通过<code>priority</code>设置优先级，优先执行哪个配置；数越大，优先级越高；越先执行。</li>
<li><code>reuseExistingChunk</code>：配置为<code>true</code>就是如果之前打包过该模块，再次遇到不会进行打包，只是复用以前打包的模块。</li>
</ul>
<h4 id="5-lazy-loading-懒加载chunk-是什么">5. Lazy Loading 懒加载，Chunk 是什么？</h4>
<h5 id="51-懒加载">5.1 懒加载</h5>
<p>我们的页面有时候会引入很多的包，或者第三方库文件；这时候整个页面加载速度会特别慢，我们可以通过懒加载的方式去加载这些包；来提高页面的响应速度。懒加载也就是说，我们在页面初始化的时候，不加载那些初始化不需要的包文件，只在需要包的函数中，进行异步加载包文件，如下面代码：这里，只要我们点击页面的时候才会需要<code>lodash</code>包，所以，我们通过异步加载，在页面首次加载的时候，不对该包进行加载；这样来提高页面的响应速度。</p>
<pre><code class="language-js">function getComponent () {
  return import(/* webpackChunkName:&quot;lodash&quot;*/'lodash').then(({default: _}) =&gt; {
    var element = document.createElement('div')
    element.innerHTML = _.join(['a','b','c'],'***')
    return element
  })
}
// 点击页面才会执行
document.addEventListener('click', () =&gt; {
  getComponent ().then((element) =&gt; {
    document.body.appendChild(element)
  })
})
</code></pre>
<p>可以使用异步函数<code>async</code>来改写上面的函数：</p>
<pre><code class="language-js">async function getComponent () {
  const {default: _} = await import(/* webpackChunkName:&quot;lodash&quot;*/'lodash');
  const element = document.createElement('div')
  element.innerHTML = _.join(['a','b','c'],'***')
  return element
}
// 点击页面才会执行
document.addEventListener('click', () =&gt; {
  getComponent ().then((element) =&gt; {
    document.body.appendChild(element)
  })
})
</code></pre>
<h5 id="52-chunk-是什么">5.2 Chunk 是什么？</h5>
<p>我们打包输出的每一个<code>js</code>文件，都是一个<code>Chunk</code>;可以查看我们打包输出的日志：<br>
<img src="https://img-blog.csdnimg.cn/2019052720265522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
比如我们前面配置的<code>chunks: 'async',</code>代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all，还有就是我们配置进行打包最小引用次数;<code>minChunks: 1</code>当一个模块被用了至少多少次的时候，才进行分割。</p>
<h4 id="6-打包分析preloading-prefetching">6. 打包分析，Preloading, Prefetching</h4>
<h5 id="61-打包分析工具">6.1 打包分析工具</h5>
<p><code>webpack</code>打包分析工具：<code>https://github.com/webpack/analyse</code>,如果要使用这个工具对我们打包生成的代码进行分析，我们首先需要生成一个打包过程的描述文件；通过这样命令<code>webpack --profile --json &gt; stats.json</code>，我们在<code>package.json</code>里面进行配置我们的打包命令：代码意思是，我们会将打包过程的描述信息放置到<code>stats.json</code>这个文件中；</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev-build&quot;: &quot;webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js&quot;
  },
</code></pre>
<p>然后点击进入这个网站<code>http://webpack.github.io/analyse/</code>（需要科学上网），上传我们打包的描述信息文件，会生成一个分析结果：<br>
<img src="https://img-blog.csdnimg.cn/20190527205335701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<img src="https://img-blog.csdnimg.cn/20190527205400861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
我的<code>webpack</code>版本是<code>4.31.0</code>这里，显示的是不合适。我们也可以使用其他的检测工具<code>https://webpack.js.org/guides/code-splitting#bundle-analysis</code>这里介绍了很多。比如这个<code>https://alexkuz.github.io/webpack-chart/</code>也可以进行检查；</p>
<h5 id="62-preloading-prefetching">6.2 Preloading, Prefetching</h5>
<h6 id="621-异步加载交互代码提高性能">6.2.1  异步加载交互代码提高性能</h6>
<p>页面中一些交互的代码，比如点击页面才会执行的事件，或者点击按钮执行的事件这些；</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  const element = document.createElement('div')
  element.innerHTML = 'jiegiser'
  document.body.appendChild(element)
})
</code></pre>
<p>我们在页面初始化的时候，并没有用到这些；我们可以打开控制台，按<code>ctrl+shift+p</code>然后输入<code>&gt;show coverage</code>来查看我们文件的利用率：绿色的是页面加载有用的内容。<br>
<img src="https://img-blog.csdnimg.cn/20190527212614385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以看到我们在与页面交互的代码，没有被利用；页面一开始并没有使用这个交互式的函数，所以在页面初始化加载的时候，将这些代码全部下载进行加载，会浪费项目的性能。这种交互的代码最好是放在一个异步加载的模块里面，我们新建一个<code>click.js</code>文件，里面写我们异步加载模块等实现的交互式代码：</p>
<pre><code class="language-js">function handleClick () {
    const element = document.createElement('div')
    element.innerHTML = 'jiegiser'
    document.body.appendChild(element)
}

export default handleClick;
</code></pre>
<p>然后在<code>index.js</code>这样去引入我们的	<code>click.js</code>模块：</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  // func就是我们导出的handleclick方法
  import('./click.js').then(({default: func}) =&gt; {
    func();
  })
})
</code></pre>
<p>再次打开控制台的<code>&gt;show coverage</code>来查看我们文件的利用率：会发现比之前的高跟多；<br>
<img src="https://img-blog.csdnimg.cn/2019052808100047.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
这也就说明了为什么<code>webpack</code>的<code>chunks: 'async'</code>默认的配置项是打包异步的代码，<code>webpack</code>真正希望的是我们多写这种异步加载模块的代码，进行打包，来提升性能。</p>
<h6 id="622-利用preloading-prefetching优化异步加载交互代码提高性能">6.2.2  利用Preloading, Prefetching优化异步加载交互代码提高性能</h6>
<p>我们前面写的只有页面需要展示的内容在页面初始化的时候进行加载，其他的交互式的代码可以通过异步加载的方式提高性能；但是比如我们有一个交互式的是一个点击按钮之后，打开一个模态框；这种交互式的如果等到用户点击按钮的时候再进行异步加载代码，是会等待很长时间的，我们可以通过<code>Preloading, Prefetching</code>（<code>https://webpack.js.org/guides/code-splitting#prefetchingpreloading-modules</code>）来优化加载，等到页面全部加载完成，网络空闲之后，再进行加载我们的异步交互代码；通过添加一个<code>/* webpackPrefetch: true */</code>魔法注释来实现，等到页面主要的<code>js</code>文件加载完成之后，再进行加载我们的交互代码；</p>
<pre><code class="language-js">document.addEventListener('click', () =&gt; {
  // func就是我们导出的handleclick方法
  import(/* webpackPrefetch: true */ './click.js').then(({default: func}) =&gt; {
    func();
  })
})
</code></pre>
<p><code>Preloading</code>,和<code>Prefetching</code>基本是一样的；<code>Prefetching</code>是等到页面主要核心的<code>js</code>文件加载完成之后，带宽空闲的时候再进行加载异步加载的代码；<code>Preloading</code>是跟主要的业务逻辑代码一起加载的。</p>
<h4 id="7-css-文件的代码分割">7. CSS 文件的代码分割</h4>
<h5 id="71-使用minicssextractplugin-插件进行css代码分割">7.1 使用MiniCssExtractPlugin 插件进行css代码分割</h5>
<p>我们在输出配置的时候可以添加一个<code>chunkFilename</code>的配置项；我们配置的入口文件在打包输出的时候其实是根据<code>filename: '[name].js',</code>我们配置的这个进行打包输出，而其他的打包输出文件会根据我们配置的<code>chunkFilename</code>的配置项，来进行打包输出；我们之前打包<code>css</code>，打包成功之后会将<code>css</code>与<code>js</code>文件打包在一起；我们现在想把我们的<code>css</code>文件打包输出的时候也跟打包<code>js</code>文件一样单独输出，这时候就需要这个<code>MiniCssExtractPlugin</code>插件，来帮助我们：<br>
输入命令<code>npm install --save-dev mini-css-extract-plugin</code>进行安装这个插件，需要注意的是，这个插件不支持热更新，在开发环境的时候使用，开发效率较低，我们修改<code>css</code>样式之后，得手动刷新浏览器；一般我们在线上环境会使用这个插件。在开发环境的配置中添加下面的配置：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const merge = require('webpack-merge')
const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    devtool: 'cheap-module-source-map',
    plugins: [
      new MiniCssExtractPlugin({})
    ]
}
// 模块导出的是两个文件的合并
module.exports = merge(commonConfig, prodConfig)
</code></pre>
<p>然后在打包的规则中，配置打包<code>css</code>文件的时候使用该插件提供的<code>loader</code>，把<code>css</code>单独打包成一个文件。然我们修改生产环境的配置，配置打包<code>css</code>文件的规则，如下代码：开发环境的打包<code>css</code>的规则可以不用修改</p>
<pre><code class="language-js">    module: {
      rules: [
        {
            test: /\.scss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'postcss-loader'
            ]
        },
      ]
    },
</code></pre>
<p>然后我们只想打包会发现并没有生成一个<code>css</code>文件，是因为我们前面配置了<code>tree shaking</code>会检测引入的包是否使用，如果没有使用就会去除，不会进行打包；我们可以修改<code>package.json</code>里面的配置，让其不对<code>css</code>文件进行检查：</p>
<pre><code class="language-js">  &quot;sideEffects&quot;: [
    &quot;*.css&quot;
  ],
</code></pre>
<p>然后将配置时候启用<code>tree shaking</code>检查的配置放在公用的配置文件（<code>webpack.common.js</code>）中：</p>
<pre><code class="language-js">    optimization: {
        usedExports: true
      },
</code></pre>
<p>修改后如下：</p>
<pre><code class="language-js">    // 修改配置，进行代码分割进行打包，以及去除打包成功之后添加的vendors~前缀
    optimization: {
      usedExports: true,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: false,
          default: false
        }
      }
    },
</code></pre>
<p>我们还可以在<code>MiniCssExtractPlugin</code>添加很多配置项，如下面代码：当打包的文件直接引入到页面的时候他的命名规则会走<code>filename</code>的配置项，如果是间接引入到页面，就会走下面的<code>chunkFilename</code>的配置项。如果页面直接引入了多个<code>css</code>文件，会直接将这些文件合并打包到一个<code>main.css</code>文件中。</p>
<pre><code class="language-js">    plugins: [
      new MiniCssExtractPlugin({
        filename: '[name].css',
        chunkFilename: '[name].chunk.css',
      })
    ]
</code></pre>
<h5 id="72-对打包输出的css文件进行压缩">7.2 对打包输出的css文件进行压缩</h5>
<p>需要压缩<code>css</code>文件，我们使用一个插件，输入命令进行安装：<code>npm install --save-dev optimize-css-assets-webpack-plugin</code>,然后在<code>webpack.prod.js</code>里面引入这个插件，进行配置如下：</p>
<pre><code class="language-js">const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const prodConfig = {
......
    optimization: {
      minimizer: [new OptimizeCssAssetsPlugin({})]
    },
  }
......
</code></pre>
<h5 id="73-多个js入口文件引入的css文件打包输出为一个文件">7.3 多个js入口文件引入的css文件打包输出为一个文件</h5>
<p>我们需要通过代码分割的配置添加一个<code>styles</code>的组，配置如下：<code>enforce: true,</code>就是说忽略掉我们配置的其他有关<code>css</code>文件打包的默认参数；</p>
<pre><code class="language-js">    splitChunks: {
      cacheGroups: {
        styles: {
          name: 'styles',
          test: /\.css$/,
          chunks: 'all',
          enforce: true,
        },
      },
    },
</code></pre>
<h5 id="74-根据配置入口js文件不同对其中引入的css文件进行单独打包">7.4 根据配置入口js文件不同，对其中引入的css文件进行单独打包</h5>
<p>我们还可以根据我们配置的<code>js</code>文件，对每个文件中引入的<code>css</code>文件打包输出成单独的一个文件。如下面配置：入口文件有<code>foo</code>跟<code>bar</code>，分别进行打包输出为不同的文件。</p>
<pre><code class="language-js">    splitChunks: {
      cacheGroups: {
        fooStyles: {
          name: 'foo',
          test: (m, c, entry = 'foo') =&gt;
            m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
        barStyles: {
          name: 'bar',
          test: (m, c, entry = 'bar') =&gt;
            m.constructor.name === 'CssModule' &amp;&amp; recursiveIssuer(m) === entry,
          chunks: 'all',
          enforce: true,
        },
      },
    },
</code></pre>
<h4 id="8-webpack-与浏览器缓存-caching">8. Webpack 与浏览器缓存( Caching )</h4>
<h5 id="81-去除打包输出性能警告提示">8.1 去除打包输出性能警告提示</h5>
<p>我们有时候在打包文件的时候，控制台会抛出一个警告：警告我们打包输出的文件太大了超过了最大的<code>244kb</code>的大小。<br>
<img src="https://img-blog.csdnimg.cn/20190530083501241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
我们可以去除这个性能的警告，在<code>webpack.common.js</code>中添加配置</p>
<pre><code class="language-js">module.exports = {
    ........
    //去除控制台提示性能的问题
    performance: false,
    ........
}
</code></pre>
<h5 id="82-浏览器缓存">8.2 浏览器缓存</h5>
<p>我们每次打包之后的文件，如果不做添加文件修改，打包输出的文件每次都是一样的；这会导致浏览器加在我们的代码的时候出现使用缓存中已经缓存好的文件；这时候我们可以在打包输出的配置进行修改添加一个打包输出文件的唯一标识符：<code>contenthash</code>是文件的<code>hash</code>值；如果打包输出的文件没有变化，这个值不变，如果有变化，对应的这个值也会变化。</p>
<pre><code class="language-js">    output: {
      filename: '[name].[contenthash].js',
      chunkFilename: '[name].[contenthash].js'
    }
</code></pre>
<p>对于新版本的<code>webpack4.x</code>打包之后如果文件没有更改，会保持不变，但是老版本的<code>webpack4.x</code>货值之前的版本，有可能会发生变化，这个时候我们需要在<code>optimization</code>选项中添加下面的配置：</p>
<pre><code class="language-js">    optimization: {
      runtimeChunk: {
          name: 'runtime'
      },
    }
</code></pre>
<p>我们会发现打包生成后，多出来一个<code>runtime--.js</code>的文件，这个文件保存着库代码与业务代码之间的引用关系。</p>
<h4 id="9-shimming的作用">9. Shimming的作用</h4>
<h5 id="91-shimming的使用">9.1 Shimming的使用</h5>
<p><code>webpack</code> 编译器(<code>compiler</code>)能够识别遵循<code>ES2015</code>模块语法、<code>CommonJS</code>或 <code>AMD</code>规范编写的模块。然而，一些第三方的库(<code>library</code>)可能会引用一些全局依赖（例如 <code>jQuery</code>中的<code>$</code>）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 <code>shimming</code>发挥作用的地方，在<code>webpack</code>中，每个库文件是单独的，彼此隔离的；如下面的代码：<br>
新建的一个<code>jquery.ui.js</code>我们使用了<code>jquery</code>但事故我们的库文件没有引入他。</p>
<pre><code class="language-js">export function ui () {
  $('body').css('background', 'red')
}

</code></pre>
<p><code>index.js</code>文件：</p>
<pre><code class="language-js">import _ from 'lodash'
import $ from 'jquery'
import { ui } from './jquery.ui.js'
ui();
const dom = $('&lt;div&gt;')
dom.html(_.join(['dell', 'lee'], '---'))
$('body').append(dom)
</code></pre>
<p>这样会提示<code>$</code>没有定义，我们原本想着前面引入了<code>jquery</code>为什么还是没用，就是因为在<code>webpack</code>中，每个库文件是单独的，彼此隔离的，我们一般引入的库文件是第三方的，存放在<code>node_module</code>中，我们也不可能去修改它里面的内容，所以这时候就需要使用<code>Shimming</code>来解决问题；修改我们的<code>webpack.common.js</code>:<code>new webpack.ProvidePlugin</code>这个<code>webpack</code>自带的插件会进行对打包文件进行检查，如果检测到你的代码中有<code>$</code>这个符号，他会自动帮你引入<code>jquery</code>模块。然后将<code>jwuery</code>模块赋值给<code>$</code>字符串。</p>
<pre><code class="language-js">const webpack = require('webpack')
module.exports = {
    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        .....
        new webpack.ProvidePlugin({
            $: 'jquery'
        })
    ],
}
</code></pre>
<p>同样这里的配置我们还可以直接将某一个包的方法进行配置到这里，比如：我想使用<code>lodash</code>模块中的<code>join</code>方法，之前我们是引入<code>import _ from 'lodash'</code>这样引入，然后<code>_.join</code>这样调用他的<code>join</code>方法，但是我这里就想<code>_join</code>这样去调用<code>join</code>方法，我们可以在<code>webpack.common.js</code>进行配置</p>
<pre><code class="language-js">export function ui () {
  $('body').css('background', 'red')
  $('body').html(_join(['ddd', 'ddd'],'----'))
}
</code></pre>
<p>配置如下：<code>_join: ['lodash', 'join']</code>意思就是，当我们打包的时候遇到<code>_join</code>，就去引入<code>lodash</code>，将<code>lodash</code>中的<code>join</code>方法，赋值给他。</p>
<pre><code class="language-js">    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.ProvidePlugin({
            $: 'jquery',
            _join: ['lodash', 'join']
        })  
    ],
</code></pre>
<h5 id="92-利用shimming改变模块中this指向window">9.2 利用Shimming改变模块中this指向window</h5>
<p>我们在模块中，比如我们的入口文件，我们打印<code>console.log(this === window);</code>会发现，里面的<code>this</code>指向并不是<code>window</code>对象，我们可以借助一些<code>loader</code>:输入命令进行安装<code>npm install imports-loader --save-dev</code>,然后进行修改<code>webpack.common.js</code>中打包<code>js</code>文件的配置：<code>loader: &quot;imports-loader?this=&gt;window&quot;</code>当我们打包<code>js</code>文件的时候，会走下面的规则，然后将我们每个模块中的<code>this</code>指向我们的<code>windos</code>对象。</p>
<pre><code class="language-js">    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
          ]
        }]
       }
</code></pre>
<blockquote>
<p>深入学习：查看<code>webpack</code>官网中<code>guides</code>里所有内容。</p>
</blockquote>
<h4 id="10-webpack环境变量的使用方法">10. Webpack环境变量的使用方法</h4>
<p>之前我们是将我们的配置文件分成了三个部分<code>webpack.dev.js webapck.common.js webapck.prod.js</code>然后在<code>package.json</code>配置命令如下：进行运行不同的文件：<br>
<code>package.json</code>之前的配置：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.dev.js&quot;,
  },
</code></pre>
<p>我们现在可以修改一下我们之前的配置，将<code>webpack.dev.js</code>配置如下：直接导出配置；</p>
<pre><code class="language-js">
const webpack = require('webpack');
// const merge = require('webpack-merge')
// const commonConfig = require('./webpack.common.js')
const devConfig = {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
    },
    module: {
      rules: [
        {
          test: /\.scss$/,
          use: [
              'style-loader',
              {
                loader: 'css-loader',
                options: {
                  importLoaders: 2
                }
              },
              'sass-loader',
              'postcss-loader'
          ]
      }, {
          test: /\.css$/,
          use: [
              'style-loader',
              'css-loader',
              'postcss-loader'
          ]
      },
      ]
    },
    plugins: [
        new webpack.HotModuleReplacementPlugin(), 
    ],
    // output: {
    //   filename: '[name].js',
    //   chunkFilename: '[name].js'
    // }
}
// module.exports = merge(commonConfig, devConfig)

module.exports = devConfig;
</code></pre>
<p>对应的<code>webpack.prod.js</code>修改为：</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');
// const merge = require('webpack-merge')
// const commonConfig = require('./webpack.common.js')
const prodConfig = {
    // 配置打包模式
    mode: 'production',
    // 暂时先屏蔽输出source文件
    // devtool: 'cheap-module-source-map',
    module: {
      rules: [
        {
            test: /\.scss$/,
            use: [
                MiniCssExtractPlugin.loader,
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.css$/,
            use: [
                MiniCssExtractPlugin.loader,
                'css-loader',
                'postcss-loader'
            ]
        },
      ]
    },
    optimization: {
      minimizer: [new OptimizeCssAssetsPlugin({})]
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: '[name].css',
        chunkFilename: '[name].chunk.css',
      })
    ],
    output: {
      filename: '[name].[contenthash].js',
      chunkFilename: '[name].[contenthash].js'
    }
}
// 模块导出的是两个文件的合并
// module.exports = merge(commonConfig, prodConfig)
module.exports = prodConfig;
</code></pre>
<p>然后我们在<code>webpack..common.js</code>进行根据我们在<code>package.json</code>中配置的命令进行判断是使用哪一个配置文件：<br>
首先修改<code>package.json</code>：<code>--env.production</code>为传入参数；表示是生产环境的配置</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.common.js&quot;,
    &quot;test&quot;: &quot;webpack-dev-server&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后在<code>webpack.common.js</code>配置如下：</p>
<pre><code class="language-js">module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p><code>webpack.common.js</code>文件内容：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')

//重新配置环境变量
/**************** */

const merge = require('webpack-merge');
const devConfig = require('./webpack.dev.js')
const prodConfig = require('./webpack.prod.js')

/*************** */
const webpack = require('webpack')
// module.exports = {
const commonConfig = {
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
          ]
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        },  {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    // 添加插件清空打包路径以及根据模板进行打包html文件
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpakcPlugin({
          template: './src/index.html'
        }),
        new webpack.ProvidePlugin({
            $: 'jquery',
            _join: ['lodash', 'join']
        })  
    ],
    //去除控制台提示性能的问题
    performance: false,
    // 修改配置，进行代码分割进行打包，以及去除打包成功之后添加的vendors~前缀
    optimization: {
      runtimeChunk: {
          name: 'runtime'
      },
      usedExports: true,
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10,
            name: 'vendors'
          },
        }
      }
    },
  //   optimization: {
  //     splitChunks: {
  //       chunks: 'async',//代码分割只对异步加载的代码生效,如果想对同步、异步都进行分割设置为all
  //       minSize: 30000,//设置模块大小大于30kb才会进行代码分割
  //       maxSize: 0,//设置打包输出文件的最大体积，如果需要打包的模块超过这个大小，他会进行分割成多个文件进行打包输出
  //       minChunks: 1,//当一个模块被用了至少多少次的时候，才进行分割。
  //       maxAsyncRequests: 5,//同时加载的模块数。如果页面引用的模块超过五个，不会对超过的模块进行代码分割
  //       maxInitialRequests: 3,//入口文件进行加载引入的模块最多数，这个设置为3，就是如果入口文件引入模块超过三个，超过的就不会进行代码分割
  //       automaticNameDelimiter: '~',//打包输出文件的连接符，例如vendors~main.js；vendors是组名，后面就是连接符；vendors~main.js意思是vendors组的入口文件是main.js
  //       name: true,//
  //       cacheGroups: {
  //           // 如果引入的包是node_modules里面的内容，会进入到这里的配置
  //         vendors: {
  //           test: /[\\/]node_modules[\\/]/,//检测引入的第三方库是不是node_modules里面的内容
  //           priority: -10,
  //           filename: 'vendors.js' //如果是node_modules里面的内容，会打包到这个文件里面
  //         },
  //         // 如果引入的包不是node_modules里面的内容，会进入到这里的配置
  //         default: {
  //           minChunks: 2,
  //           priority: -20,
  //           reuseExistingChunk: true,
  //           filename: 'common.js'
  //         }
  //       }
  //     }
  //  },
    // 打包出的文件配置/*这里的配置会跟打包HTML的插件冲突 */
    output: {
        // 文件引入的cnd地址
        // publicPath: 'http://cdn.com.cn',
        // publicPath: './',
        // // 文件名
        // filename: '[name].js',
        //  打包后的文件放在哪个文件夹，是一个绝对路径 
        //  __dirname就是webpack.config.js所在的当前目录的路径,当前模块的目录名,改成bundle就是说，打包后的文件放在dist文件夹中
        // 非入口文件打包输出走下面的配置项
        // chunkFilename: '[name].chunk.js',
        path: path.resolve(__dirname, '../dist')
    }
}

module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p>我们也可以进行传参数，这样：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env production --config ./build/webpack.common.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后<code>webpack.common.js</code>这样：</p>
<pre><code class="language-js">module.exports = (production) =&gt; {
    if (production) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
<p>或者在传参数的时候传入一个字符串：</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;,
    &quot;build&quot;: &quot;webpack --env.production =abc --config ./build/webpack.common.js&quot;,
    &quot;dev-build&quot;: &quot;webpack --config ./build/webpack.common.js&quot;,
  },
</code></pre>
<p>然后<code>webpack.common.js</code>这样：</p>
<pre><code class="language-js">module.exports = (env) =&gt; {
    if (env &amp;&amp; env.production === 'abc) {
        return merge (commonConfig, prodConfig)
    } else {
        return merge (commonConfig, devConfig)
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack实战配置案例]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-shi-zhan-pei-zhi-an-li</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-shi-zhan-pei-zhi-an-li">
        </link>
        <updated>2019-12-06T01:37:45.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-library打包">1. Library打包</h4>
<h5 id="11-对库文件进行打包">1.1 对库文件进行打包</h5>
<p>库文件的打包：我们新建一个工程，新建<code>index.js math.js string.js</code>,代码如下：</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-library打包">1. Library打包</h4>
<h5 id="11-对库文件进行打包">1.1 对库文件进行打包</h5>
<p>库文件的打包：我们新建一个工程，新建<code>index.js math.js string.js</code>,代码如下：</p>
<!-- more -->
<p><code>index.js</code>文件</p>
<pre><code class="language-js">import * as math from './math.js'
import * as string from './string.js'
export default { math, string }
</code></pre>
<p><code>math.js</code>文件：</p>
<pre><code class="language-js">export function add (a, b) {
 return a + b;
}
export function minius (a, b) {
  return a - b;
}
export function multiply (a, b) {
  return a * b;
}
export function division (a, b) {
  return a / b;
}
</code></pre>
<p><code>string.js</code>文件</p>
<pre><code class="language-js">export function join (a, b) {
    return a + ' ' + b
}
</code></pre>
<p>然后我们打包输出，我们这个库，在给被人使用的是，别人会有很多种方式，进行使用；比如：<br>
<code>ES module</code>：</p>
<pre><code class="language-js">import library from ‘library’
</code></pre>
<p><code>commonJS</code>方式：</p>
<pre><code class="language-js">const library = require('library')
</code></pre>
<p><code>AMD</code>引入方式：</p>
<pre><code class="language-js">require(['library'], function () {

})
</code></pre>
<p>我们如果想让我们的库文件，在外面可以用上面的这些方式引入，我们可以进行配置，在<code>webpack.config.js</code>中配置如下：<code>libraryTarget: 'umd'</code>代码意思就是不管是在<code>AMD</code>的环境，还是<code>CommonJS</code>的环境、或者是<code>import</code>方式引入，都可以正确使用我们的库文件。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        libraryTarget: 'umd'
    }
}
</code></pre>
<p>如果我们想用</p>
<pre><code class="language-js">&lt;script src=&quot;library.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>这种方式引入，然后使用<code>library.math</code>这种全局变量来使用我们的库，这时候我们需要在<code>webpack.config.js</code>中添加一个配置项：<code>library: 'library',</code>意思是将<code>library</code>挂载到了全局变量上，这样，就可以通过<code>script</code>引入，然后进行使用了。</p>
<pre><code class="language-js">    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
</code></pre>
<p>其实<code>libraryTarget</code>跟<code>library</code>相互作用的，如果配置成上面的，是没有多大关系的，我们可以修改 <code>libraryTarget: 'this'</code>意思就是它不支持<code>AMD commonJS</code>等这些语法引入了，但是我们的<code>library</code>会挂载到全局的<code>this</code>上面。同样，也可以是<code>window</code>；，如果在<code>nodeJS</code>环境下，也可以配置 <code>global</code>；</p>
<pre><code class="language-js">    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'this'
    }
</code></pre>
<p>我们有时候在我们的库文件中，我们使用了第三方的库文件，比如我们将我们的<code>string.js</code>代码改成下面的：我们引入了<code>lodash</code>,</p>
<pre><code class="language-js">import _ from 'lodash'
export function join (a, b) {
    return _.join([a, b],' ')
}
</code></pre>
<p>然后别人在使用我们的库文件的时候，有可能也会使用<code>lodash</code>这个库文件，这样可能会导致一个问题，用户打包后的代码会出现两个<code>lodash</code>文件，我们可以通过配置，来去除这种重复引用;<code>externals: ['lodash'],</code>意思就是打包过程中，如果遇到<code>lodash</code>就忽略这个库文件，然后比尔使用我们这个库的使用还是需要在自己的业务代码中引入<code>lodash</code>库。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    externals: ['lodash'],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
}
</code></pre>
<p>这里的<code>externals</code>也可以是一个对象：下面配置的意思是如果在<code>commonJS</code>环境下，我们使用<code>library</code>库文件：</p>
<pre><code class="language-js">const library = require('library')
</code></pre>
<p>这样，我们引入<code>lodash</code>的时候，命名必须定义成<code>lodash</code>:如下：<code>const lodash = require('lodash')</code></p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'production',
    entry: './src/index.js',
    externals: {
        lodash: {
            commonjs: 'lodash',
        }
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'library.js',
        library: 'library',
        libraryTarget: 'umd'
    }
}
</code></pre>
<h5 id="12-发布一个包">1.2 发布一个包</h5>
<p>首先我们需要修改<code>pachage.json</code>中入口改成：<code>./dist/library.js</code>表示，我们的库文件最终给别人使用的时候，入口文件是<code>./dist/library.js</code>文件。然后在<code>npm</code>上注册一个账号；<br>
然后在命令行里面输入<code>npm adduser</code>，然后输入用户名与密邮箱等。然后输入命令<code>npm publish</code>进行发布我们的包文件，这里需要注意的是，包的名字，不能重复；需要修改<code>name</code>，值，然后我们使用我们发布的包，可以运行命令<code>npm install 包名</code>就可以了。</p>
<h4 id="2-pwaprogressive-web-application的打包配置">2. PWA（Progressive Web Application）的打包配置</h4>
<p>这个是一个新的前端技术。首先一个知识点就是在配置<code>js</code>文件打包输出的时候，配置<code>this</code>的指向：在<code>webpack.config.js</code>中的配置打包输出<code>js</code>的<code>loader</code>中，进行配置：<code>loader: &quot;imports-loader?this=&gt;window&quot;</code>这句话就是将<code>this</code>指向了<code>window</code>对象。</p>
<pre><code class="language-js">{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
            {
              loader: &quot;babel-loader&quot;,
            },
            {
              loader: &quot;imports-loader?this=&gt;window&quot;
            }
</code></pre>
<p>我们可以通过一个<code>http-server</code>模块来模拟我们的服务器，当然也可以使用<code>live-server</code>两个都是一样的。输入命令<code>npm install http-server -D</code>进行安装。然后我们在<code>package.json</code>里面进行配置一个命令，来运行我们的服务器：<code>&quot;start&quot;: &quot;http-server dist&quot;</code>代码的意思就是在我们打包输出的<code>dist</code>的文件夹中启动一个服务器。</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;http-server dist&quot;
  },
</code></pre>
<p>输入运行命令之后，我们可以看到我们的网页正常显示了。如果这个时候，我们将服务器断开，浏览器会出现：无法访问此网站，也就是我们的网站挂了，而<code>pwa</code>技术是如果你第一次访问网站，访问成功之后，突然之间服务器挂了，你第二次再次访问这个网站的时候，他会利用你本地的缓存，可以利用缓存，把之前访问的页面展示出来。也就是说，即便服务器挂了，我在本地还是可以看到之前访问到的页面。<br>
我们可以在<code>webpack</code>中，通过一个插件来实现：<br>
输入命令：<code>npm install workbox-webpack-plugin --save-dev</code>进行安装，我们只需要在线上环境之后，进行使用<code>pwa</code>技术，让用户体验更好，所以，我们只需要修改<code>webapck.prod.js</code>的配置文件。</p>
<pre><code class="language-js">.....
const WorkboxPlugin = require('workbox-webpack-plugin')
const prodConfig = {
....
    plugins: [
    ....
      new WorkboxPlugin.GenerateSW({
        // 这些选项帮助快速启用 ServiceWorkers
        // 不允许遗留任何“旧的” ServiceWorkers
        clientsClaim: true,
        skipWaiting: true
      })
    ....
    ],
}
....
</code></pre>
<p>然后我们进行运行<code>npm run build</code>进行打包，现在你可以看到，生成了两个额外的文件：<code>service-worker.js</code>和名称冗长的 <code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>。<code>service-worker.js</code>是<code>Service Worker</code>文件，<code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>是 <code>service-worker.js</code>引用的文件，所以它也可以运行。可能你本地生成的文件可能会有所不同；但是应该会有一个<code>service-worker.js</code>文件。但是我们重复上面的操作之后，关闭服务器，再次访问的时候，还是不能查看我们上次访问的网页，因为我们还差一步，那就是注册<code>Service Worker</code>，在我们的<code>src</code>目录中的主入口<code>js</code>文件加上下面代码：</p>
<pre><code class="language-js">if ('serviceWorker' in navigator) {
  window.addEventListener('load', () =&gt; {
    navigator.serviceWorker.register('/service-worker.js').then(registration =&gt; {
      console.log('SW registered: ', registration);
    }).catch(registrationError =&gt; {
      console.log('SW registration failed: ', registrationError);
    });
  });
}
</code></pre>
<p>再次运行<code>npm build build</code>来构建包含注册代码版本的应用程序。然后用 <code>npm start</code>将构建结果<code>serve</code>到服务下。导航至 <code>http://localhost:8080</code>并查看 <code>console</code> 控制台。应该看到：<code>SW registered</code>,现在来进行测试。停止 <code>server</code>并刷新页面。如果浏览器能够支持 <code>Service Worker</code>，应该可以看到你的应用程序还在正常运行。</p>
<h4 id="3-typescript-的打包配置">3. TypeScript 的打包配置</h4>
<p><code>TypeScript</code>可以进行代码的规范，也可以很方便的进行报错提示；可以有效的提升<code>JavaSCript</code>的可维护性。首先我们进行配置打包<code>typescript</code>的规则，我们要使用一个<code>ts-loader</code>这个<code>loader</code>来进行打包<code>tsx</code>的文件，当然我们首先需要安装这个<code>loader</code>,使用这个<code>loader</code>的时候，你必须要安装<code>typescript</code>，所以运行下面的命令进行安装：<code>npm install ts-loader typescript --save-dev</code><br>
配置<code>webpack.config.json</code>如下：</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    entry: './src/index.tsx',
    module: {
        rules: [{
            test: /\.tsx?$/,
            use: 'ts-loader',
            exclude: /node_modules/
        }]
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist')
    }
}
</code></pre>
<p>但是这样还是不能够进行打包，我们需要添加一个<code>tsconfig.json</code>，进行配置打包<code>TypeScript</code>的规则：</p>
<pre><code class="language-js">{
    &quot;compilerOptions&quot;: {
        &quot;outDir&quot;: &quot;./dist&quot;,//打包输出的地址
        &quot;module&quot;: &quot;es6&quot;,// 模块的引用方式是使用esmodule的语法
        &quot;target&quot;: &quot;es5&quot;,//打包成es5的代码
        &quot;allowJs&quot;: true//是否允许在TypeScript中引入js模块
    }
}
</code></pre>
<p>这样就可以打包成功了；我们之所以使用<code>TypeScript</code>是进行规范我们代码书写，以及类型引用的正确；比如我们使用<code>lodash</code>这样的库文件，我们在使用这个库的时候，我们有时候不知道这个函数的参数是什么 ，也没有提示我们书写的正确性，只有运行之后，才会知道；当然你也可以去查看文档。我们可以使用对应库文件的<code>TypeScript</code>类型文件，比如我们前面说<code>lodash</code>，我们进行输入命令<code>npm install @types/lodash --save-dev</code>进行安装对应的<code>TypeScript</code>类型文件，然后我们调用里面的函数，如果传入的参数不对，会直接进行提示；<br>
我们在<code>TypeScript</code>中引用<code>lodash</code>,需要使用下面的代码：</p>
<pre><code class="language-js">import * as _ from 'lodash'
</code></pre>
<p>如果需要使用其他库文件，就安装对应的<code>TypeScript</code>类型文件。如果你不知道有还是没有，可以在这个网站;<code>https://microsoft.github.io/TypeSearch/</code>进行搜索对应的库文件。</p>
<h4 id="4-使用-webpackdevserver-实现请求转发">4. 使用 WebpackDevServer 实现请求转发</h4>
<p>我们一般在前端发送<code>ajax</code>请求是使用<code>axios</code>这个库进行发送请求，首先我们需要进行安装；一个简单的请求如下：</p>
<pre><code class="language-js">import axios from 'axios'
axios.get('http://www.dell-lee.com/react/api/header.json')
.then((res) =&gt; {
  console.log(res)
})
</code></pre>
<p>我们一般在生产环境的时候，是使用其他服务器的<code>api</code>接口，并不是使用真正的后台接口，是一台测试的服务器，线上环境我们是使用真正的接口数据。所所以这个时候，我们就需要进行对接口的转发。配置<code>devServer</code>如下：<code>'/react/api': 'http://www.dell-lee.com'</code>代码的意思就是当我发送请求<code>/react/api</code>地址的时候，接口转发到<code>http://www.dell-lee.com</code>这个地址。进行获取对应的数据。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': 'http://www.dell-lee.com',
      },
      hot: true,
    },
</code></pre>
<p>然后在发送请求的地址如下代码：</p>
<pre><code class="language-js">import axios from 'axios'
axios.get('/react/api/header.json')
.then((res) =&gt; {
  console.log(res)
})
</code></pre>
<p>也可以对一个接口请求的地址进行转发，比如我们现在请求的是<code>http://www.dell-lee.com/react/api/header.json</code>实际我们需要请求的是<code>http://www.dell-lee.com/react/api/demo.json</code>,可以在<code>devserver</code>配置如下;</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>当然我们只有在开发环境的时候进行上面的配置是有用的，有时候我们请求的地址是<code>https</code>协议的网址，需要加一个配置项：<code>secure: false,</code></p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>我们在这里也可以进行拦截，比如下面的代码配置：<code>bypass</code>里面的配置项就是说当发送请求要接手的是<code>html</code>页面数据的时候，也就是说请求是一个<code>html</code>的地址的时候，直接跳转到<code>index.html</code>页面。</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>如果我们代理多个路基，可以进行下面这样的配置：我们上面只有一个<code>'/react/api'</code>一个路径，下面代码表示遇到<code>'/auth', '/api'</code>这两个地址，都是转发到<code>https://www.dell-lee.com</code>这个服务器。</p>
<pre><code class="language-js">    devServer: {
      proxy: {
      context: ['/auth', '/api'],
      target: 'https://www.dell-lee.com',
      },
      hot: true,
    },
</code></pre>
<p>如果我们想做一个根目录的路径的转发，也就是<code>'/'</code>，我们需要将配置项的<code>index</code>设置为<code>false</code>或者为<code>''</code>空字符串，如下配置:</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        index: '',
        '/': {
          target: 'https://www.dell-lee.com',
          secure: false,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>我们可以设置<code>changeOrigin: true</code>来覆盖一些请求服务器对<code>origin</code>进行的配置，如下代码：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        index: '',
        '/': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<h4 id="5-webpackdevserver-解决单页面应用路由问题">5.  WebpackDevServer 解决单页面应用路由问题</h4>
<p>如果我们需要实现<code>react</code>的路由功能实现单页面应用，需要安装路由组件，输入命令：<code>npm intall react-router-dom --save</code>，然后我们写了两个组件<code>home</code> 跟 <code>list</code> 两个组件，代码如下：</p>
<pre><code class="language-js">import React, { Component } from 'react'
import {BrowserRouter, Router} from 'react-router-dom';
import ReactDom from 'react-dom'
import Home from './home.js';
import List from './list.js'


class App extends Component {
  return () {
    return (
      &lt;BrowserRouter&gt;
        &lt;div&gt;
         &lt;Router path='/' component={Home} /&gt;
         &lt;Router path='/list' component={List}/&gt;
         &lt;/div&gt;
      &lt;/BrowserRouter&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p><code>home.js</code>代码：</p>
<pre><code class="language-js">import React, { Component } from 'react';

class Home extends Component {
    render () {
        return &lt;div&gt;HomePages&lt;/div&gt;
    }
}
export default Home
</code></pre>
<p><code>list.js</code>代码：</p>
<pre><code class="language-js">import React, { Component } from 'react';

class Home extends Component {
    render () {
        return &lt;div&gt;HomePages&lt;/div&gt;
    }
}
export default Home
</code></pre>
<p>我们写完代码之后，运行；当我们地址中访问<code>list</code>页面的时候，会发现找不到对应的页面，这是因为，<code>webpack</code>将我们页面 的请求以为是发送到后台的<code>api</code>接口。解决这个问题，我们就需要在<code>devserver</code>中进行配置<code>historyApiFallback</code>的配置项，具体配置如下：<code>historyApiFallback: true,</code></p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      historyApiFallback: true,
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<p>这个选项也可以是一个对象，进行配置规则，进行进一步配置：代码意思是，当访问<code>item.html</code>的时候，实际访问的是<code>list.html</code>页面。</p>
<pre><code class="language-js">      historyApiFallback: {
        rewrites: [
          { 
            from: '/item.html',
            to: '/list.html'
          }
        ]
      },
</code></pre>
<p>其实我们前面配置的<code>historyApiFallback: true,</code>实际等价于下面的配置：也就是不官方文哪一个都是指向<code>index.html</code>页面。</p>
<pre><code class="language-js">      historyApiFallback: {
        rewrites: [
          { 
            from: '/\.*/',
            to: '/index.html'
          }
        ]
      },
</code></pre>
<h4 id="6-eslint-在-webpack-中的配置">6.  EsLint 在 Webpack 中的配置</h4>
<p><code>EsLint</code>就是规范我们代码书写的插件，输入命令<code>npm install eslint --save-dev</code>,然后在我们的项目中，通过命令<code>npx eslint --init</code>快速生成我们代码约束的配置文件，按照提示的信息进行配置我们的代码约束规则。我们可以输入命令<code>npx eslint src</code>这样的命令。来检测<code>src</code>目录下文件的书写规范，或者直接可以检测一个文件<code>npx eslint index.js</code>这样进行检测。<br>
如果我们配置的代码检测的规范是使用<code>airbnb</code>这种规范，我们会发现，我们去检测我们写的<code>react</code>的代码的时候，会提示很多错误，这是因为这个规范只是检测常规的<code>js</code>代码的一些规范，不会进行解析<code>react</code>的代码，进行检测规范，这个时候，我们需要添加一个解析器，<code>.eslintrc.js</code>配置代码如下：需要安装<code>babel-eslint</code>这个解析器，输入命令<code>npm install babel-eslint --save-dev</code>进行安装。</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;
}
</code></pre>
<p>也可以直接在<code>vscode</code>这个编译器中进行安装<code>eslint</code>插件，进行检测我们的代码规范，进行提示。我们也可以自己进行配置一些规范是否启用，在<code>.eslintrc.js</code>中进行配置，比如我们不需要一个配置，直接在<code>rules</code>中将对应的规范配置为0：</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    &quot;react/prefer-stateless-function&quot;: 0
  }
}
</code></pre>
<p>还有一些<code>eslint</code>的配置可以查看另一篇文章：https://blog.csdn.net/cj9551/article/details/90740377#15_ESLint_457  里面有对应的<code>eslint</code>的配置。<br>
如果需要使用全局变量，可以在配置项中进行配置：<code>document: false</code>不会被重新覆盖。</p>
<pre><code class="language-js">module.exports = {
  &quot;extends&quot;: &quot;airbnb&quot;,
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    &quot;react/prefer-stateless-function&quot;: 0
  },
  global: {
    document: false
  }
}
</code></pre>
<p>如果有的人的编译软件，是不能安装<code>eslint</code>查看，我们可以直接在<code>webpack</code>中进行配置这样一个检测环境，首先安装<code>eslint-loader</code>这样一个<code>loader</code>，输入命令<code>npm install eslint-loader --save-dev</code>，然后在<code>webpack.config.js</code>中进行配置：</p>
<pre><code class="language-js">module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            use: ['babel-loader', 'eslint-loader']
        }]
    },
</code></pre>
<p>然后运行命令，就可以在终端窗口看到一些代码规范的提示，我们也可以在<code>devserver</code>中进行添加一个<code>overlay: true</code>的配置，将代码规范的提示，直接显示在浏览器的页面中：</p>
<pre><code class="language-js">    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      // historyApiFallback: true,
      historyApiFallback: {
        rewrites: [
          { 
            from: '/item.html',
            to: '/list.html'
          }
        ]
      },
      proxy: {
        '/react/api': {
          target: 'https://www.dell-lee.com',
          secure: false,
          changeOrigin: true,
          overlay: true,
          bypass: function(req, res, proxyOptions) {
            if (req.headers.accept.indexOf('html') !== -1) {
              console.log('Skipping proxy for browser request.');
              return '/index.html';
            }
          },
          pathRewrite: {
            'header.json': 'demo.json'
          }
        },
      },
      hot: true,
    },
</code></pre>
<h4 id="7-webpack-性能优化">7.   webpack 性能优化</h4>
<ul>
<li>跟上技术的迭代（node，npm，yarn）：升级我们对应的工具；<code>webpack</code>运行在<code>node</code>之上。升级到新的版本，也会间接提升<code>webpack</code>打包速度。</li>
<li>在尽可能少的模块上应用<code>Loader</code>： 比如我们在打包<code>js</code>的文件的时候使用<code>babel-loader</code>进行转换，我们可以通过<code>includes</code>以及<code>excludes</code>等选项，进行配置不对其他库文件进行转换，降低使用<code>loader</code>的频率。</li>
<li><code>Plugin</code> 尽可能精简并确保可靠：比如我们在线上环境的配置中使用了<code>MiniCssExtractPlugin</code>插件进行将<code>css</code>代码进行压缩，但是我们在生产环境中，并不需要使用这个插件进行压缩我们的代码，要尽可能的精简。减少了代码压缩的时间。还有就是尽量使用<code>webpack</code>官网中推荐的插件。</li>
<li>一般我们在打包配置<code>js</code>的文件，与<code>jsx</code>的文件，打包规则是一样的，我们在<code>test</code>匹配的时候，可以使用<code>test: /\.jsx?$/,</code>进行匹配打包。</li>
<li>尽量减少下面的一些操作：我们有时候通过<code>import</code>的方式进行引入一个模块，我们在模块的结尾并没有明确是加载哪个类型的文件，<code>import List from './list'</code>默认是加载<code>js</code>结尾的文件，但是有时候我们的库文件是<code>jsx</code>结尾的文件，我们也想通过这种方式进行加载<code>jsx</code>文件，可以进行下面的配置：<code>extensions: ['.js', '.jsx']</code>代码意思就是引入包之后，他会按照是否有对应的<code>js</code>,如果有就进行加载，如果没有继续找是否有对应的<code>jsx</code>文件进行加载。</li>
</ul>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx']
    }
.....
}
</code></pre>
<p>这个选项还可以配置我们通过引入路径，然后对路径中的文件名进行对应的加载，比如：<code>import List from './list/'</code>这个<code>list</code>是<code>src</code>目录中的一个文件夹名，然后该文件夹中有很多<code>js</code>文件，如果按照这种引入方式，他会自动检查是否有文件名叫<code>index</code>的文件，然后进行引入，如果没有，就不会进行引入，我们可以通过配置<code>resolve</code>选项，配置加载的文件名：<code>mainFiles: ['index', 'list']</code>代码意思是如果通过路径的方式进行引入模块，首先检查进行加载<code>index</code>的文件名，如果没有，进行检查是否有<code>list</code>的文件名进行引入。</p>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx'],
       mainFiles: ['index', 'list']
    }
.....
}
</code></pre>
<p>同样上面的<code>extensions</code>,以及 <code>mainFiles</code>的配置，会影响打包的性能。在<code>resolve</code>中，我们也可以进行设置路径的别名：比如我们有时候想引入一个模块通过一个字符串，进行代表该库文件的地址，进行引入模块：<code>import list from 'listpath'</code>这样的方法进行引入模块。我们就可以设置别名，让<code>listpath</code>指向该模块的地址。</p>
<pre><code class="language-js">module.exports = {
.....
    // 入口文件
    entry: {
        main: './src/index.js',
    },
    resolve: {
       extensions: ['.js', '.jsx'],
       mainFiles: ['index', 'list'],
       alias: {
        listpath: path.resolve(__dirname, '../src/list')
      }
    }
.....
}
</code></pre>
<h4 id="8-使用dllplugin提高打包速度">8.  使用DllPlugin提高打包速度</h4>
<p>我们实现的思路：</p>
<ol>
<li>第三方模块打包一次</li>
<li>我们引入第三方模块的时候，要去使用打包输出的第三方模块的文件进行引入。<br>
我们在打包自己的项目的时候会发现，如果引入了过多的第三方库文件，会使打包的速度降低；我们可以想如果能够实现在第一次打包的时候就去分析第三方模块的代码，然后再次打包的时候，就根据前面分析的结果进行打包，不用再次分析，提高打包效率；<br>
添加一个<code>webpack.dll.js</code>的配置文件，代码如下：这里是将我们引入的第三方模块打包到<code>dll</code>文件夹中，<code>library: '[name]'</code>这句代码的意思就是，将我们打包后的第三方模块通过变量的形式暴露到全局中；变量的名字叫<code>vender</code>；</li>
</ol>
<pre><code class="language-js">const path = require('path')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['react', 'react-dom', 'lodash']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    }
}
</code></pre>
<p>然后我们需要安装一个插件，将我们的打包后的文件进行挂载到我们打包输出的页面中，输入命令<code>npm install add-asset-html-webpack-plugin --save</code>这个插件的作用就是往<code>html</code>页面中去增加静态资源。然后在<code>webpack.config.js</code>中进行配置：这样页面就会将我们打包输出的第三方模块的<code>vender.dll.js</code>进行挂载；</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }) 
    ]
.......
}
</code></pre>
<p>接下来我们就要实现引入第三方模块的时候，通过我们上一步打包输出的文件进行引入，首先我们需要进行分析前面打包输出的第三方库文件，将分析结果进行保存，使用<code>DllPlugin</code>进行分析，在<code>webpack.dll.js</code>的配置文件中进行如下配置：<code>name: '[name]',</code>是指要分析的库名，<code>path: path.resolve(__dirname, '../dll/[name].manifest.json')</code>代码意思就是将分析的结构放在<code>../dll/[name].manifest.json</code></p>
<pre><code class="language-js">const path = require('path')
const webpack = require('webpack')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['react', 'react-dom', 'lodash']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    },
    plugins: [
        new webpack.DllPlugin({
            name: '[name]',
            path: path.resolve(__dirname, '../dll/[name].manifest.json')
        })
    ]
}
</code></pre>
<p>然后我们做的就是根据我们前面生成的<code>library: '[name]'</code>全局变量的名字，以及分析的文件，在<code>webpack</code>进行配置打包：<br>
在<code>webpack.config.js</code>中使用一个插件：<code>manifest: path.resolve(__dirname, '../dll/vendors.manifest.js')</code>意思就是我们在代码中如果引入了第三方模块。他就会在<code>vendors.manifest.json</code>这个文件中去找对应的第三方模块的映射关系，如果可以找到，他就会知道这个第三方模块不用再次引入了，直接使用<code>vendors.dll.js</code>这个文件就可以了，他会在全局变量中进行使用我们的第三方模块。如果没有映射关系，就会进行将第三方库进行打包。</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/vendors.manifest.json')
        })
    ]
.......
}
</code></pre>
<p>然后我们在<code>package.json</code>里面配置一个命令：<code>&quot;build:dll&quot;: &quot;webpack --config ./build/webpack.dll.js&quot;</code>来执行我们的打包第三方模块的命令。然后进行打包，会发现比之前的打包速度要快很多。<br>
其实我们前面打包第三方库输出额时候可以进行拆分：</p>
<pre><code class="language-js">const path = require('path')
nodule.exports = {
    mode: 'production',
    entry: {
        vendors: ['lodash'],
        react: ['react', 'react-dom']
    },
    output: {
        filename: '[name].dll.js',
        path: path.resolve(__dirname, '../dll'),
        library: '[name]'
    }
}
</code></pre>
<p>对应的在<code>webpack.config.js</code>中也需要进行配置：</p>
<pre><code class="language-js">const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: [
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/vendors.dll.js')
        }),
        new AddAssetHtmlWebpackPlugin({
            filepath: path.resolve(__dirname, '../dll/react.dll.js')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/vendors.manifest.json')
        }),
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll/react.manifest.json')
        })
    ]
.......
}
</code></pre>
<p>如果我们按照上面的，配置很多的话，就特别繁琐，我们可以通过下面的方法进行简单化：</p>
<pre><code class="language-js">const plugins = [
    new CleanWebpackPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new HtmlWebpakcPlugin({
        template: './src/index.html'
    })
]
const fs = require('fs')
const files = fs.readdirSync(path.resolve(__dirname, './dll'))
files.forEach(file =&gt; {
    if(/.*\.dll.js/.test(file)) {
        plugins.push(
          new AddAssetHtmlWebpackPlugin({
              filepath: path.resolve(__dirname, '../dll', file)
          }))
    }
    if(/.*\.manifest.json/.test(file)) {
        new webpack.DllReferencePlugin({
            manifest: path.resolve(__dirname, '../dll', file)
        })
    }
})

const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')
......
module.exports = {
......
    plugins: plugins
.......
}
</code></pre>
<h4 id="9-webpack其他打包优化方法">9. Webpack其他打包优化方法</h4>
<ul>
<li>控制包文件大小：在源代码中将用不到的包文件在打包的时候通过<code>Tree Shaking</code>进行去除，或者直接不进行引入；也可以通过<code>splitchunkplugins</code>插件进行包的拆分，提高打包速率。</li>
<li><code>tread-loader, parallel-webpack, happypack</code> 多进程打包。</li>
<li>合理使用<code>sourceMap</code>：不同环境打包，使用最佳的<code>sourceMap</code>方式。</li>
<li>结合<code>stats</code>分析打包结果：根据分析结果进行优化。</li>
<li>开发环境内存编译。</li>
<li>开发环境无用插件剔除：比如开发环境中不需要对代码进行压缩，将<code>mode</code>设置为<code>production</code>。</li>
</ul>
<h4 id="10-多页面打包配置">10. 多页面打包配置</h4>
<p>我们前面所说的都是单页面进行打包，也就是打包之后就生成一个<code>index.html</code>页面。比如说我们有两个页面一个<code>index.js</code>，一个<code>list.js</code>内容分别如下：<br>
<code>index.js</code>:</p>
<pre><code class="language-js">class App extends Component {
  return () {
    return (
        &lt;div&gt;
        index
         &lt;/div&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p><code>list.js</code>:</p>
<pre><code class="language-js">class App extends Component {
  return () {
    return (
        &lt;div&gt;
        list
         &lt;/div&gt;
    )
  }
}
ReactDom.render(&lt;h1&gt;list!&lt;/h1&gt;, document.getElementById('root'))
</code></pre>
<p>这是两个不同的页面，我们希望打包之后有两个<code>html</code>页面，一个引入<code>iindex.js</code>打包之后的文件，一个引入<code>list.js</code>打包之后的文件。首先我们需要修改打包的入口文件，将<code>list.js</code>文件进行添加：</p>
<pre><code class="language-js">    // 入口文件
    entry: {
        main: './src/index.js',
        list: './src/list.js'
    },
</code></pre>
<p>然后修改我们之前配置的打包输出设置的模板<code>html</code>：设置打包输出的<code>html</code>的文件名，并且设置页面引用的包文件。</p>
<pre><code class="language-js">plugins: [
    new CleanWebpackPlugin(),
    new webpack.HotModuleReplacementPlugin(),
    new HtmlWebpakcPlugin({
        template: './src/index.html',
        filename: 'index.html',
        chunks: ['runtime', 'vendors', 'main']
    }),
    new HtmlWebpakcPlugin({
        template: './src/index.html',
        filename: 'list.html',
        chunks: ['runtime', 'vendors', 'list']
    })
]
</code></pre>
<p>我们如果有很多页面进行打包，如果重复上面的操作就特别麻烦，所以我们可以进行处理上面的代码：</p>
<pre><code class="language-js">// 引入node核心模块path
const path = require('path')
// 将我们写的html文件，进行打包；
const HtmlWebpakcPlugin = require('html-webpack-plugin')
// 清除上次打包生成的js文件
const CleanWebpackPlugin = require('clean-webpack-plugin')
const webpack = require('webpack');
const fs = require('fs')
const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin')

const makePlugins = (configs) =&gt; {
    const plugins = [new CleanWebpackPlugin()]
    const files = fs.readdirSync(path.resolve(__dirname, './dll'))
    Object.keys(configs.entry).forEach(item =&gt; [
        plugins.push(new HtmlWebpakcPlugin({
            template: './src/index.html',
            filename: `${item}.html`,
            chunks: ['runtime', 'vendors', item]
        }))
    ]);

    files.forEach(file =&gt; {
        if(/.*\.dll.js/.test(file)) {
            plugins.push(
              new AddAssetHtmlWebpackPlugin({
                  filepath: path.resolve(__dirname, '../dll', file)
              }))
        }
        if(/.*\.manifest.json/.test(file)) {
            new webpack.DllReferencePlugin({
                manifest: path.resolve(__dirname, '../dll', file)
            })
        }
    })
    return plugins;
}

const configs =  {
    // 配置打包模式
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
    // 入口文件
    entry: {
        main: './src/index.js',
        list: './src/list.js'
    },
    devServer: {
      // 服务器启动的根路径
      contentBase: './dist',
      open: true,
      proxy: {
        '/api': 'http://localhost:3000'
      },
      hot: true,
      hotOnly: true
    },
    stats: { children: false },
    module: {
        rules: [{ 
            test: /\.js$/,
            exclude: /node_modules/,
            loader: &quot;babel-loader&quot;
        },
            {
            test: /\.(png|jpe?g|gif)$/,
            use: {
                loader: 'url-loader',
                options: {
                    name: '[name].[ext]',
                    outputPath: 'images/',
                    limit: 204800
                }
            }
        }, {
            test: /\.vue$/,
            use: {
                loader: 'vue-loader'
            }
        }, {
            test: /\.scss$/,
            use: [
                'style-loader',
                {
                  loader: 'css-loader',
                  options: {
                    importLoaders: 2
                  }
                },
                'sass-loader',
                'postcss-loader'
            ]
        }, {
            test: /\.(eot|ttf|svg|woff)$/,
            use: {
                loader: 'file-loader'
            }
        }, {
            test: /\.css$/,
            use: [
                'style-loader',
                'css-loader',
                'postcss-loader'
            ]
        },{
            test: /\.(html)$/,
            use: {
                loader: 'html-loader',
            }
        }]
    },
    optimization: {
      usedExports: true
    },
    // 打包出的文件配置
    output: {
        path: path.resolve(__dirname, 'dist')
    }
}
module.exports = configs
configs.plugins = makePlugins(configs)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6笔记]]></title>
        <id>https://jiegiser.github.io/newBlog/post/es6-bi-ji</id>
        <link href="https://jiegiser.github.io/newBlog/post/es6-bi-ji">
        </link>
        <updated>2019-12-06T01:36:57.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-变量">1. 变量</h4>
<ul>
<li><code>var</code>声明的变量是<code>function scope</code>也就是在函数中可以访问到，并不是在大括号里面声明的，外层就访问不到。<code>let const</code>声明的变量都是<code>block scope</code>块级作用域，也就是在大括号里面可以访问到。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-变量">1. 变量</h4>
<ul>
<li><code>var</code>声明的变量是<code>function scope</code>也就是在函数中可以访问到，并不是在大括号里面声明的，外层就访问不到。<code>let const</code>声明的变量都是<code>block scope</code>块级作用域，也就是在大括号里面可以访问到。</li>
</ul>
<!-- more -->
<ul>
<li><code>let</code>和 <code>const</code> 都不允许重复声明。他们两个都不可以在同一个作用域中进行重复声明，比如，在函数中声明的变量跟在函数外声明的同名的变量是不同的。<code>let</code> 定义的变量可以重新赋值，<code>const</code>是不可以的。</li>
<li><code>const</code> 声明的对象，对象是一个引用类型的值，可以进行修改对象的属性。如果想要定义的对象的属性是不可以改变可以使用<code>es5</code>中的<code>Object.freeze()</code>这个方法：<code>const jelly = Object.freeze(person)</code></li>
<li><code>let</code> 跟<code>const</code>都是存在暂时性死区的，也就是说；我们在声明前使用调用变量，会报<code>RefrenceError</code>的错误；而<code>var</code>声明的变量是没有的；这样，我们也可以养成习惯，在使用变量之前，进行声明。</li>
</ul>
<h4 id="2-箭头函数">2. 箭头函数</h4>
<h5 id="21-优点">2.1 优点：</h5>
<ul>
<li>简明语法</li>
<li>可以隐式返回：也就是可以不使用<code>return</code>关键字进行返回；删除<code>{}</code>大括号。</li>
<li>不绑定<code>this</code>：箭头函数没有自己的<code>this</code>值，他的<code>this</code>值是继承他的父级作用域的，<code>this</code>值是定义的时候就绑定了。</li>
<li>箭头函数也是匿名函数，我们可以通过定义变量，等于箭头函数，当进行调用：</li>
</ul>
<pre><code class="language-js">const gree = name =&gt; { alert (`hello ${name}`)}
</code></pre>
<p>一个函数在他独立运行的时候，也就是说他没有作为对象的方法去调用，也没用<code>call</code>、<code>apply</code>等方法进行绑定；这里的数组里面<code>map</code>的回调函数就是一个独立运行的，所以他的<code>this</code>值是在运行的时候动态绑定的，绑定到了<code>window</code>对象上，所以不会获取到<code>name</code>值。</p>
<pre><code class="language-js">const jelly = {
  name: 'jiegiser',
  bobbies: ['sleeping', 'coding', 'reading'],
  print: function () {
    this.hobbies.map(function (hobby) {
      console.log(`${this.name} loves ${hobby}`)
    })
  }

}
</code></pre>
<h5 id="22-箭头函数的局限性">2.2 箭头函数的局限性：</h5>
<ul>
<li>作为构造函数，一个方法需要绑定到对象：下面的代码。<code>Person</code>对象中使用箭头函数，并没有将<code>this</code>绑定到它本身。所以，这里需要使用原始的函数。下面的给原型绑定方法，同样也是，<code>this</code>指向的是父级的<code>this</code>所以指向<code>window</code>对象；</li>
</ul>
<pre><code class="language-js">const Person = (name, points) =&gt; {
  this.name = name;
  this.points = points;
}
const jelly = new Person ('Jelly', 5);
Person.prototype.updatePoints = () =&gt; {
  this.points ++;
  console.count(this.points)
}
</code></pre>
<ul>
<li>当你真的需要this的时候：下面代码的<code>this</code>指向的是调用<code>addEventListener</code>方法的对象；箭头函数的<code>this</code>是不会绑定的，所以这里的也还是<code>window</code>对象。<code>setTimeout</code>里面应该是使用箭头函数，来邦定<code>this</code>值在该作用域。</li>
</ul>
<pre><code class="language-js">const button = document.querySelector('.zoom');
button.addEventListener('click', () =&gt; {
  this.classList.add('in');
  setTimeout(() =&gt; {
    this.classList.remove('in')
  }, 2000);
})
</code></pre>
<ul>
<li>需要使用arguments对象：箭头函数中是没有<code>arguments</code>对象的。</li>
</ul>
<pre><code class="language-js">const sum = () =&gt; {
  return Array.from(arguments).reduce((prevSum, value) =&gt; prevSum + value,0)
}
</code></pre>
<h4 id="3-es6-参数默认值">3. ES6 参数默认值</h4>
<p>我们在函数中可以通过下面的方法进行设置默认参数值：</p>
<pre><code class="language-js">function add (a = 1, b = 5) {
  return a + b;
}
</code></pre>
<p>当我们需要第一个参数使用默认值的时候，这样<code>add(undeffined, 2)</code>这样，如果<code>add(1)</code>这样调用的话，第二个参数使用默认值。</p>
<h4 id="4-模板字符串">4. 模板字符串</h4>
<p><code>es6</code>中的模板字符串是可以嵌套的，以及在<code>${}</code>中可以直接调用方法。<br>
还有一个标签模板字符串：</p>
<pre><code class="language-js">function highLight(string, user, topic) {
  return 'templa'
}
const user = 'jie';
const topic = 'learn es6';
const sentence = highLight`${user} has commented on your topic ${topic}`
</code></pre>
<p>然后我们查看<code>sentence</code>，他就会返回标签模板字符串中返回的东西；<br>
<img src="https://img-blog.csdnimg.cn/20190602110837804.png" alt="在这里插入图片描述"><br>
对应标签模板字符串是有是三个参数的，<code>string, user, topic</code>第一个参数是返回模板字符串中默认内容；返回值是一个数组，如果不是以模板字符串传入的变量开头的，那数组的第一个不死空字符串；如上面代码中，返回的是[&quot; &quot;,<code>has commented on your topic</code>,&quot; &quot;]，然后后面的参数就是模板字符串中传入的变量。我们这里传入的是<code>${user}</code>跟<code>${topic}</code>，但是如果我们传入了很多的参数，这个时候我们可以使用<code>es6</code>的剩余参数：<code>...values</code>他是参数的数组，这样我们就获取到所有的参数。我们可以使用标签模板字符串，来返回我们想要的值。</p>
<pre><code class="language-js">function highLight(string, ...values) {
  debugger;
  return 'templa'
}
</code></pre>
<p>我们可以使用标签模板字符串，去处理我们输入的参数，比如在留言板等功能中，为了防止<code>xss</code>攻击，我们可以通过模板字符串进行过滤用户输入的内容。可以使用第三方的包：<code>DOMPurify</code>进行过滤。</p>
<h4 id="5-对象解构">5. 对象解构</h4>
<p>我们有一个对象如下：</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}
</code></pre>
<p>我们每次访问的时候，需要进行<code>Tom.name</code>这样进行访问，如果属性有很多的话，就比较麻烦，我们可以这样写：这样去访问他的属性</p>
<pre><code class="language-js">
const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { name, age } =Tom
console.log(name)
console.log(age)
</code></pre>
<p>如果我们想要先声明变量，然后进行结构对象，可以如下面这样写：</p>
<pre><code class="language-js">let name = '';
({ name, age } = Tom);
</code></pre>
<p>对象解构也可以进行嵌套，如上面的代码，我们想要访问<code>family</code>属性，我们可以这样写：</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father, mother } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>我们在解构的时候也可以进行重新命名，类似<code>sql</code>中的<code>as</code>；可以这样写：<code>father: f</code>这样，将<code>father</code>属性赋值给<code>f</code>变量。</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father: f, mother } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>我们在对象解构的时候，也可以给解构后的变量赋予默认值，如果被解构的对象没有该属性为<code>undefined</code>，就使用我们的默认值，如下代码：<code>sister = 'haove no sister'</code>这样。</p>
<pre><code class="language-js">const Tom = {
  name: 'tom',
  age: 18,
  family: {
    mother: 'tom mother',
    father: 'tom father'
  }
}

const { father: f, mother, sister = 'haove no sister' } =Tom.family
console.log(mother)
console.log(father)
</code></pre>
<p>如下面代码，经常会在封装一些插件中，会使用默认值：<br>
<img src="https://img-blog.csdnimg.cn/20190602141028611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="6-数组解构">6. 数组解构</h4>
<p>数组的解构基本跟对象的解构类似：下面代码是解构了数组的第一项，跟第二项</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, two] = number;
console.log(one, two)
</code></pre>
<p>如果我们想回去第一个跟第三个：需要添加一个逗号进行分隔，流出第二个位置。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, , two] = number;
console.log(one, two)
</code></pre>
<p>如果想要获取到第一个值，跟后面所有的值，我们可以使用扩展运算符，将剩余项组成一个数组：</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];
const [one, ...other] = number;
console.log(one, other)
</code></pre>
<p><code>rest</code>参数只能使最后一个，也就是说解析后面所有的，不能解析某一部分：<code>const [one, ...other, four] = number;</code>这样就会报错。</p>
<p>数组的结构也可以进行赋予默认值：同样相应的值为<code>undefined</code>的时候，才会使用默认的值。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three'];
const [one, two, three = 'three'] = number;
</code></pre>
<p>数组的解构的使用技巧可以用在交换两个变量的值：</p>
<pre><code class="language-js">let a = 10;
let b = 20;
[a,b] = [b,a];
</code></pre>
<h4 id="7-for-of-用法">7. for of 用法</h4>
<p><code>forEach</code>循环不能终止循环，<code>for in</code>循环，循环的是<code>index</code>值，遍历的是变量的可枚举属性。即使是原型的属性也会进行循环出来。使用<code>for of</code>是循环的属性值：在循环中，也可以使用<code>break</code>进行中断循环。</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];

for (item of number) {
  console.log(item)
}
</code></pre>
<p><code>for of</code>循环还可以用于遍历数组的遍历器属性：</p>
<pre><code class="language-js">const number = ['one', 'two', 'three', 'four'];

for ( let [index, fruit] of number.entries()){
  console.log(index, number)
}
</code></pre>
<p><code>for of</code>不支持对象的循环。可以应用于字符串：</p>
<pre><code class="language-js">const number = 'sddsdsd;

for ( let code of number){
  console.log(code)
}
</code></pre>
<p><code>for of</code>循环还可以用于<code>nodeList</code>进行循环：</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
for ( let li of lis) {
  li.addEventListener('click', function () {
    //执行方法
  })
}
</code></pre>
<h4 id="8-arrayfrom-arrayof">8. Array.from()  Array.of()</h4>
<h5 id="81-arrayfrom">8.1 Array.from()</h5>
<p>这两个方法并不是数组原型的方法，我们需要通过<code>Array.from() Array.of()</code>这种去调用，而不是声明一个数组点上这个方法。<code>Array.from()</code>方法是将一个类素组对象转换为数组对象。类素组对象也就是拥有<code>length</code>属性的对象，<code>modeList</code>就是一个类数组对象。</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
const lisArr = Array.form(lis)
const names = lisArray.map(li =&gt; li.textContent)
</code></pre>
<p><code>Array.from()</code>方法有两个参数，第一个参数是需要准换的类数组，第二个参数类似数组的<code>map</code>方法，会给转化后的数组中的每一项执行该方法，于是，上面的代码可以简写为下面：</p>
<pre><code class="language-js">const lis = document.querySelectorAll('li')
const names = Array.form(lis， li =&gt; li.textContent)
</code></pre>
<p>也可以利用<code>Array.from()</code>方法进行转换函数中的<code>arguments</code>属性进行转化。<br>
我们也可以利用<code>Array.from()</code>方法将字符串也能转换为一个数组。</p>
<pre><code class="language-js">const number = 'sddsdsd;
console.log(Array.from(number))
</code></pre>
<h5 id="82-arrayof">8.2 Array.of()</h5>
<p><code>Array.of()</code>方法就是根据传入的参数，返回一个由传入的参数组成的数组；</p>
<h4 id="9-数组的其他方法">9. 数组的其他方法</h4>
<h5 id="91-find">9.1 .find()</h5>
<p>查找是否有<code>bananas</code>这个选项；返回的是找到的该选项，以对象返回；</p>
<pre><code class="language-js">const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5},
]
const bananas = inventory.find(fruit =&gt; {
  if (fruit.name === 'bananas') {
    return true
  }
  return false
})
</code></pre>
<h5 id="92-findindex">9.2 .findIndex()</h5>
<p><code>findIndex()</code>返回的是要查找的选项的索引值：</p>
<pre><code class="language-js">const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5},
]
const bananas = inventory.findIndex(fruit =&gt; fruit.name === 'bananas');//返回的是索引值1
</code></pre>
<h5 id="93-some">9.3 .some()</h5>
<p>返回的布尔值；如果有一部分满足测试函数，就返回<code>true</code></p>
<pre><code class="language-js">const isEnough= inventory.some(fruit =&gt; fruit.quantity &gt; 0);//返回true
</code></pre>
<h5 id="94-every">9.4 .every()</h5>
<p>返回的布尔值；如果所有的都满足测试函数，就返回<code>true</code></p>
<pre><code class="language-js">const isAllenough= inventory.every(fruit =&gt; fruit.quantity &gt; 0);//返回false
</code></pre>
<h4 id="10-剩余参数">10. 剩余参数</h4>
<pre><code class="language-js">function sum (...numbers) {
  console.log(numbers)//一个数组[1, 2, 3, 4]
}
sum (1, 2, 3, 4)
</code></pre>
<h4 id="11-扩展运算符">11. 扩展运算符</h4>
<p>我们如果想要两个数组，合并为一个数组，并且，在中间插入一个值，如下我们以前写的代码：</p>
<pre><code class="language-js">const youngers = ['george' , 'john', 'Thomas'];
const olders = ['James', 'Adrew', 'Martin'];

let members = [];
members = members.concat(youngers);
members.push('Mary');
members = members.concat(olders);
</code></pre>
<p>使用<code>es6</code>可以这样写：</p>
<pre><code class="language-js">const youngers = ['george' , 'john', 'Thomas'];
const olders = ['James', 'Adrew', 'Martin'];

let members = [...youngers, 'Mary', ...olders];
</code></pre>
<p>可以通过扩展运算符将一个字符串变为以每一个字符变为数组中的一项：</p>
<pre><code class="language-js">[...'jiegiser']
//[&quot;j&quot;, &quot;i&quot;, &quot;e&quot;, &quot;g&quot;, &quot;i&quot;, &quot;s&quot;, &quot;e&quot;, &quot;r&quot;]
</code></pre>
<p>可以借助扩展运算符，放置我们将数组赋值给另一个数组，修改另一个数组中的数据，会将源数组的值进行改变：</p>
<pre><code class="language-js">const currentMembers = [...numbers];
</code></pre>
<p>我们可以使用扩展运算符将可遍历对象扩展到一个新的数组中：</p>
<pre><code class="language-js">const todos = [...document.querySelectorAll('li')]
</code></pre>
<p>比如我们需要删除一个数组中，对象属性<code>id</code>为2的一项；代码如下：</p>
<pre><code class="language-js">const todos = [
  {id: 1, name: 'Go to store', completed: false},
  {id: 2, name: 'Wacth TV', completed: true},
  {id: 3, name: 'Go Shopping', completed: false},
]
// 要删除的项的id为2
const id = 2;
const todoIndex = todos.findIndex(todo =&gt; todo.id === id)

const newTodos = [...todos.slice(0, todoIndex), ...todos.slice(todoIndex + 1)];
</code></pre>
<p>我们还可以将一个数组通过扩展运算符，追加到另一个数组后：</p>
<pre><code class="language-js">const fruit = ['apple', 'bananas', 'pear'];
const newFruit = ['orange', 'mongo'];
fruit.push(...newFruit)
</code></pre>
<p>还可以利用扩展运算符，将数组扩展为函数的参数：</p>
<pre><code class="language-js">const dateField = [2019, 6, 2];
const data = new Date(...dateField)
console.log(data);
</code></pre>
<h4 id="12-对象的计算属性">12. 对象的计算属性</h4>
<p>假如我们需要定义一个对象：我们希望我们的<code>'user -1': 1</code>这个数组是每次加一，然后进行定义变量。</p>
<pre><code class="language-js">const userIds = {
  'user -1': 1
  'user-2': 2
}
</code></pre>
<p>我们可以这样写：</p>
<pre><code class="language-js">let id = 0
const userIds = {
  [`user-${++id}`]: id,
  [`user-${++id}`]: id,
  [`user-${++id}`]: id,
}
</code></pre>
<p>如果我们想要定义一个对象，对象的键是一个数组，对应的每一个值是一个数组，我们可以这样写：</p>
<pre><code class="language-js">const keys = ['name', 'age', 'birthday'];
const values = ['jiegiser', 18, '0501'];
const jiegiser = {
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
  [keys.shift()]: values.shift(),
}
</code></pre>
<h4 id="13-es6-的promise对象">13. ES6  的Promise对象</h4>
<p>如下代码，<code>then</code>里面是执行<code>ajax</code>执行成功之后的回调函数，<code>catch</code>是如果请求出现异常，执行的方法。这里是返回一个<code>promise</code>对象，所以可以继续在外层使用<code>.then()</code>方法。<code>return axios.get(</code>https://api.github.com/users/${username}/repos<code>);</code></p>
<pre><code class="language-js">let username;
const usersPromise = axios.get('https://api.github.com/users');

usersPromise
  .then(response =&gt; {
    username = response.data[0].login;
    return axios.get(`https://api.github.com/users/${username}/repos`);
  })
  .then(response =&gt; {
    console.log(response.data)
  })
  .catch(err =&gt; {
    console.log(err)
  })
</code></pre>
<p>一个<code>promise</code>对象的实例：</p>
<pre><code class="language-js">const p = new Promise((resolve, reject) =&gt; {
  //请求成功执行
  resolve('success');
  // 请求失败的执行
  reject(Error('error'))
})
//请求成功执行的回调
p.then(data =&gt; {
  console.log(data)
})
// 请求失败的执行的回调
  .catch(err =&gt; {console.log(err)})
</code></pre>
<p>如果我们的页面中有多个<code>Promise</code>对象，这些对象之间执行的顺序时不相关的，互不影响的，我们可以使用下面的方法，处理这些<code>Promise</code>对象返回的结果：这里需要注意的是，<code>.all()</code>方法返回的结果是对应的执行<code>Promise</code>对象的结果，返回的是一个数组，我们可以使用对象解构，去得到不同的请求返回的结果。只有当<code>.all()</code>方法里面的<code>Promise</code>对象全部返回的是<code>resolve</code>的时候，才会执行<code>.then()</code>方法。否则执行<code>.catch()</code></p>
<pre><code class="language-js">Promise
  .all([userPromise, movePromise])
  .then(response =&gt; {
    const [users, movice] = response;
    console.log(users);
    console.log(movice);
  })
  .catch(err =&gt; {
    console.log(err)
  })
</code></pre>
<p>与<code>.all()</code>方法相对的是一个·<code>Promise.race()</code>方法，他同样也是处理多个<code>Promise</code>实例，但是，他是处理的<code>Promise</code>实例中，只要第一个<code>Promise</code>实例是执行<code>resolve</code>也就是回调成功，就会去执行<code>.then()</code>方法。否则执行<code>.catch()</code></p>
<h4 id="14-symbol">14. Symbol</h4>
<p><code>symbol</code>是生成一个唯一的标识符，如下代码：</p>
<pre><code class="language-js">const one = Symbol('one')
const two = Symbol('two')

console.log(one === two)//false
</code></pre>
<p>我们可以使用<code>symbol</code>来给 对象定义一个相同属性名，但是值不同：</p>
<pre><code class="language-js">const classRoom = {
  [Symbol('lily')]: {grade: 60, gender: 'female'},
  [Symbol('nina')]: {grade: 80, gender: 'female'},
  [Symbol('nina')]: {grade: 90, gender: 'female'},
}
</code></pre>
<blockquote>
<p><code>symbol</code>类型的值是不能遍历的，如上面的属性，是不能通过<code>for in</code>等进行遍历的。可以使用<code>Object.getOwnPropertySymbols(classRoom)</code>进行遍历,获取到属性名。获取属性值：classrom[Symbol(lily)]这样进行获取，不能通过.的方法进行获取。前面定义<code>symbol</code>属性的时候，是需要使用计算属性的方式进行定义。</p>
</blockquote>
<pre><code class="language-js">const classRoom = {
  [Symbol('lily')]: {grade: 60, gender: 'female'},
  [Symbol('nina')]: {grade: 80, gender: 'female'},
  [Symbol('nina')]: {grade: 90, gender: 'female'},
}
Object.getOwnPropertySymbols(classRoom)
</code></pre>
<h4 id="15-eslint">15. ESLint</h4>
<p>输入命令：<code>npm install eslint -D</code>进行本地安装，然后输入命令进行初始化<code>eslint</code>的配置：<code>eslint --init</code>然后根据自己的需要进行配置，<br>
<img src="https://img-blog.csdnimg.cn/20190604202606357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
输入<code>eslint init.js</code>进行检测我们的文件的书写规范。<br>
<img src="https://img-blog.csdnimg.cn/20190604202851194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
可以输入后面的报错信息到<code>https://eslint.cn/docs/rules/</code>这里进行查看。<br>
我们可以查看前面生成的<code>eslint</code>的规则配置：可以看到我们的规则是继承了<code>&quot;extends&quot;: &quot;eslint:recommended&quot;,</code>也就是<code>https://eslint.cn/docs/rules/</code>这里面标绿色箭头的选项，我们可以在我们的<code>rules</code>里面进行配置我们自己的规则。</p>
<pre><code class="language-js">module.exports = {
    &quot;env&quot;: {
        &quot;browser&quot;: true,
        &quot;commonjs&quot;: true,
        &quot;es6&quot;: true
    },
    &quot;extends&quot;: &quot;eslint:recommended&quot;,
    &quot;parserOptions&quot;: {
        &quot;ecmaVersion&quot;: 2015,
        &quot;sourceType&quot;: &quot;module&quot;
    },
    &quot;rules&quot;: {
        &quot;indent&quot;: [
            &quot;error&quot;,
            4
        ],
        &quot;linebreak-style&quot;: [
            &quot;error&quot;,
            &quot;windows&quot;
        ],
        &quot;quotes&quot;: [
            &quot;error&quot;,
            &quot;single&quot;
        ],
        &quot;semi&quot;: [
            &quot;error&quot;,
            &quot;always&quot;
        ]
    }
};
</code></pre>
<p>禁用<code>eslint</code>，比如说我们写<code>vue</code>的时候，是引入了<code>vue</code>，这个时候<code>eslint</code>会提示，，没有定义<code>vue</code>，我们可以在代码顶部加一个:</p>
<pre><code class="language-js">/*global Vue*/   //把某一个变量当做全局对象使用
</code></pre>
<p>如果想要禁用一个规则，如下：</p>
<pre><code class="language-js"> /*eslint-disable no-new*/   //禁用 no-new 规则
</code></pre>
<p>我们也可以在某一行，重新打开我们禁用的规则：</p>
<pre><code class="language-js"> /*eslint-enable no-new*/   //打开 no-new 规则，关闭禁用no-new
</code></pre>
<p>还有检查<code>html</code>中的<code>js</code>书写，安装<code>eslint-plugin-html</code>插件</p>
<h4 id="16-import-export">16. import  export</h4>
<p>默认导出：一个模块只能有一个默认导出；</p>
<pre><code class="language-js"> const apikey = 'abc123';

 export default apikey;
</code></pre>
<p>默认导出的引入方式：</p>
<pre><code class="language-js">import api from './config.js'
console.log(api)
</code></pre>
<p>命名导出：这里的<code>apikey</code>就是导出的名字，</p>
<pre><code class="language-js">export const apikey = 'abc123';
</code></pre>
<p>引入的时候，必须使用同样的名字，而且，需要使用<code>{}</code>来包裹起来：</p>
<pre><code class="language-js">import { apikey } from './config'
</code></pre>
<p>可以引入多个：</p>
<pre><code class="language-js">import { apikey,a } from './config'
</code></pre>
<p>可以用下面的方式导出多个：</p>
<pre><code class="language-js">export { apikey, age, greet }
</code></pre>
<p>也可以在导出的时候，进行重命名：然后引入的时候，必须使用<code>as</code>命名后的名字；</p>
<pre><code class="language-js">export { apikey as apk, age, greet }
</code></pre>
<p>当然，也可以在引入的时候重新命名：在模块使用的时候，就必须使用重命名的名字；</p>
<pre><code class="language-js">import { apikey as apk, a } from './config'
</code></pre>
<blockquote>
<p>默认导出的，吗唉导入的时候，可以使用任意的命名，而命名导出，需要使用我们导出的名字，在导入的时候，进行导入。<br>
一个第三方包：<code>slug</code>,过滤用户名。还有<code>md5</code>包。</p>
</blockquote>
<p>引入命名导出以及默认导出的变量：<code>User</code>默认导出的内容。</p>
<pre><code class="language-js">import User, { apikey as apk, a } from './config'
</code></pre>
<h4 id="17-使用-systemjs-进行打包">17. 使用 SystemJS 进行打包</h4>
<p>一个非常简单的打包工具，不用进行类似<code>webpack</code>繁琐的配置。我们可以使用<code>jspm.io</code>进行加载<code>npm</code> 或者<code>github</code>上面的包。在标签中引入<code>systemJS</code>，然后进行配置：</p>
<pre><code class="language-js">&lt;script&gt;
System.config({transpiler: 'babel'})

System.import('./main.js')
&lt;/script&gt;
</code></pre>
<p>在<code>js</code>中引入第三方模块的方式也是不一样的，如下：意思就是在<code>npm</code>里面查找我们引入的包，进行引入。</p>
<pre><code class="language-js">import { sum } from 'npm:lodash';
</code></pre>
<p>引入本地模块跟前面是一样的。</p>
<h4 id="18-class">18. Class</h4>
<h5 id="181-class基本用法">18.1 Class基本用法</h5>
<p>是特殊的函数，定义方式：</p>
<pre><code class="language-js">//第一种
class User {

}
//第二种
const User = class {

}
</code></pre>
<p><code>typeof User</code>打印出的结果是<code>function</code>，函数是有函数提升的，而类是没有的。在声明之前使用，会报错。</p>
<blockquote>
<p>这里需要注意的是，类里面定义函数，之间是不需要使用逗号隔开的，加了逗号会报错；</p>
</blockquote>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`)
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<p>静态方法的定义：静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法</p>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`)
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`)
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<p>定义<code>get set</code>方法：</p>
<pre><code class="language-js">class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    info () {
        console.log(`I'm ${this.name}`);
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`);
    }

    set github (value) {
        this.githubName = value;
    }
    get github () {
        return `http://github.com/${this.githubName}`;
    }
}

const jiegiser = new User('jiegiser', 'jiegiser@163.com')

console.log(jiegiser)
</code></pre>
<h5 id="182-class的扩展">18.2 Class的扩展</h5>
<p>在类的定义中，定义方法的时候，也可以使用计算属性的方式进行定义：</p>
<pre><code class="language-js">let methodName = 'info';
class User {
    constructor (name, email) {
        this.name = name;
        this.email = email;
    }
    [methodName] () {
        console.log(`I'm ${this.name}`);
    }
    //静态方法--不能实例化调用，只能在原型对象调用，一般将原型对象里面的方法定义为静态方法
    static descript () {
        console.log(`hi jj`);
    }

    set github (value) {
        this.githubName = value;
    }
    get github () {
        return `http://github.com/${this.githubName}`;
    }
}
</code></pre>
<p>类必须要使用<code>new</code>关键字进行调用。下面是类的继承：注意<code>super(name);</code>进行调用父类构造函数。</p>
<pre><code class="language-js">class Animal {
    constructor (name) {
        this.name  = name;
        this.belly = [];
    }
    eat (food) {
        this.belly.push(food)
    } 
}
class Dog extends Animal {
    constructor (name, age) {
        //在子类中调用父类构造函数
        super(name);
        this.name = name;
        this.age = age;
    }
    bark () {
        console.log(`Barl bark!`);
        
    }
}
const lucky = new Dog('lucky', 2);
</code></pre>
<h5 id="183-class-进行扩展内建对象">18.3 Class 进行扩展内建对象</h5>
<p>我们可以通过<code>class</code>扩展<code>javascript</code>中的内建对象，比如扩展<code>Array</code>对象：</p>
<pre><code class="language-js">class MyArray extends Array {
    constructor () {
        super();
    }
}

const colors = new MyArray();
colors[0] = 'red';
console.log(colors.length);
colors.length = 0;
console.log(colors[0])
</code></pre>
<p>在子类中其实可以通过<code>this</code>来访问父级<code>Array</code>的一些属性跟方法的。这里就是调用了<code>Array</code>的<code>push</code>方法。</p>
<pre><code class="language-js">class movieCollaction {
    constructor (name, ...items) {
        super(...items)
        this.name = name;
    }
    add (item) {
        this.push(item)
    }
    toRated (limit = 10) {
        return this.sort((a, b) =&gt; (a.scores &gt; b.scores) ? -1 : 1).slice(0, limit);
    }
}
const movies = new movieCollaction('favorite movies',
  { name: 'the croods', scored: 8.7},
  { name: 'the days', scored: 9.6},
  { name: 'the shawshank', scored: 9.4},
  { name: 'the summer', scored: 8.0},
);
</code></pre>
<h4 id="19-proxy">19. Proxy</h4>
<p>帮助我们重写对象上的默认方法。比如下面的的方法：</p>
<pre><code class="language-js">const personn = { name: 'jiegiser', age: 200};
// 第一个参数为要代理的对象，第二个参数就是一个对象，包含重写的方法。也就类似vue计算属性
const personProxy = new Proxy(personn, {
    get(target, key) {
        return target[key].toUpperCase();
    },
    set (target, key, value) {
        if(typeof value === 'string'){
            target[key] = value.trim();
        }
    }
})
personProxy.name = 'jie';
</code></pre>
<p><code>Proxy</code>的一个例子：对电话号码进行格式化输出</p>
<pre><code class="language-js">const phonerHandle = {
    set(target, key, value) {
        target[key] = value.match(/[0-9]/g).join('');
    }
    get(target, key) {
        return target[key].replace(/(\d{3})(\d{4})(\d{4})/, '$1-$2-$3');
    }
}
const pgoneNumber = new Proxy({}, phonerHandle)
</code></pre>
<h4 id="20-set">20. Set</h4>
<p>一种唯一的数组，也就是数组中的数据是唯一的，不会重复，不能通过索引进行获取。使用<code>add</code>添加值，<code>delete</code>删除某个值。检验某个值是否存在<code>has</code>，移除所有的元素<code>.clear()</code>。<code>.values</code>是一个<code>set</code>的一个遍历器。可以使用<code>for of</code>进行循环遍历。</p>
<pre><code class="language-js">const colors = new Set();
colors.add('red')
colors.add('green')
colors.add('blue')
</code></pre>
<p>可以使用下面的的方法，进行遍历：</p>
<pre><code class="language-js">const colors = new Set();
colors.add('red')
colors.add('green')
colors.add('blue')
const iterator = colors.values();
iterator.next();
</code></pre>
<p>使用<code>for of</code></p>
<pre><code class="language-js">for (let color of colors) {
    console.log(color)
}
</code></pre>
<p>使用<code>forEach</code>进行遍历;</p>
<pre><code class="language-js">colors.forEach((item, key, ownSet) =&gt; {
    console.log(item,key,ownSet)
})
</code></pre>
<p><code>set</code>接收的是一个可遍历对象，我们也可以传入一个数组，进行初始化：</p>
<pre><code class="language-js">const fruits = new Set(['apple', 'banana', 'mongo'])
</code></pre>
<p><code>weakSet</code>跟<code>set</code>非常相似，只不过，他存储的项只能是对象，不能存储字符串，而且不能通过<code>for of</code>进行循环，他没有迭代器，也不能使用<code>forEach</code>进行循环。他没有<code>clear()</code>清除全部，他可以自己进行检测进行注销对应的数据。</p>
<h4 id="21-map">21. Map</h4>
<p><code>map</code>跟<code>set</code>非常相似，不同的是，<code>map</code>通过<code>.set('key',value)</code>这种方法进行添加元素，他也相当于一个数组，数组中是一个个对象。对象的键可以是任意数据类型;</p>
<pre><code class="language-js">const people = new Map();
people.set('jelly', 23);
people.set('{}',3)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190608133541629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
获取对应的值：</p>
<pre><code class="language-js">people.get('jellu')//传入键
</code></pre>
<p>获取里面j键值对的数量：</p>
<pre><code class="language-js">people.size()
</code></pre>
<p>删除某个项：</p>
<pre><code class="language-js">people.delete('jelly')
</code></pre>
<p>删除所有元素：</p>
<pre><code class="language-js">people.clear()
</code></pre>
<p>循环遍历元素：<br>
<code>forEach</code>进行循环；</p>
<pre><code class="language-js">people.forEach(function(value, key, map) =&gt; {
  console.log(value, key, map)
})
</code></pre>
<p>使用<code>for of</code>进行循环：</p>
<pre><code class="language-js">for ( let [key,value] of people) {
  console.log(key, value)
}
</code></pre>
<p>初始化参数：</p>
<pre><code class="language-js">const fruits= new Map([['apple',6], ['banans', 5]])
</code></pre>
<p><code>wekMap</code>没有<code>size</code>属性，不能循环；他的<code>key</code>必须是对象；垃圾回收机制，会自动回收。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack底层原理及脚手架工具分析]]></title>
        <id>https://jiegiser.github.io/newBlog/post/webpack-di-ceng-yuan-li-ji-jiao-shou-jia-gong-ju-fen-xi</id>
        <link href="https://jiegiser.github.io/newBlog/post/webpack-di-ceng-yuan-li-ji-jiao-shou-jia-gong-ju-fen-xi">
        </link>
        <updated>2019-12-06T01:33:10.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-如何编写一个loader">1. 如何编写一个Loader</h4>
<h5 id="11-实现一个简单的loader">1.1 实现一个简单的Loader</h5>
<p>我们开始写一个打包之后的文件，将<code>js</code>代码中<code>jie</code>这个字符串替换为<code>world</code>的一个<code>loader</code>，首先我们新建一个功能，使用<code>npm init</code>，然后进行安装<code>webpack</code>：<code>npm install webpack webpack-cli --save-dev</code>，安装完之后，新建一个文件及<code>src</code>以及<code>loaders</code>，然后分别在对应的文件夹中新建<code>index.js</code>以及<code>replace.loaders.js</code>文件。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-如何编写一个loader">1. 如何编写一个Loader</h4>
<h5 id="11-实现一个简单的loader">1.1 实现一个简单的Loader</h5>
<p>我们开始写一个打包之后的文件，将<code>js</code>代码中<code>jie</code>这个字符串替换为<code>world</code>的一个<code>loader</code>，首先我们新建一个功能，使用<code>npm init</code>，然后进行安装<code>webpack</code>：<code>npm install webpack webpack-cli --save-dev</code>，安装完之后，新建一个文件及<code>src</code>以及<code>loaders</code>，然后分别在对应的文件夹中新建<code>index.js</code>以及<code>replace.loaders.js</code>文件。</p>
<!-- more -->
<p>然后新建<code>webpack</code>的配置文件<code>webpack.config.js</code>，内容如下：在<code>module</code>使用我们的<code>loader</code></p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [path.resolve(__dirname, './loaders/replace.Loader.js')]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>然后<code>replace.loaders.js</code>文件内容：</p>
<pre><code class="language-js">module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    return source.replace('jie', 'world');
}
</code></pre>
<blockquote>
<ul>
<li>这里不能使用箭头函数，是因为在该函数中，要使用this的指向，<code>webpack</code>在调用<code>loader</code>的时候会进行this指向的变更。如果在定义的时候绑定<code>this</code>，会出现问题</li>
</ul>
</blockquote>
<p><code>index.js</code>中的内容很简单：</p>
<pre><code class="language-js">console.log('hello jie');
</code></pre>
<p>就这样，一个简单的<code>loader</code>就制作好了。在<code>package.json</code>里面配置一个命令<code>&quot;build&quot;: &quot;webpack&quot;</code>进行打包；</p>
<h5 id="12-loader-中的参数传递">1.2  Loader 中的参数传递</h5>
<p>有时候我们需要给我们的<code>loader</code>进行传递参数，可以修改 配置文件<code>webpack.config.js</code>：这里配置<code>loader</code>的<code>use</code>属性也是一个对象，<code>loader</code>就是我们配置的地址，<code>opotion</code>就是我们需要传递的参数。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [{
                loader: path.resolve(__dirname, './loaders/replace.Loader.js'),
                options: {
                    name: 'giser'
                }
            }]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>然后在<code>loader</code>中，接收传进来的参数：</p>
<pre><code class="language-js">module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    console.log(this.query);
    return source.replace('jie', 'world');
}
</code></pre>
<p>可以在官网查看很多<code>API</code>的用法：https://webpack.js.org/api/loaders/ ，在获取传进来的参数的时候，我们可以使用官方推荐的一个<code>loader-utils</code>的模块进行获取参数，输入命令<code>npm install loader-utils --save-dev</code>，然后在我们的<code>loader</code>中进行获取参数：使用<code>getOptions(this)</code>进行获取所有的参数。</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    return source.replace('jie', this.query.name);
}
</code></pre>
<h5 id="13-loader-中多个参数的返回">1.3 Loader 中多个参数的返回</h5>
<p>有时候我们想在我们的<code>loader</code>中，返回很多参数，而现在的只是返回了我们处理后的源代码，<code>this.callback</code>这个函数，可以帮助我们返回更多参数：</p>
<pre><code class="language-js">this.callback(
  err: Error | null,
  content: string | Buffer,
  sourceMap?: SourceMap,
  meta?: any
);
</code></pre>
<p>我们在我们的<code>loader</code>中修改如下：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    // return source.replace('jie', this.query.name);
    const result = source.replace('jie', this.query.name);
    // 第一个参数为错误信息，第二个参数为要返回的内容，第三个参数为sourceMap，第四个参数为返回的其他信息
    this.callback(null, result, source, meta)
}
</code></pre>
<p>而我们现在的代码中没有<code>sourcemap</code>我们可以修改为：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

//这里不能使用箭头函数，是因为在该函数中，要使用this的指向，webpack在调用loader的时候会进行this指向的变更。如果在定义的时候绑定this，会出现问题
module.exports = function(source) {
    //source就是我们调用loader传进来的源码。
    console.log(source)
    //接收传进来的参数
    // console.log(this.query);

    const options = loaderUtils.getOptions(this)
    console.log(options.name)
    // return source.replace('jie', this.query.name);
    const result = source.replace('jie', this.query.name);
    // 第一个参数为错误信息，第二个参数为要返回的内容，第三个参数为sourceMap，第四个参数为返回的其他信息
    this.callback(null, result)
}
</code></pre>
<h5 id="14-loader-中处理异步请求">1.4 Loader 中处理异步请求</h5>
<p>有时候我们需要在<code>loader</code>中处理一些异步请求数据，下面我们用<code>setTimeout</code>来模拟异步数据会获取：</p>
<pre><code class="language-js">const loaderUtils = require('loader-utils')

module.exports = function(source) {
    console.log(source)
    const options = loaderUtils.getOptions(this)
    const callback = this.async();
    setTimeout(() =&gt; {
        const result = source.replace('jie', this.query.name);
        callback(null, result)
    }, 1000);
}
</code></pre>
<p>首先我们声明一个异步操作的函数<code>const callback = this.async();</code>，然后在里面使用该函数，这里需要注意的是<code>this.async</code>异步函数返回的结果也是调用了<code>this.callback</code>这个函数，所以我们第一个参数如果没有错误信息就传递一个<code>null</code>，该参数是必须要传递的。这样就实现了在<code>loader</code>中处理异步请求。</p>
<blockquote>
<ul>
<li>this.async<br>
Tells the loader-runner that the loader intends to call back asynchronously. Returns this.callback.</li>
</ul>
</blockquote>
<h5 id="15-多个-loader-的使用">1.5 多个 Loader 的使用</h5>
<p>如果我们有多个<code>loader</code>进行使用，跟之前的一样，直接在<code>use</code>选项里加上我们需要使用的<code>loader</code>：</p>
<pre><code class="language-js">    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: path.resolve(__dirname, './loaders/replace.Loader.js'),
                options: {
                    name: 'giser'
                }
            }, {
                loader: path.resolve(__dirname, './loaders/replaceLoaderAsync.js'),
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
</code></pre>
<p>我们会发现，如果每次都要加一个<code>loader</code>进行使用的话，都需要写一次<code>path.resolve(__dirname, './loaders/replaceLoaderAsync.js'),</code>这种东西，我们希望的是我们加载自己的<code>loader</code>是跟安装其他第三方包一样，只写<code>loader</code>名称就可以，如下：</p>
<pre><code class="language-js">    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: 'replace.Loader',
                options: {
                    name: 'giser'
                }
            }, {
                loader: 'replaceLoaderAsync',
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
</code></pre>
<p>如果这样，我们可以使用一个<code>reaolveLoader</code>：<code>resolveLoader</code>代码意思是，如果我们引用一个<code>loader</code>，他会先去<code>node_modules</code>中去找如果没有，就去<code>loaders</code>的文件夹中去找。</p>
<pre><code class="language-js">const path = require('path')
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    resolveLoader: {
        modules: ['node_modules', './loaders']
    },
    // 使用我们的loader
    module: {
        rules: [{
            test: /\.js/,
            use: [
                {
                loader: 'replace.Loader',
                options: {
                    name: 'giser'
                }
            }, {
                loader: 'replaceLoaderAsync',
                options: {
                    name: 'giser'
                }
            }
        ]
        }]
    },
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js' 
    }
}
</code></pre>
<p>我们可以使用<code>loader</code>做很多，比如我们一般在代码中加上<code>try{}c atch{}</code>进行捕获异常，但是直接在业务代码中加上这些，会显得代码很乱，而且自己也要加很多这样的语句，很是麻烦，我们可以通过写一个<code>loader</code>，进行帮我们做这些事，在这个<code>loader</code>中，我们进行检测源码，如果有<code>function</code>字符串，就对这个函数添加<code>try{}c atch{}</code>进行捕获异常：</p>
<pre><code class="language-js">try {function () {
}catch(e)}
</code></pre>
<p>还有比如我们有一个网站，会打包输出一个中文版跟英文版本的，我们如果每一个都去修改代码里面标题这些，会很繁琐，我们前面说了，可以在<code>loader</code>中进行传递参数，这样就会获取到全局变量，然后根据这个全局变量进行打包我们的代码，是中文还是英文版本的，我们在元源码中使用一个占位符，进行根据全局变量，来替换这个占位符，从而达到打包输出中文以及英文版本的：<br>
我们的源码：<code>{{title}}</code><br>
然后在<code>loader</code>中：</p>
<pre><code class="language-js">if(Node全局变量 === '中文') {
  source.replace('{{title}}', '中文标题')
} else {
  source.replace('{{title}}', '英文标题')
}
</code></pre>
<p>使用<code>loader</code>可以进行对我们的源代码进行包装。方便我们进行处理一些多而繁琐的操作。</p>
<h4 id="2-如何编写一个-plugin">2. 如何编写一个 Plugin</h4>
<p>首先要知道<code>loader</code>与<code>plugin</code>之间的关系：<code>loader</code>是当我们进行打包我们的文件时，处理不同类型的文件，处理模块。<code>plugiin</code>是在打包的时候具体时刻，进行处理事件，比如我们在每次打包之前清除<code>dist</code>目录下的文件，就会使用<code>clean-webpack-plugin</code>插件进行处理。对于<code>webpack</code>的插件的核心机制或者说设计模式就是事件驱动以及发布模式；他是通过事件来驱动的。首先我们新建一个工程，类似上面的搭建<code>loader</code>的工程，然后新建一个文件夹<code>plugins</code>，里面新建一个<code>copyright-webpack-plugins.js</code>我们的插件，一般来说，插件的命名都是<code>*-webpack-plugin.js</code>这样子的，我们这个插件实现的一个功能就是，给我们每一个页面或者是脚本中添加一个版权的标识，<code>copyright-webpack-plugins.js</code>内容如下：注意这里的插件声明方式，是通过<code>class</code>声明的；</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    constructor () {

    }
    apply (compiler) {

    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>然后在<code>webpack.config.js</code>中使用我们的插件：也正是因为我们前面插件声明是通过<code>class</code>,所以这里需要使用<code>new</code>关键字来进行实例化我们的插件。</p>
<pre><code class="language-js">const path = require('path');

//引入我们的插件
const CopyRightWebpackPlugin = require('./plugins/copyright-webpack-plugin');
module.exports = {
    mode: 'development',
    entry: {
        main: './src/index.js'
    },
    // 使用我们的插件
    plugins: [
        new CopyRightWebpackPlugin()
    ],
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: '[name].js'
    }
}
</code></pre>
<h5 id="21-插件中接收参数">2.1 插件中接收参数</h5>
<p>我们在实例化插件的时候，可以传入参数：</p>
<pre><code class="language-js">    // 使用我们的插件
    plugins: [
        new CopyRightWebpackPlugin({
            name: 'jie'
        })
    ],
</code></pre>
<p>插件的构造函数中会接收我们的插件：这里的<code>options</code>就是我们传递的参数；</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    constructor (options) {
        console.log(options)
    }
    apply (compiler) {

    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190620080557680.png" alt="在这里插入图片描述"><br>
我们现在想做一个就是在打包完成之后要放到<code>dist</code>文件夹的时候，往<code>dist</code>文件夹中增加一个<code>copyright.txt</code>的文件：这里就需要使用<code>apply</code>方法，这里的参数<code>compiler</code>是一个<code>webpack</code>实例，包含<code>webapck</code>打包过程以及配置文件等等，这里有一个<code>compiler.hooks</code>类似于<code>vue</code>中的一些钩子函数，里面有很多时刻，可以查看官方文档：<code>https://webpack.js.org/api/compiler-hooks/#afteremit</code>里面有很多,我们要实现的方法就是在<code>emit</code>时刻执行，<code>emit</code>时刻也就是在打包完成之后要放到<code>dist</code>文件夹的时候。具体实现代码：</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    // constructor (options) {
    //     console.log(options)
    // }
    apply (compiler) {
        compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (complication, cb) =&gt; {  
            //complication存放这次打包的所有的配置内容，compiler是存放所有的配置内容，
            // 打包内容中有哪些文件是放在complication.assets中的，所以我们只需要在complication.assets中
            // 添加一个对象，塞入我们需要添加的文件。
            complication.assets['copyright.txt'] = {
                // 里面的内容
                source: function() {
                    return 'copyright by jie'
                },
                // 文件大小，字符长度
                size: function() {
                    return 16;
                }
            }
            console.log('1111')
            cb();
        })
    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>前面的时刻都是一步的时刻，也就是他返回的是一个<code>AsyncSeriesHook</code>，同步的时刻跟异步时刻实现的方法是不一样的，比如<code>compole</code>时候，代码如下：</p>
<pre><code class="language-js">        compiler.hooks.compile.tap('CopyrightWebpackPlugin', (complication) =&gt; {
            console.log('111')
        })
</code></pre>
<p>我们有时候想知道<code>complication</code>这个对象里面包含的一些属性，直接通过<code>console.log()</code>的方式在控制台中输出时不太直观的，我们可以配置一个命令<code>&quot;debug&quot;: &quot;node node_modules/webpack/bin/webpack.js&quot;</code>通过<code>node</code>的调试工具来进行查看。其实这个命令跟上面我们配置的直接执行<code>webpack</code>效果是一样的，不过这个通过这种我们可以传递一些<code>node</code>的参数，第一个参数<code>inspect</code>是开启<code>node</code>的调试工具，第二个参数<code>inspect-brk</code> 在运行<code>webpack</code>做调试的时候，在第一行代码就打一个断点，运行命令之后，我们就在网页<code>f12</code>会看到下面的东西：随便一个网页，<br>
<img src="https://img-blog.csdnimg.cn/20190620084549211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
点击这个<code>node</code>的图标按钮之后，会跳转到代码的调试，可以看到有断点:<br>
<img src="https://img-blog.csdnimg.cn/20190620085454571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
或者是我们在代码中在需要调试的位置添加<code>debugger</code>然后进行调试：</p>
<pre><code class="language-js">// 定义一个插件
class CopyrightWebpackPlugin {
    // constructor (options) {
    //     console.log(options)
    // }
    apply (compiler) {
        compiler.hooks.compile.tap('CopyrightWebpackPlugin', (complication) =&gt; {
            console.log('111')
        })
        compiler.hooks.emit.tapAsync('CopyrightWebpackPlugin', (complication, cb) =&gt; {  
            //complication存放这次打包的所有的配置内容，compiler是存放所有的配置内容，
            // 打包内容中有哪些文件是放在complication.assets中的，所以我们只需要在complication.assets中
            // 添加一个对象，塞入我们需要添加的文件。
            debugger;
            complication.assets['copyright.txt'] = {
                // 里面的内容
                source: function() {
                    return 'copyright by jie'
                },
                // 文件大小，字符长度
                size: function() {
                    return 16;
                }
            }
            console.log('1111')
            cb();
        })
    }
}
module.exports = CopyrightWebpackPlugin;
</code></pre>
<p>以及我们可以在调试工具的<code>Watch</code>里监听我们需要的监听的对象：<br>
<img src="https://img-blog.csdnimg.cn/2019062008594825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-bundler-源码编写-模块分析">3.  Bundler 源码编写 （模块分析）</h4>
<p>我们实现一个类似于<code>webpack</code>这样的打包工具，来逐渐分析<code>webpack</code>实现打包的原理。首先新建一个<code>bundle</code>文件夹，里面跟上面一样先初始化项目，然后新建<code>dist</code>目录，目录结构如下：<br>
<img src="https://img-blog.csdnimg.cn/20190621075825727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
对应的几个<code>js</code>文件内容也特别简单：<br>
<code>index.js</code>:</p>
<pre><code class="language-js">import message from './message.js';
console.log(message);
</code></pre>
<p><code>message.js</code>:</p>
<pre><code class="language-js">// 后缀.js要写，我们的工具不支持后缀的缩写
import { word } from './word.js';
const message = `say ${word}`;

export default message;
</code></pre>
<p><code>word.js</code>:</p>
<pre><code class="language-js">export const word = 'hello';
</code></pre>
<p>就这样，可以看到我们的项目中，有<code>es6</code>中的<code>import</code>这些语法，直接运行在浏览器，肯定是不可以的，所以我们现在做的就是，写一个类似一些打包工具，进行将我们的代码处理成可以被浏览器识别的代码。在根目录新建一个<code>bundler.js</code>：我们要做的是首先读取入口文件，然后分析入口文件的代码，</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs')

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser')

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    console.log(parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    }));
    console.log(content)
}

moduleAnalyser('./src/index.js')

</code></pre>
<blockquote>
<p>可以安装一个工具<code>npm install cli-highlight -g</code> 用于控制台输出代码高亮。运行时输入命令<code>node bundler.js | highlight</code></p>
</blockquote>
<p>安装一个插件<code>npm install @babel/parser --save</code>用来帮助我们分析读取到的源代码。可以打开官网，查看具体的例子：<code>https://babeljs.io/docs/en/babel-parser</code>,我们查看上面代码打印的内容，输入<code>node bundler.js | highlight</code>，打印结果如下：<br>
<img src="https://img-blog.csdnimg.cn/20190621082531621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
其实这是一个抽象语法树的表述方式，我们可以打印一下该对象的<code>program.body</code>，如下：</p>
<pre><code class="language-js">[ Node {
//第一个节点是import语法声明
    type: 'ImportDeclaration',
    start: 0,
    end: 35,
    loc: SourceLocation { start: [Position], end: [Position] },
    specifiers: [ [Node] ],
    source:
     Node {
       type: 'StringLiteral',
       start: 20,
       end: 34,
       loc: [SourceLocation],
       extra: [Object],
       value: './message.js' } },
  Node {
  //一个表达式的语句，
    type: 'ExpressionStatement',
    start: 37,
    end: 58,
    loc: SourceLocation { start: [Position], end: [Position] },
    expression:
     Node {
       type: 'CallExpression',
       start: 37,
       end: 57,
       loc: [SourceLocation],
       callee: [Node],
       arguments: [Array] } } ]
</code></pre>
<p>可以看到分析的抽象语法树，很好的将我们的<code>js</code>代码转换成了<code>js</code>对象。我们现在需要的是拿到我们代码中所有的依赖关系，也就是读取到<code>import</code>的节点，然后去分析里面的内容，可以去循环这个对象的<code>program.body</code>然后找到<code>type = 'ImportDeclaration'</code>,但是是有点麻烦，我们可以借助一个工具，输入命令安装：<code>npm install --save @babel/traverse</code>，然后我们使用，代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容，因为默认导出是export module
const traverse =  require('@babel/traverse').default; 


//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件
    const dependencies = []

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            console.log(node)
        }
    })
}

moduleAnalyser('./src/index.js')
</code></pre>
<p>存放依赖的文件,查看打印的内容，我们可以看到<code>source</code>中的<code>value</code>存放着依赖的文件的地址<br>
<img src="https://img-blog.csdnimg.cn/20190621085109520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NqOTU1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
然后我们将节点中的<code>node.source.value</code>值存放到依赖的文件，也就是<code>dependencies</code>变量中：我们可以看到我们获取的地址是一个相对路径，相对于<code>src</code>目录的，真正做打包的时候，我们希望我们获取的地址是一个相对路径，或者是相对于根目录的路径，我们可以利用<code>nodeJS</code>中的<code>path</code>模块，来解决这个问题，</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+path.join(dirname, node.source.value);
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    })
    return {
        filename,
        dependencies
    }
}

moduleAnalyser('./src/index.js')

</code></pre>
<p>我们这个时候只是分析了代码中的<code>import</code>的引入方式，我们要做的是把原始的代码打包编译之后能在浏览器上运行，所以我们需要借助一个工具：<code>npm install @babel/core --save</code>对代码进行转换，他是<code>babel</code>的一个核心模块，可以利用<code>babel.transformFromAst</code>函数将抽象语法树转换为可以运行的代码，我们还利用<code>babel/preset-env</code>来将<code>es6</code>语法转换为<code>es5</code>的语法：<code>npm install @babel/preset-env --save</code>进行安装，实现代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+path.join(dirname, node.source.value);
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}

const moduleInfo = moduleAnalyser('./src/index.js');
console.log(moduleInfo)

</code></pre>
<p>上面的代码是将我们的入口文件进行了分析，并转换成了可以在浏览器上运行的代码，接下来我们要实现将入口文件依赖的文件也进行分析，并转换为在浏览器上可以运行的代码，代码如下：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+ path.join(dirname, node.source.value).replace('\\', '/');
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}
// 依赖图谱，存储所有模块的依赖信息,entry是入口文件，我们要分析整个项目所有的文件；
const makeDependenciesGraph = (entry) =&gt; {
    const entryModule = moduleAnalyser(entry);
    // 利用队列的方法，循环递归获取模块中的依赖文件进行分析
    const graphArry = [entryModule];
    for(let i = 0; i &lt; graphArry.length; i++) {
        const item = graphArry[i];
        const { dependencies } = item;
        if (dependencies) {
            // for in 循环对象
            for(let j in dependencies) {
                graphArry.push(
                    moduleAnalyser(dependencies[j])
                );
            }
        }
    }
    // 将数组进行转换为对象
    const graph = {};
    graphArry.forEach(item =&gt; {
        graph[item.filename] = {
            dependencies: item.dependencies,
            code: item.code
        }
    })
    return graph;
}
const graphInfo = makeDependenciesGraph('./src/index.js');
console.log(graphInfo);
</code></pre>
<p>上面的代码是获取到了整个项目中代码的依赖以及依赖的分析结果，接下来，我们要实现的是将这些分析结果变成真正能够在浏览器上运行的代码：</p>
<pre><code class="language-js">// nodeJS中的模块，用于获取文件信息
const fs = require('fs');

// 引入babel/parser用来分析我们的源代码
const parser = require('@babel/parser');

// 引入babel/traverse来帮助我们分析抽象语法树中 type = 'ImportDeclaration' 的节点,default是我们使用export default导出的内容
const traverse =  require('@babel/traverse').default; 

// 引入nodeJS的核心模块 path
const path = require('path');

// 引入babel/core来准换我们的代码
const babel = require('@babel/core');

//filename为要分析的入口文件
const moduleAnalyser = (filename) =&gt; {
    // 读取文件中的内容，第一个参数为文件地址，第二个参数为文件编码方式
    const content = fs.readFileSync(filename, 'utf-8')
    const ast = parser.parse(content, {
        // 如果要对于es6语法的代码进行分析，需要传入一个sourceType选项，sourceType: 'module'
        sourceType: 'module'
    });
    // 存放依赖的文件- 相对路径与绝对路径
    const dependencies = {}

    // 第一个参数为抽象语法树类型的参数，第二个参数为需要查找的内容,
    // 这里我们查找ImportDeclaration节点的内容，只要包含他，就会走这个函数，
    traverse(ast, {
        // 获取到该节点的node节点
        ImportDeclaration({ node }) {
            // 获取到filename的路径 也就是主入口文件的路径 ./src
            const dirname = path.dirname(filename);
            // 将相对路径转换为绝对路径 ./src/message.js
            const newFile = './'+ path.join(dirname, node.source.value).replace('\\', '/');
            // 存储相对路径与绝对路径
            dependencies[node.source.value] = newFile;
            // dependencies.push(newFile);
        }
    });
    // 借助babel的transformFromAst方法将抽象语法树转换为可以运行的代码。
    // 第一个参数是一个抽象语法树，第二个参数是sourceCode，第三个参数是一些转换的Options
    // 这里解析后的code 就是可以在浏览器运行的代码
    const { code } = babel.transformFromAst(ast, null, {
        // 插件的集合-将es6语法转换为es5
        presets: [&quot;@babel/preset-env&quot;]
    });
    return {
        filename,
        dependencies,
        code
    }
}
// 依赖图谱，存储所有模块的依赖信息,entry是入口文件，我们要分析整个项目所有的文件；
const makeDependenciesGraph = (entry) =&gt; {
    const entryModule = moduleAnalyser(entry);
    // 利用队列的方法，循环递归获取模块中的依赖文件进行分析
    const graphArry = [entryModule];
    for(let i = 0; i &lt; graphArry.length; i++) {
        const item = graphArry[i];
        const { dependencies } = item;
        if (dependencies) {
            // for in 循环对象
            for(let j in dependencies) {
                graphArry.push(
                    moduleAnalyser(dependencies[j])
                );
            }
        }
    }
    // 将数组进行转换为对象
    const graph = {};
    graphArry.forEach(item =&gt; {
        graph[item.filename] = {
            dependencies: item.dependencies,
            code: item.code
        }
    })
    return graph;
}

const generateCode = (entry) =&gt; {
    //const graph = makeDependenciesGraph(entry);
    const graph = JSON.stringify(makeDependenciesGraph(entry));
    // 这里使用闭包的形式，是为了防止执我们的代码污染到全局。
    return `
      (function(graph){
          //构造require以及exports函数
          function require(module) {
              function localRequire(relativePath) {
                  return require(graph[module].dependencies[relativePath])
              }
              var exports = {};
              (function(require, exports, code){
                //执行代码  
                eval(code)
              })(localRequire, exports, graph[module].code)
              return exports;
          };
          require('${entry}')
      })(${graph});
    `;
}
const code = generateCode('./src/index.js');
console.log(code)

</code></pre>
<h4 id="4-通过-createreactapp-深入学习-webpack-配置">4. 通过 CreateReactApp 深入学习 Webpack 配置</h4>
<p>使用命令<code>npx create-react-app my-app</code> 创建一个<code>react</code>项目，我们可以运行命令<code>npm run eject</code>暴露项目配置，就可以看到有关<code>webpack</code>的配置信息，有可能你会出现下面的错误：</p>
<pre><code class="language-js">Remove untracked files, stash or commit any changes, and try again.
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! my-app@0.1.0 eject: `react-scripts eject`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the my-app@0.1.0 eject script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\Dell\AppData\Roaming\npm-cache\_logs\2019-06-22T06_24_24_879Z-debug.log
</code></pre>
<p>这个是<code>git</code>配置的问题，是因为我们使用脚手架创建一个项目的时候，自动给我们增加了一个<code>.gitignore</code>文件，而我们本地却没有文件仓库，我们只需要将我们的项目添加到我们本地的仓库，输入下面命令：</p>
<pre><code class="language-js">git add .
git commit -m &quot;create app&quot;
npm run eject
</code></pre>
<p>就可以了。我们可以看到项目中会多出现几个文件夹，查看<code>Script</code> 中的<code>build.js</code>文件，里面就是打包流程的逻辑代码，主要的配置文件是在<code>config</code>文件夹中的<code>webpack.config.js</code>中。<code>path.js</code>中主要是存储整个项目的一些路径信息，<code>env.js</code>初始化项目运行环境的文件。<code>webpackDevServer.config.js</code>文件。具体查看配置源码，进行深入。</p>
<h4 id="5-vue-cli-30">5. Vue cli 3.0</h4>
<p><code>vue</code>的脚手架工具，并没有像<code>react</code>的一样可以通过命令暴露项目配置，他也是有一套默认的配置，如果想要修改默认配置，需要添加一个<code>vue.config.js</code>的配置文件，然后安装官网给出的配置参数进行配置，那些配置参数都是<code>vue-cli</code>通过封装了的参数。查看一些配置参数：https://cli.vuejs.org/zh/config/#css-loaderoptions，我们可能会想，<code>vue</code>是如何将自己的配置转换成了<code>webpack</code>的配置文件，可以在<code>node_module</code>中找到<code>@vue</code>中的<code>vli-service</code>中<code>lib</code>的<code>service.js</code>文件，这个文件就是打包的时候进行转换的。</p>
<p>对于<code>webpack</code>配置的学习可以查看官网，一般基础的配置可以查看<code>guides</code>中的内容，如果要查看深入的配置可以看看<code>configuration</code>里面的内容，如果想要写一些<code>loader</code>或者是<code>plugin</code>可以查看<code>api</code>相关的内容。</p>
<p>在<code>vue-cli</code>中，访问项目中的静态资源文件，必须要通过<code>require()</code>函数进行加载，我们可以修改<code>webpack</code>配置，增加如下配置：这样<code>static</code>目录中的文件在外部也可以进行访问了，告诉服务器从哪里提供内容。只有在您想要提供静态文件时才需要这样做。</p>
<pre><code class="language-js">const path = require('path');

module.exports = {
	devServer: {
		contentBase: [path.resolve(__dirname, 'static')],
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法]]></title>
        <id>https://jiegiser.github.io/newBlog/post/suan-fa</id>
        <link href="https://jiegiser.github.io/newBlog/post/suan-fa">
        </link>
        <updated>2019-12-06T00:54:38.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1-动态规划算法">1. 动态规划算法：</h4>
<p>题目：<br>
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1-动态规划算法">1. 动态规划算法：</h4>
<p>题目：<br>
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。</p>
<!-- more -->
<p>'?' 可以匹配任何单个字符。<br>
'*' 可以匹配任意字符串（包括空字符串）。<br>
两个字符串完全匹配才算匹配成功。<br>
说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/wildcard-matching</p>
<pre><code class="language-js">var isMatch = function(s, p) {
  let cur = new Array(s.length + 1).fill(false)
  cur[0] = true
  
  for (const c of p) {
    if (c == '*'){
      let begin = cur.indexOf(true)
      if (begin == -1) {
        return false
      }
      cur.fill(true, begin)
    } else {
      for(let j = s.length;j &gt; 0; --j){
        cur[j] = (c == '?' || c == s[j-1]) &amp;&amp; cur[j-1]
      }
      cur[0] = false
    }

  }
  return cur[s.length]

};
</code></pre>
<h4 id="2-两数相加">2. 两数相加</h4>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<pre><code class="language-js">给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<p>解答：</p>
<pre><code class="language-js">// 第一种
var twoSum = function(nums, target) {
    let re = []
    for (let i = 0;i&lt;nums.length;i++){
        let item = nums[i]
        let j = nums.indexOf(target-item)
        if (j &gt; -1) {
            if (j !==i){
              return [i, j]
            }

        }
    }
};

// 第二种
var twoSum = function (nums, target) {
    let map = {};
    for (let i = 0, len = nums.length; i &lt; len; i++) {
        let num = target - nums[i];
        if (typeof map[nums[i]] === 'number') return [map[nums[i]], i];
        map[num] = i;
    }
};

// 第三种 （超出输出范围？）
var twoSum = function(nums, target) {
    for(let j =0;j&lt;nums.length;j ++) {
        console.log(j,nums[j])
      for(i=nums.length-1 ;i &gt;j; i--) {
          console.log(nums[j],nums[i])
          if(nums[j] + nums[i] === target) {
              return [i, j]
          }
      }  
    }
};
</code></pre>
]]></content>
    </entry>
</feed>